<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 3]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Grammar-Aware Literate Generative Mathematical Programming with Compiler-in-the-Loop](https://arxiv.org/abs/2601.17670)
*Roberto Rossi,Steven D. Prestwich*

Main category: cs.PL

TL;DR: SyntAGM：基于代数建模语言和编译器引导的生成式数学规划系统，通过生成-编译-评估-修订循环将自然语言问题描述转换为PyOPL模型


<details>
  <summary>Details</summary>
Motivation: 研究如何通过代数建模语言和编译器引导的模型合成来实现生成式数学规划，解决自然语言到数学规划模型的自动转换问题

Method: 提出SyntAGM端到端系统，利用PyOPL AML编译器提供语法诊断，通过生成-编译-评估-修订循环，结合上下文BNF语法学习和少样本检索，使用编译器反馈和基于LLM的对齐判断器

Result: 在对比研究中，SyntAGM相比现有提示基准实现了具有竞争力的准确性，并具有更优的token消耗、成本和延迟性能

Conclusion: SyntAGM展示了编译器引导的模型合成在生成式数学规划中的有效性，为自然语言到代数建模语言的转换提供了高效解决方案

Abstract: This work investigates generative mathematical programming through the lens of Algebraic Modelling Languages (AMLs) and compiler-guided model synthesis. By leveraging PyOPL, an OPL-like AML compiler that provides detailed syntax diagnostics, we introduce SyntAGM, an end-to-end system that translates natural language problem descriptions into PyOPL models via a generate--compile--assess--revise loop. SyntAGM is grammar-aware thanks to in-context exposure to the PyOPL BNF grammar, and benefits from few-shot retrieval of literate PyOPL model exemplars. To obtain a valid PyOPL model that matches the problem description, SyntAGM mobilises compiler feedback and an LLM-based alignment judge. In a comparative study against established prompting baselines SyntAGM achieves competitive accuracy with superior token, cost, and latency profiles.

</details>


### [2] [Types for Grassroots Logic Programs](https://arxiv.org/abs/2601.17957)
*Ehud Shapiro*

Main category: cs.PL

TL;DR: 该论文提出了Typed GLP（类型化Grassroots Logic Programs），为GLP并发逻辑编程语言开发了类型系统，通过模态路径捕获通信方向性，支持交互式部分计算的类型检查，并展示了AI辅助的类型驱动开发方法。


<details>
  <summary>Details</summary>
Motivation: GLP作为并发逻辑编程语言，支持丰富的多向通信模式，但缺乏类型系统。在AI编程的背景下，让AI直接编写复杂的GLP通信代码风险较高。论文旨在为GLP开发类型系统，使人类设计师和AI能够基于类型规范协作开发，提高代码可靠性和开发效率。

Method: 1. 将类型定义为模态路径的正则集合，模态捕获通信方向性（消费或生产）；2. 提供语法上的良类型定义；3. 证明程序良类型当且仅当其模态原子语义的路径抽象满足协变和逆变条件；4. 实现从数学规范到英文规范再到Dart代码的AI驱动实现流程。

Result: 1. 建立了GLP的类型系统，能够对交互式部分计算进行类型检查，包括可能死锁、失败或不终止的计算；2. 证明了类型系统的形式化性质（良类型等价于协变/逆变条件）；3. 在Dart中实现了GLP类型系统，展示了从数学规范到代码的AI辅助开发流程。

Conclusion: 论文成功为GLP开发了类型系统，支持交互式并发计算的类型检查。更重要的是，提出了AI辅助的类型驱动开发方法：人类与AI协作定义类型、类型声明和过程描述，然后让AI基于这些规范编写代码。这种方法提高了复杂通信模式编程的可靠性和可维护性。

Abstract: Grassroots Logic Programs (GLP) is a concurrent logic programming language in which logic variables are partitioned into paired readers and writers. An assignment is produced at most once via a writer and consumed at most once via its paired reader, and may contain additional readers and/or writers. This enables the concise expression of rich multidirectional communication modalities.
  ``Logic Programs as Types for Logic Programs'' (LICS'91) defined types as regular sets of paths over derivable ground atoms. Here, we define types to be regular sets of moded paths, where a mode captures directionality of communication -- whether a subterm is consumed from or produced to the environment -- enabling the typing of interactive partial computations including those that eventually deadlock or fail, or never terminate. We provide a syntactic definition of well-typing and prove that a program is well-typed iff the path abstraction of its moded-atom semantics satisfies covariance and contravariance conditions with respect to its type.
  The GLP type system was implemented in Dart by AI, starting from a mathematical specification of Typed GLP (this paper), deriving from it an English spec (written by AI), and from the spec deriving Dart code (by AI). While GLP is naturally untyped, the motivation for Typed GLP comes from programming with AI: Asking AI to program complex communication modalities in GLP (and in general) and hoping for the best is a tenuous strategy. The emerging discipline we advocate and employ is for the human designer and AI to jointly develop and agree upon (1)~GLP types; (2)~GLP procedure type declarations; (3)~informal (English) descriptions of the procedures; and only then let AI attempt to write (4)~GLP code based on those.

</details>


### [3] [Handling Scope Checks (Extended Version)](https://arxiv.org/abs/2601.18793)
*Michael Lee,Ningning Xie,Oleg Kiselyov,Jeremy Yallop*

Main category: cs.PL

TL;DR: 该论文首次形式化研究动态作用域外溢检查，提出λ⟨⟨op⟩⟩演算来描述和评估检查，引入新颖的"Cause-for-Concern"动态检查并证明其正确性，同时扩展框架包含精化环境分类器进行静态预防。


<details>
  <summary>Details</summary>
Motivation: 元编程和效应处理器的交互会产生意外问题，特别是作用域外溢（生成作用域不当的代码）。现有静态类型系统存在实现和可用性问题，而动态检查（如MetaOCaml中）在理论上研究不足，缺乏对元语言设计者的指导。

Method: 提出λ⟨⟨op⟩⟩演算形式化框架来描述和评估动态作用域外溢检查；引入新颖的"Cause-for-Concern"动态检查并证明其正确性；扩展框架包含精化环境分类器进行静态预防；比较动态检查与静态方法的表达能力。

Result: 首次形式化研究了动态作用域外溢检查；提出的"Cause-for-Concern"检查被证明正确且结合了现有动态检查的优点；建立了动态检查的形式化理论基础；比较了动态检查与精化环境分类器的表达能力。

Conclusion: 该研究填补了动态作用域外溢检查理论研究的空白，为元语言设计者提供了形式化指导；提出的"Cause-for-Concern"检查是现有动态检查的改进；框架扩展展示了静态和动态方法在防止作用域外溢方面的不同表达能力。

Abstract: Metaprogramming and effect handlers interact in unexpected, and sometimes undesirable, ways. One example is scope extrusion: the generation of ill-scoped code. Scope extrusion can either be preemptively prevented, via static type systems, or retroactively detected, via dynamic checks. Static type systems exist in theory, but struggle with a range of implementation and usability problems in practice. In contrast, dynamic checks exist in practice (e.g. in MetaOCaml), but are understudied in theory. Designers of metalanguages are thus given little guidance regarding the design and implementation of checks. We present the first formal study of dynamic scope extrusion checks, introducing a calculus ($λ_{\langle\langle\text{op}\rangle\rangle}$) for describing and evaluating checks. Further, we introduce a novel dynamic check $\unicode{x2014}$ the "Cause-for-Concern" check $\unicode{x2014}$ which we prove correct, characterise without reference to its implementation, and argue combines the advantages of existing dynamic checks. Finally, we extend our framework with refined environment classifiers, which statically prevent scope extrusion, and compare their expressivity with the dynamic checks.

</details>

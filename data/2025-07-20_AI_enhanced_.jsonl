{"id": "2507.12918", "categories": ["cs.LO"], "pdf": "https://arxiv.org/pdf/2507.12918", "abs": "https://arxiv.org/abs/2507.12918", "authors": ["Jan-Christoph Kassing", "Leon Spitzer", "J\u00fcrgen Giesl"], "title": "Dependency Pairs for Expected Innermost Runtime Complexity and Strong Almost-Sure Termination of Probabilistic Term Rewriting", "comment": null, "summary": "The dependency pair (DP) framework is one of the most powerful techniques for\nautomatic termination and complexity analysis of term rewrite systems. While\nDPs were extended to prove almost-sure termination of probabilistic term\nrewrite systems (PTRSs), automatic complexity analysis for PTRSs is largely\nunexplored. We introduce the first DP framework for analyzing expected\ncomplexity and for proving positive or strong almost-sure termination (SAST) of\ninnermost rewriting with PTRSs, i.e., finite expected runtime. We implemented\nour framework in the tool AProVE and demonstrate its power compared to existing\ntechniques for proving SAST.", "AI": {"tldr": "The paper introduces a DP framework for analyzing expected complexity and proving termination in probabilistic term rewrite systems (PTRSs), implemented in AProVE.", "motivation": "Automatic complexity analysis for PTRSs is largely unexplored, despite the success of DP frameworks in termination analysis.", "method": "The authors extend the DP framework to analyze expected complexity and prove SAST for PTRSs, focusing on innermost rewriting.", "result": "The framework is implemented in AProVE and outperforms existing techniques for proving SAST.", "conclusion": "The work fills a gap in PTRS analysis and demonstrates practical effectiveness through AProVE."}}
{"id": "2507.13057", "categories": ["cs.LO"], "pdf": "https://arxiv.org/pdf/2507.13057", "abs": "https://arxiv.org/abs/2507.13057", "authors": ["Gianluca Curzi", "Lukas Melgaard"], "title": "Cyclic proof theory of positive inductive definitions", "comment": "27 pages", "summary": "We study cyclic proof systems for $\\mu\\mathsf{PA}$, an extension of Peano\narithmetic by positive inductive definitions that is arithmetically equivalent\nto the (impredicative) subsystem of second-order arithmetic\n$\\Pi^1_2$-$\\mathsf{CA}_0$ by M\\\"{o}llefeld. The main result of this paper is\nthat cyclic and inductive $\\mu\\mathsf{PA}$ have the same proof-theoretic\nstrength. First, we translate cyclic proofs into an annotated variant based on\nSprenger and Dam's systems for first-order $\\mu$-calculus, whose stronger\nvalidity condition allows for a simpler proof of soundness. We then formalise\nthis argument within $\\Pi^1_2$-$\\mathsf{CA}_0$, leveraging M\\\"{o}llerfeld's\nconservativity properties. To this end, we build on prior work by Curzi and Das\non the reverse mathematics of the Knaster-Tarski theorem. As a byproduct of our\nproof methods we show that, despite the stronger validity condition, annotated\nand \"plain\" cyclic proofs for $\\mu\\mathsf{PA}$ prove the same theorems. This\nwork represents a further step in the non-wellfounded proof-theoretic analysis\nof theories of arithmetic via impredicative fragments of second-order\narithmetic, an approach initiated by Simpson's Cyclic Arithmetic, and continued\nby Das and Melgaard in the context of arithmetical inductive definitions.", "AI": {"tldr": "Cyclic and inductive $\\mu\\mathsf{PA}$ have the same proof-theoretic strength, shown via translation into annotated cyclic proofs and formalization in $\\Pi^1_2$-$\\mathsf{CA}_0$.", "motivation": "To analyze cyclic proof systems for $\\mu\\mathsf{PA}$ and compare their strength with inductive proofs, leveraging impredicative second-order arithmetic.", "method": "Translate cyclic proofs into annotated variants, formalize in $\\Pi^1_2$-$\\mathsf{CA}_0$, and use conservativity properties.", "result": "Cyclic and inductive $\\mu\\mathsf{PA}$ are equally strong; annotated and plain cyclic proofs prove the same theorems.", "conclusion": "Advances non-wellfounded proof theory for arithmetic, connecting cyclic proofs to impredicative second-order arithmetic."}}
{"id": "2507.13058", "categories": ["cs.LO"], "pdf": "https://arxiv.org/pdf/2507.13058", "abs": "https://arxiv.org/abs/2507.13058", "authors": ["Quentin Aristote"], "title": "Monotone weak distributive laws over the lifted powerset monad in categories of algebras", "comment": "Preprint of a STACS 2025 paper: contains additional remarks and\n  proofs", "summary": "Noticing the similarity between the monotone weak distributive laws combining\ntwo layers of nondeterminism in sets and in compact Hausdorff spaces, we study\nwhether the latter law can be obtained automatically as a weak lifting of the\nformer. This holds partially, but does not generalize to other categories of\nalgebras: we then characterize when exactly monotone weak distributive laws\nover powerset monads in categories of algebras exist, exhibiting a law\ncombining probabilities and non-determinism in compact Hausdorff spaces and\nshowing on the other hand that such laws do not exist in a lot of other cases.", "AI": {"tldr": "The paper explores whether monotone weak distributive laws in compact Hausdorff spaces can generalize from sets, finding partial success and characterizing their existence in algebra categories.", "motivation": "To investigate the generalization of monotone weak distributive laws from sets to compact Hausdorff spaces and other algebraic categories.", "method": "Study the weak lifting of laws, characterize conditions for existence, and test applicability in various categories.", "result": "Partial generalization to compact Hausdorff spaces; laws exist for probabilities and non-determinism there but fail in many other cases.", "conclusion": "Monotone weak distributive laws are context-dependent, with limited generalizability beyond specific algebraic structures."}}
{"id": "2507.13178", "categories": ["cs.LO"], "pdf": "https://arxiv.org/pdf/2507.13178", "abs": "https://arxiv.org/abs/2507.13178", "authors": ["Marcus Gelderie", "Maximilian Luff", "Maximilian Peltzer"], "title": "Impact and Performance of Randomized Test-Generation using Prolog", "comment": "Under consideration in Theory and Practice of Logic Programming\n  (TPLP)", "summary": "We study randomized generation of sequences of test-inputs to a system using\nProlog. Prolog is a natural fit to generate test-sequences that have complex\nlogical inter-dependent structure. To counter the problems posed by a large (or\ninfinite) set of possible tests, randomization is a natural choice. We study\nthe impact that randomization in conjunction with SLD resolution have on the\ntest performance. To this end, this paper proposes two strategies to add\nrandomization to a test-generating program. One strategy works on top of\nstandard Prolog semantics, whereas the other alters the SLD selection function.\nWe analyze the mean time to reach a test-case, and the mean number of generated\ntest-cases in the framework of Markov chains. Finally, we provide an additional\nempirical evaluation and comparison between both approaches. Under\nconsideration in Theory and Practice of Logic Programming (TPLP).", "AI": {"tldr": "Randomized test-input generation in Prolog using two strategies: one preserves standard Prolog semantics, the other alters SLD resolution. Analyzed via Markov chains and empirical evaluation.", "motivation": "Address the challenge of generating test-sequences with complex logical interdependencies efficiently, especially for large or infinite test sets.", "method": "Two randomization strategies: one modifies standard Prolog semantics, the other changes the SLD selection function. Analyzed using Markov chains for performance metrics.", "result": "Evaluation shows impact of randomization on test performance, comparing mean time to reach test-cases and number of generated cases.", "conclusion": "Proposes effective randomization methods for Prolog-based test generation, with empirical validation."}}
{"id": "2507.12640", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2507.12640", "abs": "https://arxiv.org/abs/2507.12640", "authors": ["Tom Smeding", "Miko\u0142aj Konarski", "Simon Peyton Jones", "Andrew Fitzgibbon"], "title": "Dual-Numbers Reverse AD for Functional Array Languages", "comment": null, "summary": "The standard dual-numbers construction works well for forward-mode automatic\ndifferentiation (AD) and is attractive due to its simplicity; recently, it also\nhas been adapted to reverse-mode AD, but practical performance, especially on\narray programs, leaves a lot to be desired. In this paper we introduce\nfirst-class support for multidimensional arrays in dual-numbers reverse-mode AD\nwith little to no performance overhead. The algorithm consists of three\nloosely-coupled components: a semantics-preserving vectorisation code\ntransformation (the bulk-operation transform or BOT), a fairly straightforward\nlifting of the basic dual-numbers reverse AD algorithm to a mostly first-order\narray language, and symbolic interpretation to achieve an end-to-end\ncompilation pipeline. Unfortunately, we lose some of the nice generalisable\naspects of dual-numbers AD in the process, most importantly support for\nhigher-order code.\n  We do support some higher-order array combinators, but only a\ncarefully-chosen set: 'build' (elementwise array construction), 'gather' and\n'scatter'. In return, the BOT can eliminate the essential (for AD)\nhigher-orderness of the input program, meaning that AD gets essentially\npresented with a first-order program. This allows the naive trick of lifting\ndual numbers to \"dual arrays\" to work without much modification.", "AI": {"tldr": "The paper introduces a method for efficient reverse-mode automatic differentiation (AD) on multidimensional arrays using dual numbers, addressing performance issues in existing approaches.", "motivation": "Existing dual-numbers reverse-mode AD methods perform poorly on array programs, prompting the need for a more efficient solution.", "method": "The approach combines vectorisation (BOT), lifting dual-numbers AD to an array language, and symbolic interpretation for compilation.", "result": "The method achieves efficient AD on arrays with minimal overhead but sacrifices support for higher-order code.", "conclusion": "The trade-off between efficiency and generality is justified by the practical performance gains for array programs."}}
{"id": "2507.12472", "categories": ["cs.SE", "cs.CL"], "pdf": "https://arxiv.org/pdf/2507.12472", "abs": "https://arxiv.org/abs/2507.12472", "authors": ["Lingzhe Zhang", "Tong Jia", "Mengxi Jia", "Yifan Wu", "Aiwei Liu", "Yong Yang", "Zhonghai Wu", "Xuming Hu", "Philip S. Yu", "Ying Li"], "title": "A Survey of AIOps in the Era of Large Language Models", "comment": "Accepted By CSUR, an extended version of \"A Survey of AIOps for\n  Failure Management in the Era of Large Language Models\" [arXiv:2406.11213]", "summary": "As large language models (LLMs) grow increasingly sophisticated and\npervasive, their application to various Artificial Intelligence for IT\nOperations (AIOps) tasks has garnered significant attention. However, a\ncomprehensive understanding of the impact, potential, and limitations of LLMs\nin AIOps remains in its infancy. To address this gap, we conducted a detailed\nsurvey of LLM4AIOps, focusing on how LLMs can optimize processes and improve\noutcomes in this domain. We analyzed 183 research papers published between\nJanuary 2020 and December 2024 to answer four key research questions (RQs). In\nRQ1, we examine the diverse failure data sources utilized, including advanced\nLLM-based processing techniques for legacy data and the incorporation of new\ndata sources enabled by LLMs. RQ2 explores the evolution of AIOps tasks,\nhighlighting the emergence of novel tasks and the publication trends across\nthese tasks. RQ3 investigates the various LLM-based methods applied to address\nAIOps challenges. Finally, RQ4 reviews evaluation methodologies tailored to\nassess LLM-integrated AIOps approaches. Based on our findings, we discuss the\nstate-of-the-art advancements and trends, identify gaps in existing research,\nand propose promising directions for future exploration.", "AI": {"tldr": "Survey on LLMs in AIOps, analyzing 183 papers to explore data sources, task evolution, methods, and evaluation, with future research directions.", "motivation": "Understand impact, potential, and limitations of LLMs in AIOps due to lack of comprehensive research.", "method": "Survey of 183 papers (2020-2024) addressing four research questions on data, tasks, methods, and evaluation.", "result": "Identified advancements, trends, and gaps in LLM4AIOps, highlighting novel tasks and evaluation needs.", "conclusion": "Proposes future research directions to address gaps and leverage LLMs for AIOps optimization."}}
{"id": "2507.13198", "categories": ["cs.LO", "cs.DC", "F.3.1"], "pdf": "https://arxiv.org/pdf/2507.13198", "abs": "https://arxiv.org/abs/2507.13198", "authors": ["Rob van Glabbeek", "Bas Luttik", "Myrthe Spronck"], "title": "Just Verification of Mutual Exclusion Algorithms", "comment": "An abbreviated version of this paper will appear in Proc. CONCUR'25", "summary": "We verify the correctness of a variety of mutual exclusion algorithms through\nmodel checking. We look at algorithms where communication is via shared\nread/write registers, where those registers can be atomic or non-atomic. For\nthe verification of liveness properties, it is necessary to assume a\ncompleteness criterion to eliminate spurious counterexamples. We use justness\nas completeness criterion. Justness depends on a concurrency relation; we\nconsider several such relations, modelling different assumptions on the working\nof the shared registers. We present executions demonstrating the violation of\ncorrectness properties by several algorithms, and in some cases suggest\nimprovements.", "AI": {"tldr": "Model checking verifies mutual exclusion algorithms using shared registers, with justness as a completeness criterion for liveness.", "motivation": "To ensure correctness of mutual exclusion algorithms under various register assumptions.", "method": "Model checking with atomic/non-atomic shared registers and justness for liveness.", "result": "Identified violations in algorithms and suggested improvements.", "conclusion": "Justness effectively eliminates spurious counterexamples, aiding in algorithm verification and refinement."}}
{"id": "2507.13091", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2507.13091", "abs": "https://arxiv.org/abs/2507.13091", "authors": ["Aur\u00e8le Barri\u00e8re", "Victor Deng", "Cl\u00e9ment Pit-Claudel"], "title": "Formal Verification for JavaScript Regular Expressions: a Proven Semantics and its Applications", "comment": "25 pages, 3 pages of references, 6 pages of appendix", "summary": "We present the first mechanized, succinct, practical, complete, and\nproven-faithful semantics for a modern regular expression language with\nbacktracking semantics. We ensure its faithfulness by proving it equivalent to\na preexisting line-by-line embedding of the official ECMAScript specification\nof JavaScript regular expressions. We demonstrate its practicality by\npresenting two real-world applications. First, a new notion of contextual\nequivalence for modern regular expressions, which we use to prove or disprove\nrewrites drawn from previous work. Second, the first formal proof of the PikeVM\nalgorithm used in many real-world engines. In contrast with the specification\nand other formalization work, our semantics captures not only the top-priority\nmatch, but a full backtracking tree recording all possible matches and their\nrespective priority. All our definitions and results have been mechanized in\nthe Rocq proof assistant.", "AI": {"tldr": "Mechanized, succinct, and practical semantics for modern regex with backtracking, proven faithful to ECMAScript, with real-world applications and mechanized proofs.", "motivation": "To provide a faithful and practical semantics for modern regex with backtracking, addressing gaps in existing formalizations.", "method": "Prove equivalence to ECMAScript's line-by-line embedding, apply to contextual equivalence and PikeVM algorithm, and mechanize in Rocq.", "result": "Faithful semantics capturing full backtracking tree, enabling proofs of regex rewrites and PikeVM correctness.", "conclusion": "Successful mechanization and practical applications demonstrate the semantics' utility and faithfulness."}}
{"id": "2507.12480", "categories": ["cs.SE", "cs.AI", "cs.ET"], "pdf": "https://arxiv.org/pdf/2507.12480", "abs": "https://arxiv.org/abs/2507.12480", "authors": ["Nazanin Siavash", "Armin Moin"], "title": "LLM-Powered Quantum Code Transpilation", "comment": "IEEE International Conference on Quantum Computing and Engineering\n  (QCE) 2025 - Extended Abstract", "summary": "There exist various Software Development Kits (SDKs) tailored to different\nquantum computing platforms. These are known as Quantum SDKs (QSDKs). Examples\ninclude but are not limited to Qiskit, Cirq, and PennyLane. However, this\ndiversity presents significant challenges for interoperability and\ncross-platform development of hybrid quantum-classical software systems.\nTraditional rule-based transpilers for translating code between QSDKs are\ntime-consuming to design and maintain, requiring deep expertise and rigid\nmappings in the source and destination code. In this study, we explore the use\nof Large Language Models (LLMs) as a flexible and automated solution.\nLeveraging their pretrained knowledge and contextual reasoning capabilities, we\nposition LLMs as programming language-agnostic transpilers capable of\nconverting quantum programs from one QSDK to another while preserving\nfunctional equivalence. Our approach eliminates the need for manually defined\ntransformation rules and offers a scalable solution to quantum software\nportability. This work represents a step toward enabling intelligent,\ngeneral-purpose transpilation in the quantum computing ecosystem.", "AI": {"tldr": "LLMs are proposed as a flexible, automated solution for translating quantum programs between QSDKs, eliminating manual rule-based transpilers.", "motivation": "Diverse QSDKs create interoperability challenges; traditional transpilers are rigid and labor-intensive.", "method": "Uses LLMs for language-agnostic transpilation of quantum programs, preserving functional equivalence.", "result": "LLMs enable scalable, automated quantum software portability without manual rules.", "conclusion": "LLMs offer a step toward intelligent, general-purpose transpilation in quantum computing."}}
{"id": "2507.13282", "categories": ["cs.LO"], "pdf": "https://arxiv.org/pdf/2507.13282", "abs": "https://arxiv.org/abs/2507.13282", "authors": ["Eugene Goldberg"], "title": "Solving SAT By Computing A Stable Set Of Points In Clusters", "comment": null, "summary": "Earlier we introduced the notion of a stable set of points (SSP). We proved\nthat a CNF formula is unsatisfiable iff there is a set of points (i.e. complete\nassignments) that is stable with respect to this formula. Experiments showed\nthat SSPs for CNF formulas of practical interest are very large. So computing\nan SSP for a CNF formula point by point is, in general, infeasible. In this\nreport, we show how an SSP can be computed in clusters, each cluster being a\nlarge set of points that are processed simultaneously. The appeal of computing\nSSPs is twofold. First, it allows one to better take into account formula\nstructure and hence, arguably, design more efficient SAT algorithms. Second,\nSAT solving by SSPs facilitates parallel computing.", "AI": {"tldr": "SSPs (stable sets of points) for CNF formulas are large, making point-by-point computation infeasible. This paper proposes computing SSPs in clusters for efficiency and parallelization.", "motivation": "SSPs are useful for determining CNF formula unsatisfiability, but their large size makes computation impractical. Clustering offers a scalable solution.", "method": "Proposes computing SSPs in clusters (large sets of points processed simultaneously) to leverage formula structure and enable parallel computing.", "result": "Enables more efficient SAT algorithms and facilitates parallel processing of SSPs.", "conclusion": "Clustering SSPs improves scalability and efficiency, benefiting SAT solving and parallel computing."}}
{"id": "2507.13290", "categories": ["cs.PL", "cs.AI"], "pdf": "https://arxiv.org/pdf/2507.13290", "abs": "https://arxiv.org/abs/2507.13290", "authors": ["Aaron Councilman", "David Fu", "Aryan Gupta", "Chengxiao Wang", "David Grove", "Yu-Xiong Wang", "Vikram Adve"], "title": "Towards Formal Verification of LLM-Generated Code from Natural Language Prompts", "comment": "31 pages, 9 figures", "summary": "In the past few years LLMs have emerged as a tool that can aid programmers by\ntaking natural language descriptions and generating code based on it. However,\nLLMs often generate incorrect code that users need to fix and the literature\nsuggests users often struggle to detect these errors. In this work we seek to\noffer formal guarantees of correctness to LLM generated code; such guarantees\ncould improve the experience of using AI Code Assistants and potentially enable\nnatural language programming for users with little or no programming knowledge.\nTo address this challenge we propose to incorporate a formal query language\nthat can represent a user's intent in a formally defined but natural\nlanguage-like manner that a user can confirm matches their intent. Then, using\nsuch a query we propose to verify LLM generated code to ensure it matches the\nuser's intent. We implement these ideas in our system, Astrogator, for the\nAnsible programming language which includes such a formal query language, a\ncalculus for representing the behavior of Ansible programs, and a symbolic\ninterpreter which is used for the verification. On a benchmark suite of 21\ncode-generation tasks, our verifier is able to verify correct code in 83% of\ncases and identify incorrect code in 92%.", "AI": {"tldr": "The paper proposes a method to provide formal correctness guarantees for LLM-generated code using a formal query language and verification system, achieving high accuracy in verification.", "motivation": "LLMs often generate incorrect code, and users struggle to detect errors, hindering the reliability of AI Code Assistants. Formal guarantees could enhance usability, especially for non-programmers.", "method": "Incorporates a formal query language to represent user intent and verifies LLM-generated code against it. Implemented in Astrogator for Ansible, using a calculus and symbolic interpreter.", "result": "On 21 tasks, the verifier confirmed correct code in 83% of cases and detected incorrect code in 92%.", "conclusion": "The approach improves reliability of AI-generated code, supporting natural language programming for non-experts."}}
{"id": "2507.12482", "categories": ["cs.SE", "cs.AI", "cs.CE", "cs.LG", "68N30, 68T05, 68T50", "D.2.5; D.2.7; F.3.2; I.2.6; I.2.7"], "pdf": "https://arxiv.org/pdf/2507.12482", "abs": "https://arxiv.org/abs/2507.12482", "authors": ["Ishraq Khan", "Assad Chowdary", "Sharoz Haseeb", "Urvish Patel"], "title": "Kodezi Chronos: A Debugging-First Language Model for Repository-Scale, Memory-Driven Code Understanding", "comment": "10 pages, 10 figures, 7 tables, IEEE Conference format, Q4 2025 model\n  release, Q1 2026 Kodezi OS deployment", "summary": "Large Language Models (LLMs) have advanced code generation and software\nautomation, but are fundamentally constrained by limited inference-time context\nand lack of explicit code structure reasoning. We introduce Kodezi Chronos, a\nnext-generation architecture for autonomous code understanding, debugging, and\nmaintenance, designed to operate across ultra-long contexts comprising entire\ncodebases, histories, and documentation, all without fixed window limits.\nKodezi Chronos leverages a multi-level embedding memory engine, combining\nvector and graph-based indexing with continuous code-aware retrieval. This\nenables efficient and accurate reasoning over millions of lines of code,\nsupporting repository-scale comprehension, multi-file refactoring, and\nreal-time self-healing actions. Our evaluation introduces a novel Multi Random\nRetrieval benchmark, specifically tailored to the software engineering domain.\nUnlike classical retrieval benchmarks, this method requires the model to\nresolve arbitrarily distant and obfuscated associations across code artifacts,\nsimulating realistic tasks such as variable tracing, dependency migration, and\nsemantic bug localization. Chronos outperforms prior LLMs and code models,\ndemonstrating a 23% improvement in real-world bug detection and reducing\ndebugging cycles by up to 40% compared to traditional sequence-based\napproaches. By natively interfacing with IDEs and CI/CD workflows, Chronos\nenables seamless, autonomous software maintenance, elevating code reliability\nand productivity while reducing manual effort. These results mark a critical\nadvance toward self-sustaining, continuously optimized software ecosystems.", "AI": {"tldr": "Kodezi Chronos enhances code generation and maintenance by overcoming LLM limitations with a multi-level embedding memory engine, improving bug detection by 23% and reducing debugging cycles by 40%.", "motivation": "LLMs are limited by context constraints and lack of code structure reasoning, hindering large-scale code understanding and maintenance.", "method": "Kodezi Chronos uses a multi-level embedding memory engine for efficient reasoning over entire codebases, supporting tasks like refactoring and bug detection.", "result": "Outperforms prior models with 23% better bug detection and 40% faster debugging, integrating seamlessly with IDEs and CI/CD workflows.", "conclusion": "Chronos advances autonomous software maintenance, improving reliability and productivity while reducing manual effort."}}
{"id": "2507.12483", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.12483", "abs": "https://arxiv.org/abs/2507.12483", "authors": ["Dong Wang", "Hanmo You", "Lingwei Zhu", "Kaiwei Lin", "Zheng Chen", "Chen Yang", "Junji Yu", "Zan Wang", "Junjie Chen"], "title": "A Survey of Reinforcement Learning for Software Engineering", "comment": null, "summary": "Reinforcement Learning (RL) has emerged as a powerful paradigm for sequential\ndecision-making and has attracted growing interest across various domains,\nparticularly following the advent of Deep Reinforcement Learning (DRL) in 2015.\nSimultaneously, the rapid advancement of Large Language Models (LLMs) has\nfurther fueled interest in integrating RL with LLMs to enable more adaptive and\nintelligent systems. In the field of software engineering (SE), the increasing\ncomplexity of systems and the rising demand for automation have motivated\nresearchers to apply RL to a broad range of tasks, from software design and\ndevelopment to quality assurance and maintenance. Despite growing research in\nRL-for-SE, there remains a lack of a comprehensive and systematic survey of\nthis evolving field. To address this gap, we reviewed 115 peer-reviewed studies\npublished across 22 premier SE venues since the introduction of DRL. We\nconducted a comprehensive analysis of publication trends, categorized SE topics\nand RL algorithms, and examined key factors such as dataset usage, model design\nand optimization, and evaluation practices. Furthermore, we identified open\nchallenges and proposed future research directions to guide and inspire ongoing\nwork in this evolving area. To summarize, this survey offers the first\nsystematic mapping of RL applications in software engineering, aiming to\nsupport both researchers and practitioners in navigating the current landscape\nand advancing the field. Our artifacts are publicly available:\nhttps://github.com/KaiWei-Lin-lanina/RL4SE.", "AI": {"tldr": "This survey systematically maps RL applications in SE, analyzing 115 studies to identify trends, challenges, and future directions.", "motivation": "The increasing complexity of SE tasks and demand for automation motivate integrating RL with SE, yet no comprehensive survey exists.", "method": "Reviewed 115 peer-reviewed studies from 22 SE venues, analyzing trends, algorithms, datasets, and evaluation practices.", "result": "Identified key RL applications in SE, categorized topics/algorithms, and highlighted open challenges.", "conclusion": "Provides the first systematic survey of RL-for-SE, offering guidance for researchers and practitioners to advance the field."}}
{"id": "2507.12558", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.12558", "abs": "https://arxiv.org/abs/2507.12558", "authors": ["Tien P. T. Le", "Anh M. T. Bui", "Huy N. D. Pham", "Alessio Bucaioni", "Phuong T. Nguyen"], "title": "When Retriever Meets Generator: A Joint Model for Code Comment Generation", "comment": "The paper has been peer-reviewed and accepted for publication in the\n  proceedings of the 19th ACM/IEEE International Symposium on Empirical\n  Software Engineering and Measurement (ESEM 2025)", "summary": "Automatically generating concise, informative comments for source code can\nlighten documentation effort and accelerate program comprehension.\nRetrieval-augmented approaches first fetch code snippets with existing comments\nand then synthesize a new comment, yet retrieval and generation are typically\noptimized in isolation, allowing irrelevant neighbors topropagate noise\ndownstream. To tackle the issue, we propose a novel approach named RAGSum with\nthe aim of both effectiveness and efficiency in recommendations. RAGSum is\nbuilt on top offuse retrieval and generation using a single CodeT5 backbone. We\nreport preliminary results on a unified retrieval-generation framework built on\nCodeT5. A contrastive pre-training phase shapes code embeddings for\nnearest-neighbor search; these weights then seed end-to-end training with a\ncomposite loss that (i) rewards accurate top-k retrieval; and (ii) minimizes\ncomment-generation error. More importantly, a lightweight self-refinement loop\nis deployed to polish the final output. We evaluated theframework on three\ncross-language benchmarks (Java, Python, C), and compared it with three\nwell-established baselines. The results show that our approach substantially\noutperforms thebaselines with respect to BLEU, METEOR, and ROUTE-L. These\nfindings indicate that tightly coupling retrieval and generationcan raise the\nceiling for comment automation and motivateforthcoming replications and\nqualitative developer studies.", "AI": {"tldr": "RAGSum, a novel approach combining retrieval and generation for code comments, outperforms baselines by tightly coupling these tasks.", "motivation": "To improve comment automation by addressing noise propagation in retrieval-augmented methods.", "method": "Uses CodeT5 backbone with contrastive pre-training, composite loss, and self-refinement.", "result": "Outperforms baselines on BLEU, METEOR, and ROUTE-L metrics across Java, Python, and C.", "conclusion": "Tight coupling of retrieval and generation enhances comment automation, warranting further study."}}
{"id": "2507.12561", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.12561", "abs": "https://arxiv.org/abs/2507.12561", "authors": ["Samal Nursapa", "Anastassiya Samuilova", "Alessio Bucaioni. Phuong T. Nguyen"], "title": "ROSE: Transformer-Based Refactoring Recommendation for Architectural Smells", "comment": "The paper has been peer-reviewed and accepted for publication in the\n  proceedings of the 19th ACM/IEEE International Symposium on Empirical\n  Software Engineering and Measurement (ESEM 2025)", "summary": "Architectural smells such as God Class, Cyclic Dependency, and Hub-like\nDependency degrade software quality and maintainability. Existing tools detect\nsuch smells but rarely suggest how to fix them. This paper explores the use of\npre-trained transformer models--CodeBERT and CodeT5--for recommending suitable\nrefactorings based on detected smells. We frame the task as a three-class\nclassification problem and fine-tune both models on over 2 million refactoring\ninstances mined from 11,149 open-source Java projects. CodeT5 achieves 96.9%\naccuracy and 95.2% F1, outperforming CodeBERT and traditional baselines. Our\nresults show that transformer-based models can effectively bridge the gap\nbetween smell detection and actionable repair, laying the foundation for future\nrefactoring recommendation systems. We release all code, models, and data under\nan open license to support reproducibility and further research.", "AI": {"tldr": "Transformer models (CodeBERT, CodeT5) are fine-tuned to recommend refactorings for architectural smells, with CodeT5 outperforming others at 96.9% accuracy.", "motivation": "Existing tools detect architectural smells but lack actionable fixes, prompting the use of AI for refactoring recommendations.", "method": "Fine-tuned CodeBERT and CodeT5 on 2M+ refactoring instances from 11,149 Java projects, framing it as a three-class classification task.", "result": "CodeT5 achieved 96.9% accuracy and 95.2% F1, surpassing CodeBERT and traditional methods.", "conclusion": "Transformer models effectively link smell detection to actionable fixes, paving the way for advanced refactoring recommendation systems."}}
{"id": "2507.12642", "categories": ["cs.SE", "cs.AI", "quant-ph"], "pdf": "https://arxiv.org/pdf/2507.12642", "abs": "https://arxiv.org/abs/2507.12642", "authors": ["Kiana Kheiri", "Aamna Aamir", "Andriy Miranskyy", "Chen Ding"], "title": "QSpark: Towards Reliable Qiskit Code Generation", "comment": null, "summary": "Quantum circuits must be error-resilient, yet LLMs like Granite-20B-Code and\nStarCoder often output flawed Qiskit code. We fine-tuned a 32 B model with two\nRL methods, Group Relative Policy Optimization (GRPO) and Odds-Ratio Preference\nOptimization (ORPO), using a richly annotated synthetic dataset. On the Qiskit\nHumanEval benchmark, ORPO reaches 56.29\\% Pass@1 ($\\approx+10$ pp over\nGranite-8B-QK) and GRPO hits 49\\%, both beating all general-purpose baselines;\non the original HumanEval they score 65.90\\% and 63.00\\%. GRPO excels on basic\ntasks (42/54), ORPO on intermediate ones (41/68), and neither solves the five\nadvanced tasks, highlighting clear gains yet room for progress in AI-assisted\nquantum programming.", "AI": {"tldr": "Fine-tuned 32B model with GRPO and ORPO outperforms baselines in Qiskit HumanEval, but struggles with advanced tasks.", "motivation": "Address error resilience in quantum circuits by improving AI-generated Qiskit code.", "method": "Fine-tuned 32B model using GRPO and ORPO on synthetic dataset.", "result": "ORPO: 56.29% Pass@1, GRPO: 49% on Qiskit HumanEval; both beat baselines.", "conclusion": "Clear progress in AI-assisted quantum programming, but advanced tasks remain unsolved."}}
{"id": "2507.12649", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.12649", "abs": "https://arxiv.org/abs/2507.12649", "authors": ["Christine van Stiphoudt", "Sergio Potenciano Menci", "Gilbert Fridgen"], "title": "A Three-Phase Evaluation Approach for new Information and Data Models in the Smart Grid Domain", "comment": null, "summary": "The ongoing digitalisation of the smart grid is resulting in an increase in\nautomated information exchanges across distributed energy systems. This process\nhas led to the development of new information and data models when the existing\nones fall short. To prevent potential disruptions caused by flaws in the newly\ndesigned information and data models, it is essential to evaluate them during\nthe design process before they are implemented in operation.\n  Currently, general explicit evaluation approaches outside the smart grid\ndomain stay at a high level without defining clear steps. Meanwhile, implicit\nevaluation approaches in the smart grid domain focus on testing systems that\nutilise information and data models already in use for functionality in terms\nof conformance and interoperability. Notably, no combination of explicit and\nimplicit evaluation approaches for newly designed information and data models\noffers a clearly defined set of steps during their design process in the smart\ngrid context.\n  Consequently, we design a three-phase evaluation approach using design\nscience research to address this gap. Our evaluation approach combines explicit\nand implicit evaluation methods and is applicable when developing new\ninformation and data models. We use the development of an information model and\ndata model focused on industrial flexibility descriptions to refine our\nevaluation approach. Additionally, we provide lessons learned from our\nexperience.", "AI": {"tldr": "The paper proposes a three-phase evaluation approach combining explicit and implicit methods to assess newly designed information and data models in smart grids, addressing gaps in current evaluation practices.", "motivation": "Existing evaluation approaches for smart grid information and data models are either too high-level (explicit) or limited to testing operational systems (implicit), lacking a combined method for design-phase evaluation.", "method": "A three-phase evaluation approach using design science research, combining explicit and implicit methods, is developed and refined through the creation of industrial flexibility description models.", "result": "The proposed approach successfully integrates explicit and implicit evaluation methods, providing a structured process for assessing new models during their design phase.", "conclusion": "The study fills a critical gap in smart grid model evaluation, offering practical insights and lessons learned for future implementations."}}
{"id": "2507.12653", "categories": ["cs.SE", "cs.CL", "H.4.m"], "pdf": "https://arxiv.org/pdf/2507.12653", "abs": "https://arxiv.org/abs/2507.12653", "authors": ["Jo\u00e3o Granja-Correia", "Remedios Hern\u00e1ndez-Linares", "Luca Ferranti", "Arm\u00e9nio Rego"], "title": "A Fuzzy Approach to Project Success: Measuring What Matters", "comment": "3 pages, 1 figure, presented at FUZZ-IEEE 2025", "summary": "This paper introduces a novel approach to project success evaluation by\nintegrating fuzzy logic into an existing construct. Traditional Likert-scale\nmeasures often overlook the context-dependent and multifaceted nature of\nproject success. The proposed hierarchical Type-1 Mamdani fuzzy system\nprioritizes sustained positive impact for end-users, reducing emphasis on\nsecondary outcomes like stakeholder satisfaction and internal project success.\nThis dynamic approach may provide a more accurate measure of project success\nand could be adaptable to complex evaluations. Future research will focus on\nempirical testing and broader applications of fuzzy logic in social science.", "AI": {"tldr": "A novel fuzzy logic approach enhances project success evaluation by prioritizing end-user impact over traditional Likert-scale measures.", "motivation": "Traditional methods overlook context-dependent and multifaceted aspects of project success.", "method": "Hierarchical Type-1 Mamdani fuzzy system prioritizes sustained positive impact for end-users.", "result": "More accurate project success measurement, adaptable to complex evaluations.", "conclusion": "Future research will test empirically and explore broader fuzzy logic applications in social science."}}
{"id": "2507.12665", "categories": ["cs.SE", "cs.AI", "cs.HC"], "pdf": "https://arxiv.org/pdf/2507.12665", "abs": "https://arxiv.org/abs/2507.12665", "authors": ["Salvador D. Escobedo"], "title": "Single Conversation Methodology: A Human-Centered Protocol for AI-Assisted Software Development", "comment": "Style reviewed by a LLM for improving clarity and English syntax", "summary": "We propose the Single Conversation Methodology (SCM), a novel and pragmatic\napproach to software development using large language models (LLMs). In\ncontrast to ad hoc interactions with generative AI, SCM emphasizes a structured\nand persistent development dialogue, where all stages of a project - from\nrequirements to architecture and implementation - unfold within a single,\nlong-context conversation. The methodology is grounded on principles of\ncognitive clarity, traceability, modularity, and documentation. We define its\nphases, best practices, and philosophical stance, while arguing that SCM offers\na necessary correction to the passive reliance on LLMs prevalent in current\npractices. We aim to reassert the active role of the developer as architect and\nsupervisor of the intelligent tool.", "AI": {"tldr": "SCM is a structured methodology for software development using LLMs, emphasizing persistent dialogue and developer control.", "motivation": "Addresses the ad hoc use of LLMs by promoting structured, traceable development.", "method": "Uses a single, long-context conversation for all project stages, grounded in clarity and modularity.", "result": "Proposes a corrective to passive LLM reliance, reasserting developer agency.", "conclusion": "SCM offers a pragmatic, developer-centric approach to leveraging LLMs in software development."}}
{"id": "2507.13035", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.13035", "abs": "https://arxiv.org/abs/2507.13035", "authors": ["Keila Lucas", "Rohit Gheyi", "M\u00e1rcio Ribeiro", "Fabio Palomba", "Luana Martins", "Elvys Soares"], "title": "Investigating the Performance of Small Language Models in Detecting Test Smells in Manual Test Cases", "comment": "7 pages, Accepted at Insightful Ideas and Emerging Results (IIER)\n  Track of the Brazilian Symposium on Software Engineering (SBES 2025)", "summary": "Manual testing, in which testers follow natural language instructions to\nvalidate system behavior, remains crucial for uncovering issues not easily\ncaptured by automation. However, these test cases often suffer from test\nsmells, quality issues such as ambiguity, redundancy, or missing checks that\nreduce test reliability and maintainability. While detection tools exist, they\ntypically require manual rule definition and lack scalability. This study\ninvestigates the potential of Small Language Models (SLMs) for automatically\ndetecting test smells. We evaluate Gemma3, Llama3.2, and Phi-4 on 143\nreal-world Ubuntu test cases, covering seven types of test smells. Phi-4\nachieved the best results, reaching a pass@2 of 97% in detecting sentences with\ntest smells, while Gemma3 and Llama3.2 reached approximately 91%. Beyond\ndetection, SLMs autonomously explained issues and suggested improvements, even\nwithout explicit prompt instructions. They enabled low-cost, concept-driven\nidentification of diverse test smells without relying on extensive rule\ndefinitions or syntactic analysis. These findings highlight the potential of\nSLMs as efficient tools that preserve data privacy and can improve test quality\nin real-world scenarios.", "AI": {"tldr": "SLMs like Phi-4, Gemma3, and Llama3.2 effectively detect test smells in manual testing, with Phi-4 achieving 97% accuracy, outperforming others. They also autonomously explain issues and suggest improvements.", "motivation": "Manual testing suffers from test smells (ambiguity, redundancy, etc.), reducing reliability. Existing tools lack scalability and require manual rules.", "method": "Evaluated SLMs (Gemma3, Llama3.2, Phi-4) on 143 Ubuntu test cases for seven test smell types.", "result": "Phi-4 achieved 97% pass@2 accuracy, outperforming Gemma3 (91%) and Llama3.2 (91%). SLMs also autonomously explained and suggested fixes.", "conclusion": "SLMs offer scalable, low-cost test smell detection without extensive rules, improving test quality while preserving privacy."}}
{"id": "2507.13081", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.13081", "abs": "https://arxiv.org/abs/2507.13081", "authors": ["Dongming Jin", "Weisong Sun", "Jiangping Huang", "Peng Liang", "Jifeng Xuan", "Yang Liu", "Zhi Jin"], "title": "iReDev: A Knowledge-Driven Multi-Agent Framework for Intelligent Requirements Development", "comment": "22pages, 4 figures", "summary": "Requirements development is a critical phase as it is responsible for\nproviding a clear understanding of what stakeholders need. It involves\ncollaboration among stakeholders to extract explicit requirements and address\npotential conflicts, which is time-consuming and labor-intensive. Recently,\nmulti-agent systems for software development have attracted much attention.\nHowever, existing research provides limited support for requirements\ndevelopment and overlooks the injection of human knowledge into agents and the\nhuman-agent collaboration. % To address these issues, this paper proposes a\nknowledge-driven multi-agent framework for intelligent requirement development,\nnamed iReDev. iReDev features: iReDev consists of six knowledge-driven agents\nto support the entire requirements development. They collaboratively perform\nvarious tasks to produce a software requirements specification. iReDev focuses\non integrating human knowledge for agents, enabling them to simulate real-world\nstakeholders. iReDev uses an event-driven communication mechanism based on an\nartifact pool. Agents continuously monitor the pool and autonomously trigger\nthe next action based on its changes, enabling iReDev to handle new\nrequirements quickly. iReDev introduces a human-in-the-loop mechanism to\nsupport human-agent collaboration, ensuring that the generated artifacts align\nwith the expectations of stakeholders. We evaluated the generated artifacts and\nresults show that iReDev outperforms existing baselines in multiple aspects. We\nfurther envision three key directions and hope this work can facilitate the\ndevelopment of intelligent requirements development.", "AI": {"tldr": "iReDev is a knowledge-driven multi-agent framework for intelligent requirements development, integrating human knowledge and enabling human-agent collaboration to outperform existing baselines.", "motivation": "Existing multi-agent systems lack support for requirements development and human-agent collaboration, prompting the need for iReDev.", "method": "iReDev uses six knowledge-driven agents, an event-driven communication mechanism, and a human-in-the-loop approach to collaboratively develop software requirements.", "result": "iReDev outperforms existing baselines in generating software requirements specifications.", "conclusion": "iReDev advances intelligent requirements development and suggests future directions for further research."}}
{"id": "2507.13095", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.13095", "abs": "https://arxiv.org/abs/2507.13095", "authors": ["Dongming Jin", "Zhi Jin", "Linyu Li", "Xiaohong Chen"], "title": "A Conceptual Framework for Requirements Engineering of Pretrained-Model-Enabled Systems", "comment": "5pages, 1 figure", "summary": "Recent advances in large pretrained models have led to their widespread\nintegration as core components in modern software systems. The trend is\nexpected to continue in the foreseeable future. Unlike traditional software\nsystems governed by deterministic logic, systems powered by pretrained models\nexhibit distinctive and emergent characteristics, such as ambiguous capability\nboundaries, context-dependent behavior, and continuous evolution. These\nproperties fundamentally challenge long-standing assumptions in requirements\nengineering, including functional decomposability and behavioral\npredictability. This paper investigates this problem and advocates for a\nrethinking of existing requirements engineering methodologies. We propose a\nconceptual framework tailored to requirements engineering of\npretrained-model-enabled software systems and outline several promising\nresearch directions within this framework. This vision helps provide a guide\nfor researchers and practitioners to tackle the emerging challenges in\nrequirements engineering of pretrained-model-enabled systems.", "AI": {"tldr": "The paper discusses the challenges of integrating large pretrained models into software systems and proposes a new framework for requirements engineering to address these issues.", "motivation": "The integration of pretrained models into software systems challenges traditional requirements engineering assumptions due to their emergent, context-dependent, and evolving nature.", "method": "The paper proposes a conceptual framework tailored for requirements engineering of pretrained-model-enabled systems and outlines research directions.", "result": "The framework aims to guide researchers and practitioners in addressing the unique challenges posed by pretrained models in software systems.", "conclusion": "The paper advocates for rethinking requirements engineering methodologies to better accommodate the distinctive properties of pretrained-model-enabled systems."}}
{"id": "2507.13117", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.13117", "abs": "https://arxiv.org/abs/2507.13117", "authors": ["Andreas Pointner", "Josef Pichler", "Herbert Pr\u00e4hofer"], "title": "Inferring Attributed Grammars from Parser Implementations", "comment": "Accepted to ICSME 2025", "summary": "Software systems that process structured inputs often lack complete and\nup-to-date specifications, which specify the input syntax and the semantics of\ninput processing. While grammar mining techniques have focused on recovering\nsyntactic structures, the semantics of input processing remains largely\nunexplored. In this work, we introduce a novel approach for inferring\nattributed grammars from parser implementations. Given an input grammar, our\ntechnique dynamically analyzes the implementation of recursive descent parsers\nto reconstruct the semantic aspects of input handling, resulting in\nspecifications in the form of attributed grammars. By observing program\nexecutions and mapping the program's runtime behavior to the grammar, we\nsystematically extract and embed semantic actions into the grammar rules. This\nenables comprehensive specification recovery. We demonstrate the feasibility of\nour approach using an initial set of programs, showing that it can accurately\nreproduce program behavior through the generated attributed grammars.", "AI": {"tldr": "A novel approach infers attributed grammars from parser implementations to recover semantic aspects of input handling, enabling comprehensive specification recovery.", "motivation": "Software systems often lack complete specifications for structured input processing, especially regarding semantics.", "method": "Dynamic analysis of recursive descent parsers, mapping runtime behavior to grammar rules to embed semantic actions.", "result": "Accurate reproduction of program behavior through generated attributed grammars.", "conclusion": "The approach is feasible and effective for recovering input processing specifications."}}
{"id": "2507.13123", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.13123", "abs": "https://arxiv.org/abs/2507.13123", "authors": ["Xin Yin", "Xinrui Li", "Chao Ni", "Xiaodan Xu", "Xiaohu Yang"], "title": "Detecting LLM-generated Code with Subtle Modification by Adversarial Training", "comment": null, "summary": "With the rapid development of Large Language Models (LLMs), their powerful\ncode-generation capabilities have been widely applied in tasks like code\ncompletion and automated development, demonstrating the value of improving\ncoding efficiency. However, the extensive use of LLM-generated code also raises\nseveral new challenges. On the one hand, issues such as the regulation of code\nprovenance, copyright disputes, and code quality have become increasingly\nconcerning. How to effectively detect LLM-generated code and ensure its\ncompliant and responsible use has become a critical and urgent issue. On the\nother hand, in practical applications, LLM-generated code is often subject to\nmanual modifications, such as variable renaming or structural adjustments.\nAlthough some recent studies have proposed training-based and zero-shot methods\nfor detecting LLM-generated code, these approaches show insufficient robustness\nwhen facing modified LLM-generated code, and there is a lack of an effective\nsolution. To address the real-world scenario where LLM-generated code may\nundergo minor modifications, we propose CodeGPTSensor+, an enhanced version of\nCodeGPTSensor, which employs adversarial training to improve robustness against\ninput perturbations. CodeGPTSensor+ integrates an adversarial sample generation\nmodule, Multi-objective Identifier and Structure Transformation (MIST), which\nsystematically generates both high-quality and representative adversarial\nsamples. This module effectively enhances the model's resistance against\ndiverse adversarial attacks. Experimental results on the HMCorp dataset\ndemonstrate that CodeGPTSensor+ significantly improves detection accuracy on\nthe adversarial test set while maintaining high accuracy on the original test\nset, showcasing superior robustness compared to CodeGPTSensor.", "AI": {"tldr": "CodeGPTSensor+ is an enhanced tool for detecting LLM-generated code, even after modifications, using adversarial training and MIST for robustness.", "motivation": "Address challenges like code provenance, copyright, and quality in LLM-generated code, especially after manual modifications.", "method": "Proposes CodeGPTSensor+ with adversarial training and MIST module for generating adversarial samples to improve robustness.", "result": "Shows higher detection accuracy on adversarial and original test sets compared to CodeGPTSensor.", "conclusion": "CodeGPTSensor+ effectively detects modified LLM-generated code, offering a robust solution for real-world applications."}}

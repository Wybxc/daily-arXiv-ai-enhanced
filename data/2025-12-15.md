<div id=toc></div>

# Table of Contents

- [cs.LO](#cs.LO) [Total: 3]
- [cs.PL](#cs.PL) [Total: 1]
- [cs.SE](#cs.SE) [Total: 6]
- [cs.FL](#cs.FL) [Total: 1]


<div id='cs.LO'></div>

# cs.LO [[Back]](#toc)

### [1] [Context-Dependent Effects and Concurrency in Guarded Interaction Trees](https://arxiv.org/abs/2512.11577)
*Sergei Stepanenko,Emma Nardino,Virgil Marionneau,Dan Frumin,Amin Timany,Lars Birkedal*

Main category: cs.LO

TL;DR: 扩展Guarded Interaction Trees以支持上下文依赖效应（如call/cc、shift/reset）和抢占式并发，保持对上下文无关效应的推理原则不变，并提供程序逻辑和语义验证。


<details>
  <summary>Details</summary>
Motivation: 上下文依赖效应（如call/cc、shift/reset）在现代程序逻辑中破坏了组合性原则（如"bind规则"），使得表示和推理变得困难。需要一种能支持这类效应同时保持现有推理原则的方法。

Method: 扩展Guarded Interaction Trees框架，保守地添加对上下文依赖效应的支持。使用扩展框架为带call/cc和限定延续的高阶编程语言提供直接式指称语义，并扩展程序逻辑以处理上下文依赖效应。同时添加抢占式并发支持，包括原子状态修改操作。

Result: 成功扩展了Guarded Interaction Trees，支持上下文依赖效应和抢占式并发。证明了指称语义相对于操作语义的充分性，展示了带限定延续的编程语言与高阶存储编程语言的安全互操作性类型可靠性。

Conclusion: 该扩展提供了一种保守且模块化的方法来处理上下文依赖效应，保持了现有推理原则，支持多种效应组合，并为并发数据结构和算法实现提供了基础。

Abstract: Guarded Interaction Trees are a structure and a fully formalized framework for representing higher-order computations with higher-order effects in Rocq. We present an extension of Guarded Interaction Trees to support formal reasoning about context-dependent effects. That is, effects whose behaviors depend on the evaluation context, e.g., call/cc, shift and reset. Using and reasoning about such effects is challenging since certain compositionality principles no longer hold in the presence of such effects. For example, the so-called ``bind rule'' in modern program logics is no longer valid. The goal of our extension is to support representation and reasoning about context-dependent effects in the most painless way possible. To that end, our extension is conservative: the reasoning principles for context-independent effects remain the same. We use it to give direct-style denotational semantics for higher-order programming languages with call/cc and with delimited continuations. We extend the program logic for Guarded Interaction Trees to account for context-dependent effects, and we use the program logic to prove that the denotational semantics is adequate with respect to the operational semantics. Additionally, we retain the ability to combine multiple effects in a modular way, which we demonstrate by showing type soundness for safe interoperability of a programming language with delimited continuations and a programming language with higher-order store. Furthermore, as another contribution, in addition to context-dependent effects, we show how to extend Guarded Interaction Trees with preemptive concurrency. To support implementation and verification of concurrent data structures and algorithms in the presence of preemptive concurrency one requires atomic state modification operations, e.g., compare-and-exchange.

</details>


### [2] [Multi-clocked Guarded Recursion Beyond ω](https://arxiv.org/abs/2512.11361)
*Rasmus Ejlers Møgelberg*

Main category: cs.LO

TL;DR: 本文扩展了多时钟守卫递归的扩展预层模型到高阶序数，使得共归纳类型的编码正确性可以从W-类型扩展到涉及有限幂集和有限分布的类型，以及涉及存在量词的共归纳谓词。


<details>
  <summary>Details</summary>
Motivation: 现有的多时钟守卫递归模型在扩展类型理论中通过预层模型验证了W-类型的编码正确性，但需要扩展到更复杂的共归纳类型（如涉及有限幂集、有限分布的类型）和共归纳谓词（涉及存在量词）。同时，需要将时钟立方类型理论中的结果解释到基于集合论的模型中。

Method: 将扩展预层模型扩展到高阶序数，构建基于集合论的模型，使得时钟立方类型理论中的结果能够在该模型中解释，从而验证涉及有限幂集、有限分布和存在量词的共归纳类型/谓词的编码正确性。

Result: 成功扩展了多时钟守卫递归的扩展预层模型到高阶序数，使得编码正确性从W-类型扩展到更复杂的共归纳类型（有限幂集、有限分布）和共归纳谓词（存在量词），并将时钟立方类型理论的结果解释到集合论模型中。

Conclusion: 通过将扩展预层模型扩展到高阶序数，本文实现了对更复杂共归纳类型和谓词的编码正确性验证，并将时钟立方类型理论的结果与集合论解释联系起来，为高级编程语言特性提供了更完整的理论基础。

Abstract: Type theories with multi-clocked guarded recursion provide a flexible framework for programming with coinductive types encoding productivity in types. Combining this with solutions to general guarded domain equations one can also construct relatively simple denotational models of programming languages with advanced features. These constructions have previously been explored in the setting of extensional type theory through a presheaf model, which proves correctness of encodings of W-types. That model has been adapted to presheaves of cubical sets (functors into the category of cubical sets), where the model verifies correctness of encodings also of coinductive types whose definitions involve quotient inductive types such as finite powersets or finite distributions. Likewise the cubical model also verifies correctness of coinductive predicates defined using existential quantification and allows the results to be related to the global world of cubical sets.
  This paper looks at how to extend the extensional presheaf model of multi-clocked guarded recursion to higher ordinals, so that correctness of encodings of coinductive types can be extended from W-types to those involving finite powersets and finite distributions, as well as coinductive predicates involving existential quantification. This extension will allow results previously proved in Clocked Cubical Type Theory to be interpreted in a model based on set-theory, proving the correctness of these results as understood in their usual set theoretic interpretation.

</details>


### [3] [Compact SAT Encoding for Power Peak Minimization](https://arxiv.org/abs/2512.11435)
*Tuyen Van Kieu,Phong Chi Nguyen,Bao Gia Hoang,Khanh Van To*

Main category: cs.LO

TL;DR: 提出紧凑SAT编码(CSE)解决带功率峰值最小化的装配线平衡问题，将每个传递优先边的子句复杂度从O(m²)降至O(m)，在工业规模实例上实现精确优化。


<details>
  <summary>Details</summary>
Motivation: SALBP-3PM问题结合工作站分配、时序调度和功率聚合，是NP难问题。现有SAT/MaxSAT方法存在编码效率低的问题，每个优先边产生O(m²)子句，限制了求解规模。

Method: 提出紧凑SAT编码(CSE)，利用顺序计数器技术将每个传递优先边的子句复杂度降至O(m)。实现了四种优化变体：基于子句的迭代SAT、伪布尔约束迭代SAT、MaxSAT和增量SAT。

Result: 在基准实例上的实验评估显示，相比现有方法有持续的性能提升，能够在之前难以处理的工业规模实例上实现精确优化。

Conclusion: 紧凑编码原则可推广到其他装配线平衡变体和更广泛的带优先约束的调度问题，为解决复杂工业优化问题提供了有效方法。

Abstract: The Simple Assembly Line Balancing Problem with Power Peak Minimization (SALBP-3PM) minimizes maximum instantaneous power usage while assigning $n$ tasks to $m$ workstations and determining execution schedules within given cycle time constraints. This NP-hard problem couples workstation assignment, temporal sequencing, and power aggregation, presenting significant computational challenges for exact optimization methods. Existing Boolean Satisfiability (SAT) and Maximum Satisfiability (MaxSAT) approaches suffer from baseline encodings generating $O(m^2)$ clauses per precedence edge. We introduce a Compact SAT Encoding (CSE) achieving $O(m)$ clauses per transitive precedence edge using sequential counter techniques. We instantiate four optimization variants: Clause-Based iterative SAT, Pseudo-Boolean (PB) Constraint iterative SAT, MaxSAT, and Incremental SAT. Comprehensive experimental evaluation on benchmark instances demonstrates consistent performance improvements over state-of-the-art approaches, enabling exact optimization on previously intractable industrial-scale instances. The encoding principles generalize to other assembly line balancing variants and broader scheduling problems with precedence constraints.

</details>


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [4] [The Relative Monadic Metalanguage](https://arxiv.org/abs/2512.11762)
*Jack Liell-Cock,Zev Shirazi,Sam Staton*

Main category: cs.PL

TL;DR: 本文扩展了相对单子理论，提出了相对单子元语言，并应用于分级单子和箭头计算，开发了新的程序演算系统。


<details>
  <summary>Details</summary>
Motivation: 相对单子提供了计算的可控视图，但需要将其扩展到更一般的程序计算框架中。本文旨在将单子元语言推广到相对设置，为分级单子和箭头计算提供统一的语义基础。

Method: 1. 将单子元语言推广到相对设置，给出强相对单子的完整语义
2. 为分级单子开发线性-非线性语言LNL-RMM，并证明其是分级单子元语言的保守扩展
3. 为箭头计算提供完整语义，展示其是受限相对单子元语言
4. 引入ARMM，一种箭头计算风格的λ演算语言，保守扩展箭头计算

Result: 1. 成功建立了相对单子元语言的完整语义框架
2. 开发了LNL-RMM语言，并证明了其保守扩展性质
3. 为箭头计算提供了完整的语义解释，建立了与相对单子的联系
4. 提出了ARMM语言，扩展了箭头计算的能力

Conclusion: 相对单子为程序计算提供了统一的语义框架，能够优雅地处理分级单子和箭头计算。本文的工作扩展了相对单子理论的应用范围，为程序语言设计提供了新的理论基础。

Abstract: Relative monads provide a controlled view of computation. We generalise the monadic metalanguage to a relative setting and give a complete semantics with strong relative monads. Adopting this perspective, we generalise two existing program calculi from the literature. We provide a linear-non-linear language for graded monads, LNL-RMM, along with a semantic proof that it is a conservative extension of the graded monadic metalanguage. Additionally, we provide a complete semantics for the arrow calculus, showing it is a restricted relative monadic metalanguage. This motivates the introduction of ARMM, a computational lambda calculus-style language for arrows that conservatively extends the arrow calculus.

</details>


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [5] [Coverage Isn't Enough: SBFL-Driven Insights into Manually Created vs. Automatically Generated Tests](https://arxiv.org/abs/2512.11223)
*Sasara Shimizu,Yoshiki Higo*

Main category: cs.SE

TL;DR: 自动生成的测试比人工测试有更高的分支覆盖率，但在基于频谱的故障定位(SBFL)方面表现较差，特别是在深度嵌套代码结构中


<details>
  <summary>Details</summary>
Motivation: 当前测试生成研究主要关注覆盖率指标，很少评估测试对故障定位的支持效果。本研究旨在通过SBFL分数这一新指标，比较自动生成测试和人工创建测试的优劣

Method: 使用SBFL分数和代码覆盖率作为评估指标，比较自动生成测试和人工创建测试。特别关注SBFL技术在故障定位中的准确性，并分析代码结构（如深度嵌套）对结果的影响

Result: 自动生成测试的分支覆盖率高于人工测试，但SBFL分数较低，特别是在深度嵌套结构的代码中。这表明自动生成测试在覆盖代码方面更有效，但在帮助定位故障方面不如人工测试

Conclusion: 研究结果为有效结合自动生成测试和人工创建测试提供了指导。自动测试适合提高覆盖率，而人工测试在故障定位方面更有优势，特别是在复杂代码结构中

Abstract: The testing phase is an essential part of software development, but manually creating test cases can be time-consuming. Consequently, there is a growing need for more efficient testing methods. To reduce the burden on developers, various automated test generation tools have been developed, and several studies have been conducted to evaluate the effectiveness of the tests they produce. However, most of these studies focus primarily on coverage metrics, and only a few examine how well the tests support fault localization-particularly using artificial faults introduced through mutation testing. In this study, we compare the SBFL (Spectrum-Based Fault Localization) score and code coverage of automatically generated tests with those of manually created tests. The SBFL score indicates how accurately faults can be localized using SBFL techniques. By employing SBFL score as an evaluation metric-an approach rarely used in prior studies on test generation-we aim to provide new insights into the respective strengths and weaknesses of manually created and automatically generated tests. Our experimental results show that automatically generated tests achieve higher branch coverage than manually created tests, but their SBFL score is lower, especially for code with deeply nested structures. These findings offer guidance on how to effectively combine automatically generated and manually created testing approaches.

</details>


### [6] [AutoFSM: A Multi-agent Framework for FSM Code Generation with IR and SystemC-Based Testing](https://arxiv.org/abs/2512.11398)
*Qiuming Luo,Yanming Lei,Kunzhong Wu,Yixuan Cao,Chengjian Liu*

Main category: cs.SE

TL;DR: AutoFSM是一个多智能体协作框架，通过结构化中间表示和SystemC建模结合自动测试平台生成，显著提高FSM Verilog代码生成的准确性和调试效率。


<details>
  <summary>Details</summary>
Motivation: 现有大语言模型在生成有限状态机Verilog代码时面临语法错误频繁、调试效率低、过度依赖测试基准等问题，需要更可靠的硬件设计代码生成方案。

Method: 提出AutoFSM多智能体协作框架，采用结构化中间表示降低语法错误率，集成SystemC建模与自动测试平台生成，并构建分层FSM基准SKT-FSM进行评估。

Result: 在相同基础LLM下，AutoFSM在SKT-FSM基准上优于开源框架MAGE，通过率提升最高达11.94%，语法错误率降低最高达17.62%。

Conclusion: 结合LLM与结构化中间表示及自动化测试，能够显著提高RTL代码生成的可靠性和可扩展性，为硬件设计自动化提供有效解决方案。

Abstract: With the rapid advancement of large language models (LLMs) in code generation, their applications in hardware design are receiving growing attention. However, existing LLMs face several challenges when generating Verilog code for finite state machine (FSM) control logic, including frequent syntax errors, low debugging efficiency, and heavy reliance on test benchmarks. To address these challenges, this paper proposes AutoFSM, a multi-agent collaborative framework designed for FSM code generation tasks. AutoFSM introduces a structurally clear intermediate representation (IR) to reduce syntax error rate during code generation and provides a supporting toolchain to enable automatic translation from IR to Verilog. Furthermore, AutoFSM is the first to integrate SystemC-based modeling with automatic testbench generation, thereby improving debugging efficiency and feedback quality. To systematically evaluate the framework's performance, we construct SKT-FSM, the first hierarchical FSM benchmark in the field, comprising 67 FSM samples across different complexity levels. Experimental results show that, under the same base LLM, AutoFSM consistently outperforms the open-source framework MAGE on the SKT-FSM benchmark, achieving up to an 11.94% improvement in pass rate and up to a 17.62% reduction in syntax error rate. These results demonstrate the potential of combining LLMs with structured IR and automated testing to improve the reliability and scalability of register-transfer level (RTL) code generation.

</details>


### [7] [REMODEL-LLM: Transforming C code to Java using LLMs](https://arxiv.org/abs/2512.11402)
*Aryan Gupta,Y. Raghu Reddy*

Main category: cs.SE

TL;DR: 小型量化LLM在C到Java代码翻译任务中表现分层明显，仅少数模型能生成可运行代码，但复杂C概念仍是硬天花板。


<details>
  <summary>Details</summary>
Motivation: C到Java的自动翻译面临范式转换、内存模型和数据类型不兼容等根本性挑战，研究旨在评估小型量化LLM在此任务上的实际效能。

Method: 采用混合管道方法：利用抽象语法树进行语义分解，结合高度约束的基于规则的提示策略，测试19个参数少于200亿的小型量化LLM。

Result: 性能呈现三级分化：大多数模型完全失败；中间层能生成可运行代码但存在危险语义错误；仅三个模型通过超过50%测试，但仍无法处理函数指针、sizeof和枚举逻辑等复杂概念。

Conclusion: 当前量化模型在C到Java翻译任务中的推理能力存在硬性上限，复杂C概念仍是主要瓶颈，仅少数模型具备基本翻译能力。

Abstract: The automated translation of C code to Java code is a notoriously difficult task, fraught with challenges stemming from fundamental paradigm shifts (procedural vs. Object Oriented), memory models (manual pointers vs. Garbage Collection), and incompatible data types. This paper investigates the efficacy of 19 small, quantized LLMs (under 20 billion parameters) for the C to Java translation task. We use a novel, hybrid pipeline that leverages Abstract Syntax Trees (ASTs) for semantic decomposition and employs a highly constrained, rule based prompting strategy. The results are stark: a clear multi tiered performance divide emerged. The vast majority of models (Tier 3, e.g., llama3.1, gemma3, starcoder2) failed 100\% of the tests, proving incapable of generating even basic, runnable Java boilerplate. A small middle tier (Tier 2, e.g., mistral-nemo and mistral) produced runnable code but was plagued by dangerous semantic failures and wrong translations. Only three models (Tier 1: phi4, deepseek-coder-v2, codeqwen) proved viable, passing over 50\% of the test suite. Even these top models failed on the most complex C concepts, such as function pointers, sizeof, and enum logic, revealing a hard ceiling for the reasoning capabilities of current quantized models.

</details>


### [8] [Towards Privacy-Preserving Code Generation: Differentially Private Code Language Models](https://arxiv.org/abs/2512.11482)
*Melih Catal,Pooja Rani,Harald C. Gall*

Main category: cs.SE

TL;DR: 首次系统评估差分隐私在代码大语言模型中的应用，发现DP能显著减少记忆化风险，同时保持代码生成能力，且不影响训练效率


<details>
  <summary>Details</summary>
Motivation: 代码大语言模型在生成代码时可能无意中记忆并复现训练数据片段，这带来了隐私泄露和知识产权侵权的风险，限制了在敏感领域的部署。需要在不损害任务性能的前提下缓解记忆化风险。

Method: 应用差分隐私技术，首先识别和理解代码大语言模型在微调过程中的记忆化行为驱动原因，然后实证评估DP在缓解记忆化同时保持代码生成能力的效果。

Result: DP显著减少了代码大语言模型在所有测试片段类型中的记忆化，最易记忆化的片段类型也是DP最有效缓解的类型。DP略微增加了困惑度，但保持甚至增强了代码生成能力。DP对训练时间和能耗没有显著影响。

Conclusion: 差分隐私是保护代码大语言模型隐私的实用选择，能有效缓解记忆化风险而不显著损害模型效用，为在敏感领域部署代码大语言模型提供了可行方案。

Abstract: Large language models specialized for code (CodeLLMs) have demonstrated remarkable capabilities in generating code snippets, documentation, and test cases. However, despite their promising capabilities, CodeLLMs can inadvertently memorize and reproduce snippets from their training data, which poses risks of privacy breaches and intellectual property violations. These risks restrict the deployment of CodeLLMs in sensitive domains and limit their training datasets to publicly available sources. To mitigate the memorization risk without compromising their task performance, we apply Differential Privacy (DP) to CodeLLMs. To the best of our knowledge, this is the first comprehensive study that systematically evaluates the effectiveness of DP in CodeLLMs. DP adds calibrated noise to the training process to protect individual data points while still allowing the model to learn useful patterns. To this end, we first identify and understand the driving reasons of the memorization behaviour of the CodeLLMs during their fine-tuning. Then, to address this issue, we empirically evaluate the effect of DP on mitigating memorization while preserving code generation capabilities. Our findings show that DP substantially reduces memorization in CodeLLMs across all the tested snippet types. The snippet types most prone to memorization are also the most effectively mitigated by DP. Furthermore, we observe that DP slightly increases perplexity but preserves, and can even enhance, the code generation capabilities of CodeLLMs, which makes it feasible to apply DP in practice without significantly compromising model utility. Finally, we analyze the impact of DP on training efficiency and energy consumption, finding that DP does not significantly affect training time or energy usage, making it a practical choice for privacy-preserving CodeLLMs training.

</details>


### [9] [Mini-SFC: A Comprehensive Simulation Framework for Orchestration and Management of Service Function Chains](https://arxiv.org/abs/2512.11527)
*Xi Wang,Shuo Shi,Chenyu Wu*

Main category: cs.SE

TL;DR: 提出Mini-SFC模拟框架，支持数值和容器虚拟仿真，支持动态拓扑调整，用于SFC算法验证和服务部署验证


<details>
  <summary>Details</summary>
Motivation: 现有SFC模拟工具存在局限性，需要更灵活、用户友好的仿真框架来支持复杂网络服务的研究和验证

Method: 设计模块化仿真框架Mini-SFC，支持数值仿真和基于容器的虚拟仿真，提供标准化求解器接口，支持在线动态拓扑调整

Result: 开发了开源平台，简化模块设计，显著缩短研究人员学习曲线，增强SFC管理和优化的灵活性和可扩展性

Conclusion: Mini-SFC为SFC研究提供了有效的仿真工具，支持快速算法验证和实际服务部署验证，促进SFC管理和优化研究

Abstract: In the continuously evolving cloud computing and network environment, service function chain (SFC) plays a crucial role in implementing complex services in the network with its flexible deployment capabilities. To address the limitations of existing SFC simulation tools, this paper introduces Mini-SFC, a modular simulation framework that supports both numerical and container-based virtual simulations, while also supporting online dynamic topology adjustments. As an open-source platform emphasizing user-friendliness, Mini-SFC facilitates rapid algorithm verification and realistic service deployment validation. By simplifying module design and providing standardized solver interfaces, Mini-SFC significantly shortens the learning curve for researchers and enhances the flexibility and scalability required for advanced SFC management and optimization. For readers interested in exploring or utilizing Mini-SFC, more information is available on the official project page.

</details>


### [10] [A Study of Library Usage in Agent-Authored Pull Requests](https://arxiv.org/abs/2512.11589)
*Lukas Twist*

Main category: cs.SE

TL;DR: AI编码代理在29.5%的PR中导入库，但仅1.3%添加新依赖；添加时75%会指定版本，比直接使用LLM有明显改进；代理使用的库集合比非代理LLM研究中的"库偏好"更加多样化。


<details>
  <summary>Details</summary>
Motivation: 尽管AI编码代理能够完成端到端的软件工程工作流，包括提交PR，但我们对其如何使用库（软件开发的核心部分）了解甚少。本研究旨在填补这一空白，探究代理在实际开发中与库生态系统的交互方式。

Method: 基于AIDev数据集的26,760个代理撰写的PR进行分析，研究三个问题：代理导入库的频率、引入新依赖的频率及版本控制实践、以及具体选择的库类型。

Result: 1) 代理经常导入库（29.5%的PR）；2) 很少添加新依赖（1.3%的PR）；3) 添加依赖时遵循良好的版本控制实践（75.0%指定版本），优于直接使用LLM；4) 代理使用的外部库集合非常多样化，不同于先前非代理LLM研究中观察到的有限"库偏好"。

Conclusion: AI编码代理在库使用方面表现出谨慎和规范的特点：虽然经常导入库，但很少添加新依赖；添加时能良好地管理版本；使用的库集合更加多样化。这为理解AI代理如何与现有软件生态系统交互提供了早期实证视角。

Abstract: Coding agents are becoming increasingly capable of completing end-to-end software engineering workflows that previously required a human developer, including raising pull requests (PRs) to propose their changes. However, we still know little about how these agents use libraries when generating code, a core part of real-world software development. To fill this gap, we study 26,760 agent-authored PRs from the AIDev dataset to examine three questions: how often do agents import libraries, how often do they introduce new dependencies (and with what versioning), and which specific libraries do they choose? We find that agents often import libraries (29.5% of PRs) but rarely add new dependencies (1.3% of PRs); and when they do, they follow strong versioning practices (75.0% specify a version), an improvement on direct LLM usage where versions are rarely mentioned. Generally, agents draw from a surprisingly diverse set of external libraries, contrasting with the limited "library preferences" seen in prior non-agentic LLM studies. Our results offer an early empirical view into how AI coding agents interact with today's software ecosystems.

</details>


<div id='cs.FL'></div>

# cs.FL [[Back]](#toc)

### [11] [Uniform winning strategies for the synchronization games on subclasses of finite automata](https://arxiv.org/abs/2512.11007)
*Henning Fernau,Carolina Haase,Stefan Hoffmann,Mikhail Volkov*

Main category: cs.FL

TL;DR: 证明了DS伪簇中的同步自动机具有统一的获胜策略，且DS是满足此性质的最大伪簇


<details>
  <summary>Details</summary>
Motivation: 研究同步自动机的同步游戏，探索哪些代数结构能保证存在统一的获胜策略

Method: 通过分析DS伪簇中有限幺半群的结构特性，构造Synchronizer在同步游戏中的统一获胜策略

Result: 对于所有转移幺半群属于DS的同步自动机，Synchronizer都有统一的获胜策略，且DS是满足此性质的最大伪簇

Conclusion: DS伪簇刻画了保证同步游戏存在统一获胜策略的代数特征，为同步自动机理论提供了重要的代数分类

Abstract: The pseudovariety $\mathbf{DS}$ consists of all finite monoids whose regular $D$-classes form subsemigroups. We exhibit a uniform winning strategy for Synchronizer in the synchronization game on every synchronizing automaton whose transition monoid lies in $\mathbf{DS}$, and we prove that $\mathbf{DS}$ is the largest pseudovariety with this property.

</details>

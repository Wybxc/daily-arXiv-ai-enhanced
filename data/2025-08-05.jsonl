{"id": "2508.01067", "categories": ["cs.LO", "cs.AI", "F.4.1; F.1.1; I.2.0"], "pdf": "https://arxiv.org/pdf/2508.01067", "abs": "https://arxiv.org/abs/2508.01067", "authors": ["Veeti Ahvonen", "Maurice Funk", "Damian Heiman", "Antti Kuusisto", "Carsten Lutz"], "title": "Expressive Power of Graph Transformers via Logic", "comment": null, "summary": "Transformers are the basis of modern large language models, but relatively\nlittle is known about their precise expressive power on graphs. We study the\nexpressive power of graph transformers (GTs) by Dwivedi and Bresson (2020) and\nGPS-networks by Ramp\\'asek et al. (2022), both under soft-attention and average\nhard-attention. Our study covers two scenarios: the theoretical setting with\nreal numbers and the more practical case with floats. With reals, we show that\nin restriction to vertex properties definable in first-order logic (FO),\nGPS-networks have the same expressive power as graded modal logic (GML) with\nthe global modality. With floats, GPS-networks turn out to be equally\nexpressive as GML with the counting global modality. The latter result is\nabsolute, not restricting to properties definable in a background logic. We\nalso obtain similar characterizations for GTs in terms of propositional logic\nwith the global modality (for reals) and the counting global modality (for\nfloats)."}
{"id": "2508.01535", "categories": ["cs.LO"], "pdf": "https://arxiv.org/pdf/2508.01535", "abs": "https://arxiv.org/abs/2508.01535", "authors": ["Yeonseok Lee", "Koji Nakazawa"], "title": "Relative Completeness of Incorrectness Separation Logic", "comment": "This is an extended version of a paper that appeared in the Asian\n  Symposium on Programming Languages and Systems (APLAS) 2024: Lee, Y.,\n  Nakazawa, K. \"Relative Completeness of Incorrectness Separation Logic.\" In:\n  Kiselyov, O. (eds) Programming Languages and Systems. Lecture Notes in\n  Computer Science, vol 15194. Springer, Singapore. DOI:\n  10.1007/978-981-97-8943-6_13", "summary": "Incorrectness Separation Logic (ISL) is a proof system that is tailored\nspecifically to resolve problems of under-approximation in programs that\nmanipulate heaps, and it primarily focuses on bug detection. This approach is\ndifferent from the over-approximation methods that are used in traditional\nlogics such as Hoare Logic or Separation Logic. Although the soundness of ISL\nhas been established, its completeness remains unproven. In this study, we\nestablish relative completeness by leveraging the expressiveness of the weakest\npostconditions; expressiveness is a factor that is critical to demonstrating\nrelative completeness in Reverse Hoare Logic. In our ISL framework, we allow\nfor infinite disjunctions in disjunctive normal forms, where each clause\ncomprises finite symbolic heaps with existential quantifiers. To compute the\nweakest postconditions in ISL, we introduce a canonicalization that includes\nvariable aliasing."}
{"id": "2508.01758", "categories": ["cs.LO", "cs.MA"], "pdf": "https://arxiv.org/pdf/2508.01758", "abs": "https://arxiv.org/abs/2508.01758", "authors": ["Pinaki Chakraborty", "Tristan Caulfield", "David Pym"], "title": "Causality and Decision-making: A Logical Framework for Systems and Security Modelling", "comment": "28 pages", "summary": "Causal reasoning is essential for understanding decision-making about the\nbehaviour of complex `ecosystems' of systems that underpin modern society, with\nsecurity -- including issues around correctness, safety, resilience, etc. --\ntypically providing critical examples. We present a theory of strategic\nreasoning about system modelling based on minimal structural assumptions and\nemploying the methods of transition systems, supported by a modal logic of\nsystem states in the tradition of van Benthem, Hennessy, and Milner, and\nvalidated through equivalence theorems. Our framework introduces an\nintervention operator and a separating conjunction to capture actual causal\nrelationships between component systems of the ecosystem, aligning naturally\nwith Halpern and Pearl's counterfactual approach based on Structural Causal\nModels. We illustrate the applicability through examples of of decision-making\nabout microservices in distributed systems. We discuss localized\ndecision-making through a separating conjunction. This work unifies a formal,\nminimalistic notion of system behaviour with a Halpern--Pearl-compatible theory\nof counterfactual reasoning, providing a logical foundation for studying\ndecision making about causality in complex interacting systems."}
{"id": "2508.01199", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2508.01199", "abs": "https://arxiv.org/abs/2508.01199", "authors": ["Avinash Malik"], "title": "Efficient compilation and execution of synchronous programs via type-state programming", "comment": null, "summary": "Synchronous programs are used extensively in implementation of safety\ncritical embedded software. Imperative synchronous programming languages model\nmultiple Finite State Machines (FSMs) executing in lockstep at logical clock\nticks. The synchronous view of time along with the FSM based design enables\neasier formal verification. The synchronous composition of multiple FSMs,\nduring compilation, results in the well known state space explosion problem.\nHence, efficiently compiling imperative synchronous programs into small and\nfast executables is challenging. This paper introduces a novel linear time\ncompilation technique for automata based compilation of synchronous programs.\nGraph based rewrite rules for kernel programming constructs are introduced. A\nlinear time algorithm applies these rules to produce a FSM. The FSM is then\nencoded into a type-state program using template meta-programming in C++.\nExperimental results show that the compilation time and generated binary size\nis comparable, while the execution times are on average 31-60% faster than\ncurrent state-of-the-art compilers."}
{"id": "2508.01866", "categories": ["cs.LO", "D.3.1; F.3.1; F.3.2; F.3.3; F.4.1"], "pdf": "https://arxiv.org/pdf/2508.01866", "abs": "https://arxiv.org/abs/2508.01866", "authors": ["Berend van Starkenburg", "Henning Basold", "Chase Ford"], "title": "Separation Logic of Generic Resources via Sheafeology", "comment": "55 pages including appendix", "summary": "Separation logic was conceived in order to make the verification of pointer\nprograms scalable to large systems and it has proven extremely effective. The\nkey idea is that programs typically access only small parts of memory, allowing\nfor local reasoning. This idea is implemented in separation logic by extending\nfirst-order logic with separating connectives, which inspect local regions of\nmemory. It turns that this approach not only applies to pointer programs, but\nalso to programs involving other resource structures. Various theories have\nbeen put forward to extract and apply the ideas of separation logic more\nbroadly. This resulted in algebraic abstractions of memory and many variants of\nseparation logic for, e.g., concurrent programs and stochastic processes.\nHowever, none of the existing approaches formulate the combination of\nfirst-order logic with separating connectives in a theory that could\nimmediately yield program logics for different resources. In this paper, we\npropose a framework based on the idea that separation logic can obtained by\nmaking first-order logic resource-aware. First-order logic can be understood in\nterms of categorical logic, specifically fibrations. Our contribution is to\nmake these resource-aware by developing categorical logic internally in\ncategories of sheaves, which is what we call sheafeology. The role of sheaves\nis to model views on resources, through which resources can be localised and\ncombined, which enables the scalability promised by separation logic. We\ncontribute constructions of an internal fibration in sheaf categories that\nmodels predicates on resources, and that admits first-order and separating\nconnectives. Thereby, we attain a general framework of separation logic for\ngeneric resources, a claim we substantiate by instantiating our framework to\nvarious memory models and random variables."}
{"id": "2508.02305", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2508.02305", "abs": "https://arxiv.org/abs/2508.02305", "authors": ["Rose Bohrer"], "title": "Proceedings 14th International Workshop on Trends in Functional Programming in Education", "comment": null, "summary": "The goal of TFPIE is to gather researchers, teachers and professionals that\nuse, or are interested in the use of, functional programming in education.\nTFPIE aims to be a venue where novel ideas, classroom-tested ideas and\nwork-in-progress on the use of functional programming in education are\ndiscussed. The one-day workshop will foster a spirit of open discussion by\nhaving a review process for publication after the workshop."}
{"id": "2508.01821", "categories": ["cs.FL", "F.4.3"], "pdf": "https://arxiv.org/pdf/2508.01821", "abs": "https://arxiv.org/abs/2508.01821", "authors": ["Dana Fisman", "Elina Sudit"], "title": "Runtime Consultants", "comment": null, "summary": "In this paper we introduce the notion of a runtime consultant. A runtime\nconsultant is defined with respect to some value function on infinite words.\nSimilar to a runtime monitor, it runs in parallel to an execution of the system\nand provides inputs at every step of the run. While a runtime monitor alerts\nwhen a violation occurs, the idea behind a consultant is to be pro-active and\nprovide recommendations for which action to take next in order to avoid\nviolation (or obtain a maximal value for quantitative objectives). It is\nassumed that a runtime-controller can take these recommendations into\nconsideration. The runtime consultant does not assume that its recommendations\nare always followed. Instead, it adjusts to the actions actually taken (similar\nto a vehicle navigation system). We show how to compute a runtime consultant\nfor common value functions used in verification, and that almost all have a\nruntime consultant that works in constant time. We also develop consultants for\n$\\omega$-regular properties, under both their classical Boolean semantics and\ntheir recently proposed quantitative interpretation."}
{"id": "2508.01255", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2508.01255", "abs": "https://arxiv.org/abs/2508.01255", "authors": ["Cuong Chi Le", "Cuong Duc Van", "Tung Duy Vu", "Thai Minh Pham Vu", "Hoang Nhat Phan", "Huy Nhat Phan", "Tien N. Nguyen"], "title": "TestWeaver: Execution-aware, Feedback-driven Regression Testing Generation with Large Language Models", "comment": null, "summary": "Regression testing ensures that code changes do not unintentionally break\nexisting functionality. While recent advances in large language models (LLMs)\nhave shown promise in automating test generation for regression testing, they\noften suffer from limited reasoning about program execution, resulting in\nstagnated coverage growth - a phenomenon known as the coverage plateau. In this\npaper, we present TestWeaver, a novel LLM-based approach that integrates\nlightweight program analysis to guide test generation more effectively.\nTestWeaver introduces three key innovations: (1) it reduces hallucinations and\nimproves focus by supplying the LLM with the backward slice from the target\nline instead of full program context; (2) it identifies and incorporates close\ntest cases - those that share control-flow similarities with the path to the\ntarget line - to provide execution context within the LLM's context window; and\n(3) it enhances LLM's reasoning with execution in-line annotations that encode\nvariable states as comments along executed paths. By equipping LLMs with these\ntargeted and contextualized inputs, TestWeaver improves coverage-guided test\ngeneration and mitigates redundant explorations. Empirical results demonstrate\nthat TestWeaver accelerates code coverage growth and generates more effective\nregression test cases than existing LLM-based approaches."}
{"id": "2508.02301", "categories": ["cs.LO", "68Q60, 68Q45", "F.3.1; D.3.1"], "pdf": "https://arxiv.org/pdf/2508.02301", "abs": "https://arxiv.org/abs/2508.02301", "authors": ["Marek Chalupa", "Thomas A. Henzinger", "Ana Oliveira da Costa"], "title": "Monitoring Hyperproperties over Observed and Constructed Traces", "comment": null, "summary": "We study the problem of monitoring at runtime whether a system fulfills a\nspecification defined by a hyperproperty, such as linearizability or variants\nof non-interference. For this purpose, we introduce specifications with both\npassive and active quantification over traces. While passive trace quantifiers\nrange over the traces that are observed, active trace quantifiers are\ninstantiated with \\emph{generator functions}, which are part of the\nspecification. Generator functions enable the monitor to construct traces that\nmay never be observed at runtime, such as the linearizations of a concurrent\ntrace. As specification language, we extend hypernode logic with trace\nquantifiers over generator functions and interpret these hypernode formulas\nover possibly infinite domains. We present a corresponding monitoring\nalgorithm, which we implemented and evaluated on a range of hyperproperties for\nconcurrency and security applications. Our method enables, for the first time,\nthe monitoring of asynchronous hyperproperties that contain alternating trace\nquantifiers."}
{"id": "2508.01974", "categories": ["cs.SE", "cs.PL"], "pdf": "https://arxiv.org/pdf/2508.01974", "abs": "https://arxiv.org/abs/2508.01974", "authors": ["Jiahao Zhang", "Xiao Cheng", "Yuxiang Lei"], "title": "Flow Sensitivity without Control Flow Graph: An Efficient Andersen-Style Flow-Sensitive Pointer Analysis", "comment": null, "summary": "Flow-sensitive pointer analysis constitutes an essential component of precise\nprogram analysis for accurately modeling pointer behaviors by incorporating\ncontrol flows. Flow-sensitive pointer analysis is extensively used in alias\nanalysis, taint analysis, program understanding, compiler optimization, etc.\nExisting flow-sensitive pointer analysis approaches, which are conducted based\non control flow graphs, have significantly advanced the precision of pointer\nanalysis via sophisticated techniques to leverage control flow information.\nHowever, they inevitably suffer from computational inefficiencies when\nresolving points-to information due to the inherent complex structures of\ncontrol flow graphs. We present CG-FSPTA, a Flow-Sensitive Constraint Graph\n(FSConsG) based flow-sensitive pointer analysis to overcome the inefficiency of\ncontrol-flow-graph-based analysis. CG-FSPTA uses a flow-sensitive variant to\nleverage the structural advantages of set-constraint graphs (which are commonly\nused in flow-insensitive pointer analysis) while keeping the flow sensitivity\nof variable definitions and uses, allowing the incorporation of sophisticated\ngraph optimization and dynamic solving techniques. In this way, CG-FSPTA\nachieves significant efficiency improvements while keeping the precision of\nflow-sensitive analysis. Experimental evaluations on benchmark programs\ndemonstrate that CG-FSPTA, significantly reduces both memory usage and\nexecution time while maintaining precision. In particular, by solving in the\nFSConsG, CG-FSPTA achieves an average memory reduction of 33.05\\% and\naccelerates flow-sensitive pointer analysis by 7.27x compared to the\nstate-of-art method. These experimental results underscore the efficacy of\nCG-FSPTA as a scalable solution to analyze large-scale software systems,\nestablishing a robust foundation for future advancements in efficient program\nanalysis frameworks."}
{"id": "2508.01337", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2508.01337", "abs": "https://arxiv.org/abs/2508.01337", "authors": ["Wei Liu", "Linqiang Guo", "Yi Wen Heng", "Chenglin Li", "Tse-Hsun", "Chen", "Ahmed E. Hassan"], "title": "Screencast-Based Analysis of User-Perceived GUI Responsiveness", "comment": null, "summary": "GUI responsiveness is critical for a positive user experience in mobile\napplications. Even brief delays in visual feedback can frustrate users and lead\nto negative reviews. However, detecting and quantifying such user-perceived\ndelays remains challenging, especially in industrial testing pipelines that\nevaluate thousands of apps daily across diverse devices and OS versions.\nExisting techniques based on static analysis or system metrics, while useful,\nmay not accurately capture user-perceived issues or scale effectively.\n  In this experience paper, we present \\tool, a lightweight and black-box\ntechnique that measures GUI responsiveness directly from mobile screencasts --\nvideo recordings captured during automated GUI testing. \\tool detects user\ninteractions and visual delays, helping developers identify GUI performance\nissues that affect the user experience. It uses computer vision to detect user\ninteractions and analyzes frame-level visual changes to compute two key\nmetrics: response time (from user action to first visual feedback) and finish\ntime (until visual feedback stabilizes). We evaluate \\tool on a manually\nannotated benchmark of 2,458 interactions from 64 popular Android apps. \\tool\nachieves 0.96 precision and 0.93 recall in detecting interactions, and measures\nresponse and finish times within 50\\,ms and 100\\,ms error, respectively, for\nover 89\\% of interactions. The tool has been deployed in an industrial testing\npipeline and analyzes thousands of screencasts daily, uncovering responsiveness\nissues missed by traditional tools and improving performance debugging\nefficiency."}
{"id": "2302.06506", "categories": ["cs.FL", "cs.DS", "cs.LO"], "pdf": "https://arxiv.org/pdf/2302.06506", "abs": "https://arxiv.org/abs/2302.06506", "authors": ["Nicola Cotumaccio"], "title": "A Myhill-Nerode Theorem for Generalized Automata, with Applications to Pattern Matching and Compression", "comment": null, "summary": "The model of generalized automata, introduced by Eilenberg in 1974, allows\nrepresenting a regular language more concisely than conventional automata by\nallowing edges to be labeled not only with characters, but also strings.\nGiammaresi and Montalbano introduced a notion of determinism for generalized\nautomata [STACS 1995]. While generalized deterministic automata retain many\nproperties of conventional deterministic automata, the uniqueness of a minimal\ngeneralized deterministic automaton is lost.\n  In the first part of the paper, we show that the lack of uniqueness can be\nexplained by introducing a set $ \\mathcal{W(A)} $ associated with a generalized\nautomaton $ \\mathcal{A} $. By fixing $ \\mathcal{W(A)} $, we are able to derive\nfor the first time a full Myhill-Nerode theorem for generalized automata, which\ncontains the textbook Myhill-Nerode theorem for conventional automata as a\ndegenerate case.\n  In the second part of the paper, we show that the set $ \\mathcal{W(A)} $\nleads to applications for pattern matching and data compression. Wheeler\nautomata [TCS 2017, SODA 2020] are a popular class of automata that can be\ncompactly stored using $ e \\log \\sigma (1 + o(1)) + O(e) $ bits ($ e $ being\nthe number of edges, $ \\sigma $ being the size of the alphabet) in such a way\nthat pattern matching queries can be solved in $ \\tilde{O}(m) $ time ($ m $\nbeing the length of the pattern). In the paper, we show how to extend these\nresults to generalized automata. More precisely, a Wheeler generalized automata\ncan be stored using $ \\mathfrak{e} \\log \\sigma (1 + o(1)) + O(e + rn) $ bits so\nthat pattern matching queries can be solved in $ \\tilde{O}(r m) $ time, where $\n\\mathfrak{e} $ is the total length of all edge labels, $ r $ is the maximum\nlength of an edge label and $ n $ is the number of states."}
{"id": "2508.01357", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2508.01357", "abs": "https://arxiv.org/abs/2508.01357", "authors": ["Yunhao Liang", "Ruixuan Ying", "Takuya Taniguchi", "Guwen Lyu", "Zhe Cui"], "title": "HyClone: Bridging LLM Understanding and Dynamic Execution for Semantic Code Clone Detection", "comment": null, "summary": "Code clone detection is a critical task in software engineering, aimed at\nidentifying duplicated or similar code fragments within or across software\nsystems. Traditional methods often fail to capture functional equivalence,\nparticularly for semantic clones (Type 4), where code fragments implement\nidentical functionality despite differing syntactic structures. Recent advances\nin large language models (LLMs) have shown promise in understanding code\nsemantics. However, directly applying LLMs to code clone detection yields\nsuboptimal results due to their sensitivity to syntactic differences. To\naddress these challenges, we propose a novel two-stage framework that combines\nLLM-based screening with execution-based validation for detecting semantic\nclones in Python programs. In the first stage, an LLM evaluates code pairs to\nfilter out obvious non-clones based on semantic analysis. For pairs not\nidentified as clones, the second stage employs an execution-based validation\napproach, utilizing LLM-generated test inputs to assess functional equivalence\nthrough cross-execution validation. Our experimental evaluation demonstrates\nsignificant improvements in precision, recall, and F1-score compared to direct\nLLM-based detection, highlighting the framework's effectiveness in identifying\nsemantic clones. Future work includes exploring cross-language clone detection\nand optimizing the framework for large-scale applications."}
{"id": "2508.01358", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2508.01358", "abs": "https://arxiv.org/abs/2508.01358", "authors": ["Elijah Kayode Adejumo", "Brittany Johnson"], "title": "An Empirical Validation of Open Source Repository Stability Metrics", "comment": null, "summary": "Over the past few decades, open source software has been continuously\nintegrated into software supply chains worldwide, drastically increasing\nreliance and dependence. Because of the role this software plays, it is\nimportant to understand ways to measure and promote its stability and potential\nfor sustainability. Recent work proposed the use of control theory to\nunderstand repository stability and evaluate repositories' ability to return to\nequilibrium after a disturbance such as the introduction of a new feature\nrequest, a spike in bug reports, or even the influx or departure of\ncontributors. This approach leverages commit frequency patterns, issue\nresolution rate, pull request merge rate, and community activity engagement to\nprovide a Composite Stability Index (CSI). While this framework has theoretical\nfoundations, there is no empirical validation of the CSI in practice. In this\npaper, we present the first empirical validation of the proposed CSI by\nexperimenting with 100 highly ranked GitHub repositories. Our results suggest\nthat (1) sampling weekly commit frequency pattern instead of daily is a more\nfeasible measure of commit frequency stability across repositories and (2)\nimproved statistical inferences (swapping mean with median), particularly with\nascertaining resolution and review times in issues and pull request, improves\nthe overall issue and pull request stability index. Drawing on our empirical\ndataset, we also derive data-driven half-width parameters that better align\nstability scores with real project behavior. These findings both confirm the\nviability of a control-theoretic lens on open-source health and provide\nconcrete, evidence-backed applications for real-world project monitoring tools."}
{"id": "2508.01430", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2508.01430", "abs": "https://arxiv.org/abs/2508.01430", "authors": ["Kaveh Shahedi", "Matthew Khouzam", "Heng Li", "Maxime Lamothe", "Foutse Khomh"], "title": "From Technical Excellence to Practical Adoption: Lessons Learned Building an ML-Enhanced Trace Analysis Tool", "comment": null, "summary": "System tracing has become essential for understanding complex software\nbehavior in modern systems, yet sophisticated trace analysis tools face\nsignificant adoption gaps in industrial settings. Through a year-long\ncollaboration with Ericsson Montr\\'eal, developing TMLL (Trace-Server Machine\nLearning Library, now in the Eclipse Foundation), we investigated barriers to\ntrace analysis adoption. Contrary to assumptions about complexity or automation\nneeds, practitioners struggled with translating expert knowledge into\nactionable insights, integrating analysis into their workflows, and trusting\nautomated results they could not validate. We identified what we called the\nExcellence Paradox: technical excellence can actively impede adoption when\nconflicting with usability, transparency, and practitioner trust. TMLL\naddresses this through adoption-focused design that embeds expert knowledge in\ninterfaces, provides transparent explanations, and enables incremental\nadoption. Validation through Ericsson's experts' feedback, Eclipse Foundation's\nintegration, and a survey of 40 industry and academic professionals revealed\nconsistent patterns: survey results showed that 77.5% prioritize quality and\ntrust in results over technical sophistication, while 67.5% prefer\nsemi-automated analysis with user control, findings supported by qualitative\nfeedback from industrial collaboration and external peer review. Results\nvalidate three core principles: cognitive compatibility, embedded expertise,\nand transparency-based trust. This challenges conventional capability-focused\ntool development, demonstrating that sustainable adoption requires\nreorientation toward adoption-focused design with actionable implications for\nautomated software engineering tools."}
{"id": "2508.01443", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2508.01443", "abs": "https://arxiv.org/abs/2508.01443", "authors": ["Jingzhi Gong", "Rafail Giavrimis", "Paul Brookes", "Vardan Voskanyan", "Fan Wu", "Mari Ashiga", "Matthew Truscott", "Mike Basios", "Leslie Kanthan", "Jie Xu", "Zheng Wang"], "title": "Tuning LLM-based Code Optimization via Meta-Prompting: An Industrial Perspective", "comment": "Submitted to ASE'25 Industry Showcase", "summary": "There is a growing interest in leveraging large language models (LLMs) for\nautomated code optimization. However, industrial platforms deploying multiple\nLLMs face a critical challenge: prompts optimized for one LLM often fail with\nothers, requiring expensive model-specific prompt engineering. This cross-model\nprompt engineering bottleneck severely limits the practical deployment of\nmulti-LLM optimization systems in production environments. To address this, we\nintroduce Meta-Prompted Code Optimization (MPCO), a framework that\nautomatically generates high-quality, task-specific prompts across diverse LLMs\nwhile maintaining industrial efficiency requirements. MPCO leverages\nmeta-prompting to dynamically synthesize context-aware optimization prompts by\nintegrating project metadata, task requirements, and LLM-specific contexts, and\nit seamlessly deploys on the ARTEMIS industrial platform for automated\nvalidation and scaling.\n  Our comprehensive evaluation on five real-world codebases with 366 hours of\nruntime benchmarking demonstrates MPCO's effectiveness: it achieves overall\nperformance improvements up to 19.06% with the best statistical rank across all\nsystems compared to baseline methods. Analysis shows that 96% of the\ntop-performing optimizations stem from meaningful edits. Through systematic\nablation studies and meta-prompter sensitivity analysis, we identify that\ncomprehensive context integration is essential for effective meta-prompting,\nand that all three major LLMs can serve effectively as meta-prompters,\nproviding actionable insights for industrial practitioners."}
{"id": "2508.01472", "categories": ["cs.SE", "68N99", "D.2.5"], "pdf": "https://arxiv.org/pdf/2508.01472", "abs": "https://arxiv.org/abs/2508.01472", "authors": ["Lukas Kirschner", "Ezekiel Soremekun"], "title": "Directed Grammar-Based Test Generation", "comment": "21 pages, 10 figures, 13 tables, submitted to IEEE Transactions on\n  Software Engineering, for replication package, see\n  https://tinyurl.com/FDLoop-V3", "summary": "To effectively test complex software, it is important to generate\ngoal-specific inputs, i.e., inputs that achieve a specific testing goal.\nHowever, most state-of-the-art test generators are not designed to target\nspecific goals. Notably, grammar-based test generators, which (randomly)\nproduce syntactically valid inputs via an input specification (i.e., grammar)\nhave a low probability of achieving an arbitrary testing goal. This work\naddresses this challenge by proposing an automated test generation approach\n(called FdLoop) which iteratively learns relevant input properties from\nexisting inputs to drive the generation of goal-specific inputs. Given a\ntesting goal, FdLoop iteratively selects, evolves and learn the input\ndistribution of goal-specific test inputs via test feedback and a probabilistic\ngrammar. We concretize FdLoop for four testing goals, namely unique code\ncoverage, input-to-code complexity, program failures (exceptions) and long\nexecution time. We evaluate FdLoop using three (3) well-known input formats\n(JSON, CSS and JavaScript) and 20 open-source software. In most (86%) settings,\nFdLoop outperforms all five tested baselines namely the baseline grammar-based\ntest generators (random, probabilistic and inverse-probabilistic methods),\nEvoGFuzz and DynaMosa. FdLoop is (up to) twice (2X) as effective as the best\nbaseline (EvoGFuzz) in inducing erroneous behaviors. In addition, we show that\nthe main components of FdLoop (i.e., input mutator, grammar mutator and test\nfeedbacks) contribute positively to its effectiveness. Finally, our evaluation\ndemonstrates that FdLoop effectively achieves single testing goals (revealing\nerroneous behaviors, generating complex inputs, or inducing long execution\ntime) and scales to multiple testing goals across varying parameter settings."}
{"id": "2508.01489", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2508.01489", "abs": "https://arxiv.org/abs/2508.01489", "authors": ["SK. Golam Saroar", "Waseefa Ahmed", "Elmira Onagh", "Maleknaz Nayebi"], "title": "GitHub Marketplace: Driving Automation and Fostering Innovation in Software Development", "comment": "SANER 2025 journal first paper", "summary": "GitHub, a central hub for collaborative software development, has\nrevolutionized the open-source software (OSS) ecosystem through its GitHub\nMarketplace, a platform launched in 2017 to host automation tools aimed at\nenhancing the efficiency and scalability of software projects. As the adoption\nof automation in OSS production grows, understanding the trends,\ncharacteristics, and underlying dynamics of this marketplace has become vital.\nFurthermore, despite the rich repository of academic research on software\nautomation, a disconnect persists between academia and industry practices. This\nstudy seeks to bridge this gap by providing a systematic analysis of the GitHub\nMarketplace, comparing trends observed in industry tools with advancements\nreported in academic literature, and identifying areas where academia can\ncontribute to practical innovation."}
{"id": "2508.01492", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2508.01492", "abs": "https://arxiv.org/abs/2508.01492", "authors": ["Angel C. Chavez-Moreno", "Cristina L. Abad"], "title": "OpenLambdaVerse: A Dataset and Analysis of Open-Source Serverless Applications", "comment": "8 pages, 7 figures, 13th IEEE International Conference on Cloud\n  Engineering (IC2E 2025, accepted, to appear)", "summary": "Function-as-a-Service (FaaS) is at the core of serverless computing, enabling\ndevelopers to easily deploy applications without managing computing resources.\nWith an Infrastructure-as-Code (IaC) approach, frameworks like the Serverless\nFramework use YAML configurations to define and deploy APIs, tasks, workflows,\nand event-driven applications on cloud providers, promoting zero-friction\ndevelopment. As with any rapidly evolving ecosystem, there is a need for\nupdated insights into how these tools are used in real-world projects. Building\non the methodology established by the Wonderless dataset for serverless\ncomputing (and applying multiple new filtering steps), OpenLambdaVerse\naddresses this gap by creating a dataset of current GitHub repositories that\nuse the Serverless Framework in applications that contain one or more AWS\nLambda functions. We then analyze and characterize this dataset to get an\nunderstanding of the state-of-the-art in serverless architectures based on this\nstack. Through this analysis we gain important insights on the size and\ncomplexity of current applications, which languages and runtimes they employ,\nhow are the functions triggered, the maturity of the projects, and their\nsecurity practices (or lack of). OpenLambdaVerse thus offers a valuable,\nup-to-date resource for both practitioners and researchers that seek to better\nunderstand evolving serverless workloads."}
{"id": "2508.01523", "categories": ["cs.SE", "cs.HC"], "pdf": "https://arxiv.org/pdf/2508.01523", "abs": "https://arxiv.org/abs/2508.01523", "authors": ["Ningzhi Tang", "Emory Smith", "Yu Huang", "Collin McMillan", "Toby Jia-Jun Li"], "title": "Exploring Direct Instruction and Summary-Mediated Prompting in LLM-Assisted Code Modification", "comment": null, "summary": "This paper presents a study of using large language models (LLMs) in\nmodifying existing code. While LLMs for generating code have been widely\nstudied, their role in code modification remains less understood. Although\n\"prompting\" serves as the primary interface for developers to communicate\nintents to LLMs, constructing effective prompts for code modification\nintroduces challenges different from generation. Prior work suggests that\nnatural language summaries may help scaffold this process, yet such approaches\nhave been validated primarily in narrow domains like SQL rewriting. This study\ninvestigates two prompting strategies for LLM-assisted code modification:\nDirect Instruction Prompting, where developers describe changes explicitly in\nfree-form language, and Summary-Mediated Prompting, where changes are made by\nediting the generated summaries of the code. We conducted an exploratory study\nwith 15 developers who completed modification tasks using both techniques\nacross multiple scenarios. Our findings suggest that developers followed an\niterative workflow: understanding the code, localizing the edit, and validating\noutputs through execution or semantic reasoning. Each prompting strategy\npresented trade-offs: direct instruction prompting was more flexible and easier\nto specify, while summary-mediated prompting supported comprehension, prompt\nscaffolding, and control. Developers' choice of strategy was shaped by task\ngoals and context, including urgency, maintainability, learning intent, and\ncode familiarity. These findings highlight the need for more usable prompt\ninteractions, including adjustable summary granularity, reliable summary-code\ntraceability, and consistency in generated summaries."}
{"id": "2508.01550", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2508.01550", "abs": "https://arxiv.org/abs/2508.01550", "authors": ["Zhilong Chen", "Chengzong Zhao", "Boyuan Chen", "Dayi Lin", "Yihao Chen", "Arthur Leung", "Gopi Krishnan Rajbahadur", "Gustavo A. Oliva", "Ahmed E. Hassan"], "title": "RepoForge: Training a SOTA Fast-thinking SWE Agent with an End-to-End Data Curation Pipeline Synergizing SFT and RL at Scale", "comment": null, "summary": "Training software engineering (SWE) LLMs is bottlenecked by expensive\ninfrastructure, inefficient evaluation pipelines, scarce training data, and\ncostly quality control. We present RepoForge, an autonomous, end-to-end\npipeline that generates, evaluates, and trains SWE agents at scale. Our key\ncontributions include: (1) RepoForge-8B-Agent, achieving 17.4\\% on\nSWE-Bench-Verified~\\citep{swebench_verified2024}, establishing new\nstate-of-the-art for $\\leq$8B non-thinking LLMs; (2) 7,304 executable\nenvironments auto-generated from real GitHub commits with zero manual\nintervention; (3) 14$\\times$ storage reduction (1.4GB $\\rightarrow$ 102MB per\ninstance) via intelligent dependency management and image pruning; (4) $>$70\\%\nfaster evaluation using a Ray-powered~\\citep{ray2018} distributed RepoForge\nharness; (5) 19,000$\\times$ cheaper labeling through our automated\nSPICE~\\citep{spice2024} difficulty assessment technique. By unifying\nstorage-efficient sandboxing, Ray-powered evaluation harness, automated data\ngeneration, SPICE-based labeling, and bubble-free RL scaffold, we demonstrate\nthat even $\\leq$8B models can reach new state-of-the-art performance on\ndemanding benchmarks like SWE-Bench-Verified. Our approach addresses critical\nbottlenecks in SWE agent training: high storage costs of container-based\nevaluation, inefficient sequential reward pipelines, limited availability of\nhigh-quality training data, expensive manual labeling, and multi-turn RL\npipeline bottlenecks."}
{"id": "2508.01974", "categories": ["cs.SE", "cs.PL"], "pdf": "https://arxiv.org/pdf/2508.01974", "abs": "https://arxiv.org/abs/2508.01974", "authors": ["Jiahao Zhang", "Xiao Cheng", "Yuxiang Lei"], "title": "Flow Sensitivity without Control Flow Graph: An Efficient Andersen-Style Flow-Sensitive Pointer Analysis", "comment": null, "summary": "Flow-sensitive pointer analysis constitutes an essential component of precise\nprogram analysis for accurately modeling pointer behaviors by incorporating\ncontrol flows. Flow-sensitive pointer analysis is extensively used in alias\nanalysis, taint analysis, program understanding, compiler optimization, etc.\nExisting flow-sensitive pointer analysis approaches, which are conducted based\non control flow graphs, have significantly advanced the precision of pointer\nanalysis via sophisticated techniques to leverage control flow information.\nHowever, they inevitably suffer from computational inefficiencies when\nresolving points-to information due to the inherent complex structures of\ncontrol flow graphs. We present CG-FSPTA, a Flow-Sensitive Constraint Graph\n(FSConsG) based flow-sensitive pointer analysis to overcome the inefficiency of\ncontrol-flow-graph-based analysis. CG-FSPTA uses a flow-sensitive variant to\nleverage the structural advantages of set-constraint graphs (which are commonly\nused in flow-insensitive pointer analysis) while keeping the flow sensitivity\nof variable definitions and uses, allowing the incorporation of sophisticated\ngraph optimization and dynamic solving techniques. In this way, CG-FSPTA\nachieves significant efficiency improvements while keeping the precision of\nflow-sensitive analysis. Experimental evaluations on benchmark programs\ndemonstrate that CG-FSPTA, significantly reduces both memory usage and\nexecution time while maintaining precision. In particular, by solving in the\nFSConsG, CG-FSPTA achieves an average memory reduction of 33.05\\% and\naccelerates flow-sensitive pointer analysis by 7.27x compared to the\nstate-of-art method. These experimental results underscore the efficacy of\nCG-FSPTA as a scalable solution to analyze large-scale software systems,\nestablishing a robust foundation for future advancements in efficient program\nanalysis frameworks."}
{"id": "2508.02023", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2508.02023", "abs": "https://arxiv.org/abs/2508.02023", "authors": ["Huashan Lei", "Guanping Xiao", "Yepang Liu", "Zheng Zheng"], "title": "PCREQ: Automated Inference of Compatible Requirements for Python Third-party Library Upgrades", "comment": "52 pages, 33 figures", "summary": "Python third-party libraries (TPLs) are essential in modern software\ndevelopment, but upgrades often cause compatibility issues, leading to system\nfailures. These issues fall into two categories: version compatibility issues\n(VCIs) and code compatibility issues (CCIs). Existing tools mainly detect\ndependency conflicts but overlook code-level incompatibilities, with no\nsolution fully automating the inference of compatible versions for both VCIs\nand CCIs. To fill this gap, we propose PCREQ, the first approach to\nautomatically infer compatible requirements by combining version and code\ncompatibility analysis. PCREQ integrates six modules: knowledge acquisition,\nversion compatibility assessment, invoked APIs and modules extraction, code\ncompatibility assessment, version change, and missing TPL completion. PCREQ\ncollects candidate versions, checks for conflicts, identifies API usage,\nevaluates code compatibility, and iteratively adjusts versions to generate a\ncompatible requirements.txt with a detailed repair report. To evaluate PCREQ,\nwe construct REQBench, a large-scale benchmark with 2,095 upgrade test cases\n(including 406 unsolvable by pip). Results show PCREQ achieves a 94.03%\ninference success rate, outperforming PyEGo (37.02%), ReadPyE (37.16%), and\nLLM-based approaches (GPT-4o, DeepSeek V3/R1) by 18-20%. PCREQ processes each\ncase from REQBench in 60.79s on average, demonstrating practical efficiency.\nPCREQ significantly reduces manual effort in troubleshooting upgrades,\nadvancing Python dependency maintenance automation."}
{"id": "2508.02144", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2508.02144", "abs": "https://arxiv.org/abs/2508.02144", "authors": ["Yusaku Kato", "Norihiro Yoshida", "Erina Makihara", "Katsuro Inoue"], "title": "BiFuzz: A Two-Stage Fuzzing Tool for Open-World Video Games", "comment": "4 pages, 5 figures", "summary": "Open-world video games present a broader search space than other games,\nposing challenges for test automation. Fuzzing, which generates new inputs by\nmutating an initial input, is commonly used to uncover failures. In this study,\nwe proposed BiFuzz, a two-stage fuzzer designed for automated testing of\nopen-world video games, and investigated its effectiveness. The results\nrevealed that BiFuzz mutated the overall strategy of gameplay and test cases,\nincluding actual movement paths, step by step. Consequently, BiFuzz can detect\n`stucking' failures. The tool and its video are at\nhttps://github.com/Yusaku-Kato/BiFuzz."}
{"id": "2508.02167", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2508.02167", "abs": "https://arxiv.org/abs/2508.02167", "authors": ["Yuxuan Wang", "Cristian Tirelli", "Giovanni Ansaloni", "Laura Pozzi", "David Atienza"], "title": "An MLIR-based Compilation Framework for Control Flow Management on CGRAs", "comment": null, "summary": "Coarse Grained Reconfigurable Arrays (CGRAs) present both high flexibility\nand efficiency, making them well-suited for the acceleration of intensive\nworkloads. Nevertheless, a key barrier towards their widespread adoption is\nposed by CGRA compilation, which must cope with a multi-dimensional space\nspanning both the spatial and the temporal domains. Indeed, state-of-the-art\ncompilers are limited in scope as they mostly deal with the data flow of\napplications, while having little or no support for control flow. Hence, they\nmostly target the mapping of single loops and/or delegate the management of\ncontrol flow divergences to ad-hoc hardware units.\n  Conversely, in this paper we show that control flow can be effectively\nmanaged and optimized at the compilation level, allowing for a broad set of\napplications to be targeted while being hardware-agnostic and achieving high\nperformance. We embody our methodology in a modular compilation framework\nconsisting of transformation and optimization passes, enabling support for\napplications with arbitrary control flows running on abstract CGRA meshes. We\nalso introduce a novel mapping methodology that acts as a compilation back-end,\naddressing the limitations in available CGRA hardware resources and\nguaranteeing a feasible solution in the compilation process. Our framework\nachieves up to 2.1X speedups over state-of-the-art approaches, purely through\ncompilation optimizations."}
{"id": "2508.02176", "categories": ["cs.SE", "cs.HC", "D.2.3; D.2.6; D.2.5; H.5.2"], "pdf": "https://arxiv.org/pdf/2508.02176", "abs": "https://arxiv.org/abs/2508.02176", "authors": ["Andrew Tropin"], "title": "Highly Interactive Testing for Uninterrupted Development Flow", "comment": "12 pages, ICFP-2025", "summary": "Highly interactive development environments (HIDEs) enable uninterrupted\ndevelopment flow through continuous program evolution and rapid hypothesis\nchecking. However, traditional testing approaches -- typically executed\nseparately via CLI -- isolate tests from HIDE tooling (interactive debuggers,\nvalue and stack inspectors, etc.) and introduce disruptive delays due to coarse\nexecution granularity and lack of runtime context. This disconnect breaks\ndevelopment flow by exceeding critical attention thresholds. In this paper we\npresent a library that provides runtime representation for tests, allowing\ntight integration with HIDEs, and enabling immediate access to HIDE tooling in\nthe context of test failure. We then describe development workflows enhanced\nwith testing and demonstrate how they achieve subsecond test reexecution times\ncrucial for maintaining developer focus."}
{"id": "2508.02233", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2508.02233", "abs": "https://arxiv.org/abs/2508.02233", "authors": ["Vincenzo De Martino", "Joel Castaño", "Fabio Palomba", "Xavier Franch", "Silverio Martínez-Fernández"], "title": "A Methodological Framework for LLM-Based Mining of Software Repositories", "comment": null, "summary": "Large Language Models (LLMs) are increasingly used in software engineering\nresearch, offering new opportunities for automating repository mining tasks.\nHowever, despite their growing popularity, the methodological integration of\nLLMs into Mining Software Repositories (MSR) remains poorly understood.\nExisting studies tend to focus on specific capabilities or performance\nbenchmarks, providing limited insight into how researchers utilize LLMs across\nthe full research pipeline. To address this gap, we conduct a mixed-method\nstudy that combines a rapid review and questionnaire survey in the field of\nLLM4MSR. We investigate (1) the approaches and (2) the threats that affect the\nempirical rigor of researchers involved in this field. Our findings reveal 15\nmethodological approaches, nine main threats, and 25 mitigation strategies.\nBuilding on these findings, we present PRIMES 2.0, a refined empirical\nframework organized into six stages, comprising 23 methodological substeps,\neach mapped to specific threats and corresponding mitigation strategies,\nproviding prescriptive and adaptive support throughout the lifecycle of\nLLM-based MSR studies. Our work contributes to establishing a more transparent\nand reproducible foundation for LLM-based MSR research."}
{"id": "2508.02279", "categories": ["cs.SE", "cs.AI", "cs.CL"], "pdf": "https://arxiv.org/pdf/2508.02279", "abs": "https://arxiv.org/abs/2508.02279", "authors": ["Mikio Nakano", "Hironori Takeuchi", "Sadahiro Yoshikawa", "Yoichi Matsuyama", "Kazunori Komatani"], "title": "Dialogue Systems Engineering: A Survey and Future Directions", "comment": "18 pages, 2 figures", "summary": "This paper proposes to refer to the field of software engineering related to\nthe life cycle of dialogue systems as Dialogue Systems Engineering, and surveys\nthis field while also discussing its future directions. With the advancement of\nlarge language models, the core technologies underlying dialogue systems have\nsignificantly progressed. As a result, dialogue system technology is now\nexpected to be applied to solving various societal issues and in business\ncontexts. To achieve this, it is important to build, operate, and continuously\nimprove dialogue systems correctly and efficiently. Accordingly, in addition to\napplying existing software engineering knowledge, it is becoming increasingly\nimportant to evolve software engineering tailored specifically to dialogue\nsystems. In this paper, we enumerate the knowledge areas of dialogue systems\nengineering based on those of software engineering, as defined in the Software\nEngineering Body of Knowledge (SWEBOK) Version 4.0, and survey each area. Based\non this survey, we identify unexplored topics in each area and discuss the\nfuture direction of dialogue systems engineering."}
{"id": "2508.02335", "categories": ["cs.SE", "cs.DL"], "pdf": "https://arxiv.org/pdf/2508.02335", "abs": "https://arxiv.org/abs/2508.02335", "authors": ["Matteo Cancellieri", "Martin Docekal", "David Pride", "Morane Gruenpeter", "David Douard", "Petr Knoth"], "title": "Interoperable verification and dissemination of software assets in repositories using COAR Notify", "comment": "8 pages. Presented at the 20th International Conference on Open\n  Repositories, June 15-18 2025, Chicago, Illinois, USA", "summary": "The discoverability, attribution, and reusability of open research software\nare often hindered by its obscurity within academic manuscripts. To address\nthis, the SoFAIR project (2024-2025) introduces a comprehensive workflow\nleveraging machine learning tools for extracting software mentions from\nresearch papers. The project integrates repository systems, authors, and\nservices like HAL and Software Heritage to ensure proper archiving, citation,\nand accessibility of research software in alignment with FAIR principles. To\nenable interoperable communication across the various systems we present an\nintegration of the COAR Notify Protocol, which facilitates automated,\ninteroperable communication among repositories and authors to validate and\ndisseminate software mentions. This paper outlines the SoFAIR workflow and the\nimplementation of the COAR Notify Protocol, emphasising its potential to\nenhance the visibility and credibility of research software as first-class\nbibliographic records."}
{"id": "2508.02338", "categories": ["cs.SE", "cs.RO"], "pdf": "https://arxiv.org/pdf/2508.02338", "abs": "https://arxiv.org/abs/2508.02338", "authors": ["Jiahui Wu", "Chengjie Lu", "Aitor Arrieta", "Shaukat Ali", "Thomas Peyrucain"], "title": "Vision Language Model-based Testing of Industrial Autonomous Mobile Robots", "comment": null, "summary": "Autonomous Mobile Robots (AMRs) are deployed in diverse environments (e.g.,\nwarehouses, retail spaces, and offices), where they work alongside humans.\nGiven that human behavior can be unpredictable and that AMRs may not have been\ntrained to handle all possible unknown and uncertain behaviors, it is important\nto test AMRs under a wide range of human interactions to ensure their safe\nbehavior. Moreover, testing in real environments with actual AMRs and humans is\noften costly, impractical, and potentially hazardous (e.g., it could result in\nhuman injury). To this end, we propose a Vision Language Model (VLM)-based\ntesting approach (RVSG) for industrial AMRs developed by PAL Robotics in Spain.\nBased on the functional and safety requirements, RVSG uses the VLM to generate\ndiverse human behaviors that violate these requirements. We evaluated RVSG with\nseveral requirements and navigation routes in a simulator using the latest AMR\nfrom PAL Robotics. Our results show that, compared with the baseline, RVSG can\neffectively generate requirement-violating scenarios. Moreover, RVSG-generated\nscenarios increase variability in robot behavior, thereby helping reveal their\nuncertain behaviors."}
{"id": "2508.02397", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2508.02397", "abs": "https://arxiv.org/abs/2508.02397", "authors": ["Lida Zhao", "Chaofan Li", "Yueming Wu", "Lyuye Zhang", "Jiahui Wu", "Chengwei Liu", "Sen Chen", "Yutao Hu", "Zhengzi Xu", "Yi Liu", "Jingquan Ge", "Jun Sun", "Yang Liu"], "title": "JC-Finder: Detecting Java Clone-based Third-Party Library by Class-level Tree Analysis", "comment": null, "summary": "While reusing third-party libraries (TPL) facilitates software development,\nits chaotic management has brought great threats to software maintenance and\nthe unauthorized use of source code also raises ethical problems such as\nmisconduct on copyrighted code. To identify TPL reuse in projects, Software\nComposition Analysis (SCA) is employed, and two categories of SCA techniques\nare used based on how TPLs are introduced: clone-based SCA and\npackage-manager-based SCA (PM-based SCA). Although introducing TPLs by clones\nis prevalent in Java, no clone-based SCA tools are specially designed for Java.\nAlso, directly applying clone-based SCA techniques from other tools is\nproblematic. To fill this gap, we introduce JC-Finder, a novel clone-based SCA\ntool that aims to accurately and comprehensively identify instances of TPL\nreuse introduced by source code clones in Java projects. JC-Finder achieves\nboth accuracy and efficiency in identifying TPL reuse from code cloning by\ncapturing features at the class level, maintaining inter-function\nrelationships, and excluding trivial or duplicated elements. To evaluate the\nefficiency of JC-Finder, we applied it to 9,965 most popular Maven libraries as\nreference data and tested the TPL reuse of 1,000 GitHub projects. The result\nshows that JC-Finder achieved an F1-score of 0.818, outperforming the other\nfunction-level tool by 0.427. The average time taken for resolving TPL reuse is\n14.2 seconds, which is approximately 9 times faster than the other tool. We\nfurther applied JC-Finder to 7,947 GitHub projects, revealing TPL reuse by code\nclones in 789 projects (about 9.89% of all projects) and identifying a total of\n2,142 TPLs. JC-Finder successfully detects 26.20% more TPLs that are not\nexplicitly declared in package managers."}
{"id": "2508.02407", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2508.02407", "abs": "https://arxiv.org/abs/2508.02407", "authors": ["Xinyi Wang", "Qinghua Xu", "Paolo Arcaini", "Shaukat Ali", "Thomas Peyrucain"], "title": "Quantum Machine Learning-based Test Oracle for Autonomous Mobile Robots", "comment": null, "summary": "Robots are increasingly becoming part of our daily lives, interacting with\nboth the environment and humans to perform their tasks. The software of such\nrobots often undergoes upgrades, for example, to add new functionalities, fix\nbugs, or delete obsolete functionalities. As a result, regression testing of\nrobot software becomes necessary. However, determining the expected correct\nbehavior of robots (i.e., a test oracle) is challenging due to the potentially\nunknown environments in which the robots must operate. To address this\nchallenge, machine learning (ML)-based test oracles present a viable solution.\nThis paper reports on the development of a test oracle to support regression\ntesting of autonomous mobile robots built by PAL Robotics (Spain), using\nquantum machine learning (QML), which enables faster training and the\nconstruction of more precise test oracles. Specifically, we propose a hybrid\nframework, QuReBot, that combines both quantum reservoir computing (QRC) and a\nsimple neural network, inspired by residual connection, to predict the expected\nbehavior of a robot. Results show that QRC alone fails to converge in our case,\nyielding high prediction error. In contrast, QuReBot converges and achieves 15%\nreduction of prediction error compared to the classical neural network\nbaseline. Finally, we further examine QuReBot under different configurations\nand offer practical guidance on optimal settings to support future robot\nsoftware testing."}
{"id": "2508.02455", "categories": ["cs.SE", "cs.AI", "cs.IR"], "pdf": "https://arxiv.org/pdf/2508.02455", "abs": "https://arxiv.org/abs/2508.02455", "authors": ["Daniele Cipollone", "Egor Bogomolov", "Arie van Deursen", "Maliheh Izadi"], "title": "TreeRanker: Fast and Model-agnostic Ranking System for Code Suggestions in IDEs", "comment": null, "summary": "Token-level code completion is one of the most critical features in modern\nIntegrated Development Environments (IDEs). It assists developers by suggesting\nrelevant identifiers and APIs during coding. While completions are typically\nderived from static analysis, their usefulness depends heavily on how they are\nranked, as correct predictions buried deep in the list are rarely seen by\nusers. Most current systems rely on hand-crafted heuristics or lightweight\nmachine learning models trained on user logs, which can be further improved to\ncapture context information and generalize across projects and coding styles.\nIn this work, we propose a new scoring approach to ranking static completions\nusing language models in a lightweight and model-agnostic way. Our method\norganizes all valid completions into a prefix tree and performs a single greedy\ndecoding pass to collect token-level scores across the tree. This enables a\nprecise token-aware ranking without needing beam search, prompt engineering, or\nmodel adaptations. The approach is fast, architecture-agnostic, and compatible\nwith already deployed models for code completion. These findings highlight a\npractical and effective pathway for integrating language models into already\nexisting tools within IDEs, and ultimately providing smarter and more\nresponsive developer assistance."}
{"id": "2508.02473", "categories": ["cs.SE", "cs.LG", "68N30", "D.2.3; D.1.2; I.2.2"], "pdf": "https://arxiv.org/pdf/2508.02473", "abs": "https://arxiv.org/abs/2508.02473", "authors": ["Xinfang Chen", "Siyang Xiao", "Xianying Zhu", "Junhong Xie", "Ming Liang", "Dajun Chen", "Wei Jiang", "Yong Li", "Peng Di"], "title": "An Efficient and Adaptive Next Edit Suggestion Framework with Zero Human Instructions in IDEs", "comment": "13 pages", "summary": "Code editing, including modifying, refactoring, and maintaining existing\ncode, is the most frequent task in software development and has garnered\nsignificant attention from AI-powered tools. However, existing solutions that\ntranslate explicit natural language instructions into code edits face critical\nlimitations, such as heavy reliance on human instruction input and high\nlatency, which hinder their effective integration into a developer's workflow.\nWe observe that developers' habitual behaviors and coding objectives are often\nreflected in their historical editing patterns, making this data key to\naddressing existing limitations. To leverage these insights, we propose NES\n(Next Edit Suggestion), an LLM-driven code editing framework that delivers an\ninstruction-free and low-latency experience. Built on a dual-model architecture\nand trained with our high-quality SFT and DAPO datasets, NES enhances\nproductivity by understanding developer intent while optimizing inference to\nminimize latency. NES is a scalable, industry-ready solution with a continuous\nTab key interaction workflow, seamlessly adopted by a FinTech company with over\n20,000 developers. Evaluations on real-world datasets show NES achieves 75.6%\nand 81.6% accuracy in two tasks of predicting next edit locations, alongside\n91.36% ES and 27.7% EMR for intent-aligned edits, outperforming SOTA models.\nOur open-sourced SFT and DAPO datasets have been demonstrated to enhance the\nperformance of open-source CodeLLMs. The demonstration of NES is available at\nhttps://youtu.be/yGoyYOe6fbY."}
{"id": "2508.02487", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2508.02487", "abs": "https://arxiv.org/abs/2508.02487", "authors": ["Elijah Kayode Adejumo", "Brittany Johnson", "Mariam Guizani"], "title": "Commit Stability as a Signal for Risk in Open-Source Projects", "comment": null, "summary": "Open source software (OSS) generates trillions of dollars in economic value\nand has become essential to technical infrastructures worldwide. As\norganizations increasingly depend on OSS, understanding project evolution is\ncritical. While existing metrics provide insights into project health, one\ndimension remains understudied: project resilience -- the ability to return to\nnormal operations after disturbances such as contributor departures, security\nvulnerabilities, and bug report spikes. We hypothesize that stable commit\npatterns reflect underlying project characteristics such as mature governance,\nsustained contributors, and robust development processes that enable\nresilience. Building on the Composite Stability Index (CSI) framework, we\nempirically validate commit frequency patterns across 100 highly ranked\nrepositories. Our findings reveal that only 2\\% of repositories exhibit daily\nstability, 29\\% achieve weekly stability, and 50\\% demonstrate monthly\nstability, while half remain unstable across all temporal levels. Programming\nlanguages and blockchain applications were the most stable. We identified two\nexemplary repositories that achieved stability at all three granularities,\nwhose governance models, CI cadence, and release policies could serve as\nreference frameworks. We observed that large yearly commit throughput does not\nnecessarily correlate with stability. Beyond commits, stability can be enriched\nwith issue-resolution times, PR merge rates, and community-engagement metrics\nto broaden resilience assessment and sharpen stability-based risk evaluation."}
{"id": "2508.02497", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2508.02497", "abs": "https://arxiv.org/abs/2508.02497", "authors": ["Elijah Kayode Adejumo", "Brittany Johnson", "Mariam Guizani"], "title": "Bridging Language Gaps in Open-Source Documentation with Large-Language-Model Translation", "comment": null, "summary": "While open source communities attract diverse contributors globally, few\nrepositories provide essential documentation in languages other than English.\nLarge language models (LLMs) have demonstrated remarkable capabilities in\nsoftware engineering tasks and translations across domains. However, little is\nknown about LLM capabilities in translating open-source technical\ndocumentation, which mixes natural language, code, URLs, and markdown\nformatting. To understand the need and potential for LLMs in technical\ndocumentation translation, we evaluated community translation activity and\nEnglish-to-German translations of 50 README files using OpenAI's ChatGPT 4 and\nAnthropic's Claude. We found scarce translation activity, mostly in larger\nrepositories and community-driven in nature. LLM performance comparison\nsuggests they can provide accurate translations. However, analysis revealed\nfidelity challenges: both models struggled to preserve structural components\n(e.g., hyperlinks) and exhibited formatting inconsistencies. These findings\nhighlight both promise and challenges of LLM-assisted documentation\ninternationalization. As a first step toward translation-aware continuous\nintegration pipelines, we introduce TRIFID, an early-stage translation fidelity\nscoring framework that automatically checks how well translations preserve\ncode, links, and formatting. Our efforts provide a foundation for automated\nLLM-driven support for creating and maintaining open source documentation."}
{"id": "2508.02541", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2508.02541", "abs": "https://arxiv.org/abs/2508.02541", "authors": ["Peter Hamfelt", "Ricardo Britto", "Lincoln Rocha", "Camilo Almendra"], "title": "Automatic Identification of Machine Learning-Specific Code Smells", "comment": null, "summary": "Machine learning (ML) has rapidly grown in popularity, becoming vital to many\nindustries. Currently, the research on code smells in ML applications lacks\ntools and studies that address the identification and validity of ML-specific\ncode smells. This work investigates suitable methods and tools to design and\ndevelop a static code analysis tool (MLpylint) based on code smell criteria.\nThis research employed the Design Science Methodology. In the problem\nidentification phase, a literature review was conducted to identify ML-specific\ncode smells. In solution design, a secondary literature review and\nconsultations with experts were performed to select methods and tools for\nimplementing the tool. We evaluated the tool on data from 160 open-source ML\napplications sourced from GitHub. We also conducted a static validation through\nan expert survey involving 15 ML professionals. The results indicate the\neffectiveness and usefulness of the MLpylint. We aim to extend our current\napproach by investigating ways to introduce MLpylint seamlessly into\ndevelopment workflows, fostering a more productive and innovative developer\nenvironment."}
{"id": "2508.02611", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2508.02611", "abs": "https://arxiv.org/abs/2508.02611", "authors": ["Vali Tawosia", "Salwa Alamir", "Xiaomo Liu", "Manuela Veloso"], "title": "Meta-RAG on Large Codebases Using Code Summarization", "comment": null, "summary": "Large Language Model (LLM) systems have been at the forefront of applied\nArtificial Intelligence (AI) research in a multitude of domains. One such\ndomain is software development, where researchers have pushed the automation of\na number of code tasks through LLM agents. Software development is a complex\necosystem, that stretches far beyond code implementation and well into the\nrealm of code maintenance. In this paper, we propose a multi-agent system to\nlocalize bugs in large pre-existing codebases using information retrieval and\nLLMs. Our system introduces a novel Retrieval Augmented Generation (RAG)\napproach, Meta-RAG, where we utilize summaries to condense codebases by an\naverage of 79.8\\%, into a compact, structured, natural language representation.\nWe then use an LLM agent to determine which parts of the codebase are critical\nfor bug resolution, i.e. bug localization. We demonstrate the usefulness of\nMeta-RAG through evaluation with the SWE-bench Lite dataset. Meta-RAG scores\n84.67 % and 53.0 % for file-level and function-level correct localization\nrates, respectively, achieving state-of-the-art performance."}

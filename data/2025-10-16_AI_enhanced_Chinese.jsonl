{"id": "2510.12803", "categories": ["cs.SE", "cs.AI", "cs.CL", "cs.PL"], "pdf": "https://arxiv.org/pdf/2510.12803", "abs": "https://arxiv.org/abs/2510.12803", "authors": ["Shang Zhou", "Zihan Zheng", "Kaiyuan Liu", "Zeyu Shen", "Zerui Cheng", "Zexing Chen", "Hansen He", "Jianzhu Yao", "Huanzhi Mao", "Qiuyang Mang", "Tianfu Fu", "Beichen Li", "Dongruixuan Li", "Wenhao Chai", "Zhuang Liu", "Aleksandra Korolova", "Peter Henderson", "Natasha Jaques", "Pramod Viswanath", "Saining Xie", "Jingbo Shang"], "title": "AutoCode: LLMs as Problem Setters for Competitive Programming", "comment": "Project page: https://livecodebenchpro.com/projects/autocode/overview", "summary": "Writing competitive programming problems is exacting. Authors must: set\nconstraints, input distributions, and edge cases that rule out shortcuts;\ntarget specific algorithms (e.g., max-flow, dynamic programming, data\nstructures); and calibrate complexity beyond the reach of most competitors. We\nargue that this makes for an ideal test of general large language model\ncapabilities and study whether they can do this reliably. We introduce\nAutoCode, which uses multiple rounds of validation to yield competition-grade\nproblem statements and test cases. On held-out problems, AutoCode test suites\napproach 99% consistency with official judgments, a significant improvement\nover current state-of-the-art methods like HardTests, which achieve less than\n81%. Furthermore, starting with a random seed problem, AutoCode can create\nnovel variants with reference and brute-force solutions. By cross-verifying\nthese generated solutions against test cases, we can further filter out\nmalformed problems. Our system ensures high correctness, as verified by human\nexperts. AutoCode successfully produces novel problems judged by\nGrandmaster-level (top 0.3%) competitive programmers to be of contest quality.", "AI": {"tldr": "AutoCode\u662f\u4e00\u4e2a\u4f7f\u7528\u591a\u8f6e\u9a8c\u8bc1\u751f\u6210\u7ade\u8d5b\u7ea7\u7f16\u7a0b\u9898\u76ee\u548c\u6d4b\u8bd5\u7528\u4f8b\u7684\u7cfb\u7edf\uff0c\u5728\u4fdd\u7559\u95ee\u9898\u4e0a\u6d4b\u8bd5\u5957\u4ef6\u4e0e\u5b98\u65b9\u8bc4\u5224\u7684\u4e00\u81f4\u6027\u63a5\u8fd199%\uff0c\u663e\u8457\u4f18\u4e8e\u73b0\u6709\u65b9\u6cd5\u3002", "motivation": "\u7f16\u5199\u7ade\u8d5b\u7f16\u7a0b\u9898\u76ee\u9700\u8981\u8bbe\u7f6e\u7ea6\u675f\u6761\u4ef6\u3001\u8f93\u5165\u5206\u5e03\u548c\u8fb9\u754c\u60c5\u51b5\uff0c\u9488\u5bf9\u7279\u5b9a\u7b97\u6cd5\uff0c\u5e76\u6821\u51c6\u8d85\u51fa\u5927\u591a\u6570\u53c2\u8d5b\u8005\u80fd\u529b\u7684\u590d\u6742\u5ea6\uff0c\u8fd9\u4f7f\u5176\u6210\u4e3a\u6d4b\u8bd5\u5927\u8bed\u8a00\u6a21\u578b\u901a\u7528\u80fd\u529b\u7684\u7406\u60f3\u573a\u666f\u3002", "method": "AutoCode\u4f7f\u7528\u591a\u8f6e\u9a8c\u8bc1\u751f\u6210\u9898\u76ee\u9648\u8ff0\u548c\u6d4b\u8bd5\u7528\u4f8b\uff0c\u4ece\u968f\u673a\u79cd\u5b50\u95ee\u9898\u521b\u5efa\u65b0\u9896\u53d8\u4f53\uff0c\u5e76\u901a\u8fc7\u4ea4\u53c9\u9a8c\u8bc1\u751f\u6210\u7684\u53c2\u8003\u548c\u66b4\u529b\u89e3\u51b3\u65b9\u6848\u4e0e\u6d4b\u8bd5\u7528\u4f8b\u6765\u8fc7\u6ee4\u6709\u95ee\u9898\u7684\u9898\u76ee\u3002", "result": "\u5728\u4fdd\u7559\u95ee\u9898\u4e0a\uff0cAutoCode\u6d4b\u8bd5\u5957\u4ef6\u4e0e\u5b98\u65b9\u8bc4\u5224\u7684\u4e00\u81f4\u6027\u8fbe\u5230\u63a5\u8fd199%\uff0c\u663e\u8457\u4f18\u4e8eHardTests\u7b49\u73b0\u6709\u65b9\u6cd5\uff08\u4f4e\u4e8e81%\uff09\u3002\u7cfb\u7edf\u6210\u529f\u751f\u6210\u4e86\u88ab\u9876\u7ea7\u7a0b\u5e8f\u5458\u8bc4\u4e3a\u7ade\u8d5b\u8d28\u91cf\u7684\u65b0\u9896\u9898\u76ee\u3002", "conclusion": "AutoCode\u80fd\u591f\u53ef\u9760\u5730\u751f\u6210\u7ade\u8d5b\u7ea7\u7f16\u7a0b\u9898\u76ee\uff0c\u901a\u8fc7\u591a\u8f6e\u9a8c\u8bc1\u548c\u4ea4\u53c9\u9a8c\u8bc1\u786e\u4fdd\u9ad8\u8d28\u91cf\uff0c\u9a8c\u8bc1\u4e86\u5927\u8bed\u8a00\u6a21\u578b\u5728\u590d\u6742\u7f16\u7a0b\u4efb\u52a1\u4e2d\u7684\u80fd\u529b\u3002"}}
{"id": "2510.12948", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.12948", "abs": "https://arxiv.org/abs/2510.12948", "authors": ["Minh Nguyen"], "title": "SpareCodeSearch: Searching for Code Context When You Have No Spare GPU", "comment": "4 pages, 3 figures, 4 tables. Accepted to Context Collection Workshop\n  co-located with ASE'25", "summary": "Retrieval-Augmented Generation (RAG) frameworks aim to enhance Code Language\nModels (CLMs) by including another module for retrieving relevant context to\nconstruct the input prompt. However, these retrieval modules commonly use\nsemantic search, requiring substantial computational resources for training and\nhosting these embedded models, making them infeasible to integrate into\nlightweight applications such as in-IDE AI-based code completion. In this\nsolution paper, we prove that using keyword-search is sufficient to retrieve\nrelevant and useful code context inside large codebases, without the need for\nextensive GPU resources. The usefulness of code contexts found by our solution\nis demonstrated through their completion results on the Code Context\nCompetition's benchmark, reaching 0.748 and 0.725 chRF scores on Kotlin and\nPython tracks, respectively.", "AI": {"tldr": "\u672c\u6587\u8bc1\u660e\u5728\u5927\u578b\u4ee3\u7801\u5e93\u4e2d\u4f7f\u7528\u5173\u952e\u8bcd\u641c\u7d22\u8db3\u4ee5\u68c0\u7d22\u76f8\u5173\u4ee3\u7801\u4e0a\u4e0b\u6587\uff0c\u65e0\u9700GPU\u8d44\u6e90\uff0c\u5728\u4ee3\u7801\u8865\u5168\u4efb\u52a1\u4e2d\u8868\u73b0\u826f\u597d\u3002", "motivation": "\u73b0\u6709\u7684\u68c0\u7d22\u589e\u5f3a\u751f\u6210\u6846\u67b6\u901a\u5e38\u4f7f\u7528\u8bed\u4e49\u641c\u7d22\uff0c\u9700\u8981\u5927\u91cf\u8ba1\u7b97\u8d44\u6e90\uff0c\u96be\u4ee5\u96c6\u6210\u5230\u8f7b\u91cf\u7ea7\u5e94\u7528\u4e2d\u5982IDE\u4ee3\u7801\u8865\u5168\u3002", "method": "\u4f7f\u7528\u5173\u952e\u8bcd\u641c\u7d22\u66ff\u4ee3\u8bed\u4e49\u641c\u7d22\u6765\u68c0\u7d22\u76f8\u5173\u4ee3\u7801\u4e0a\u4e0b\u6587\uff0c\u6784\u5efa\u8f93\u5165\u63d0\u793a\u3002", "result": "\u5728Code Context Competition\u57fa\u51c6\u6d4b\u8bd5\u4e2d\uff0cKotlin\u548cPython\u8f68\u9053\u5206\u522b\u8fbe\u52300.748\u548c0.725\u7684chRF\u5206\u6570\u3002", "conclusion": "\u5173\u952e\u8bcd\u641c\u7d22\u662f\u68c0\u7d22\u4ee3\u7801\u4e0a\u4e0b\u6587\u7684\u6709\u6548\u65b9\u6cd5\uff0c\u53ef\u5728\u8d44\u6e90\u53d7\u9650\u73af\u5883\u4e2d\u66ff\u4ee3\u8bed\u4e49\u641c\u7d22\u3002"}}
{"id": "2510.13078", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.13078", "abs": "https://arxiv.org/abs/2510.13078", "authors": ["Tri Minh-Triet Pham", "Diego Elias Costa", "Weiyi Shang", "Jinqiu Yang"], "title": "ADPerf: Investigating and Testing Performance in Autonomous Driving Systems", "comment": "13 pages, accepted by ASE 2025", "summary": "Obstacle detection is crucial to the operation of autonomous driving systems,\nwhich rely on multiple sensors, such as cameras and LiDARs, combined with code\nlogic and deep learning models to detect obstacles for time-sensitive\ndecisions. Consequently, obstacle detection latency is critical to the safety\nand effectiveness of autonomous driving systems. However, the latency of the\nobstacle detection module and its resilience to various changes in the LiDAR\npoint cloud data are not yet fully understood. In this work, we present the\nfirst comprehensive investigation on measuring and modeling the performance of\nthe obstacle detection modules in two industry-grade autonomous driving\nsystems, i.e., Apollo and Autoware. Learning from this investigation, we\nintroduce ADPerf, a tool that aims to generate realistic point cloud data test\ncases that can expose increased detection latency. Increasing latency decreases\nthe availability of the detected obstacles and stresses the capabilities of\nsubsequent modules in autonomous driving systems, i.e., the modules may be\nnegatively impacted by the increased latency in obstacle detection.\n  We applied ADPerf to stress-test the performance of widely used 3D obstacle\ndetection modules in autonomous driving systems, as well as the propagation of\nsuch tests on trajectory prediction modules. Our evaluation highlights the need\nto conduct performance testing of obstacle detection components, especially 3D\nobstacle detection, as they can be a major bottleneck to increased latency of\nthe autonomous driving system. Such an adverse outcome will also further\npropagate to other modules, reducing the overall reliability of autonomous\ndriving systems.", "AI": {"tldr": "ADPerf\u5de5\u5177\u7528\u4e8e\u6d4b\u8bd5\u81ea\u52a8\u9a7e\u9a76\u7cfb\u7edf\u4e2d\u969c\u788d\u7269\u68c0\u6d4b\u6a21\u5757\u7684\u6027\u80fd\uff0c\u901a\u8fc7\u751f\u6210\u771f\u5b9e\u70b9\u4e91\u6570\u636e\u6d4b\u8bd5\u7528\u4f8b\u6765\u66b4\u9732\u68c0\u6d4b\u5ef6\u8fdf\u589e\u52a0\u7684\u95ee\u9898\uff0c\u8bc4\u4f30\u5ef6\u8fdf\u5bf9\u8f68\u8ff9\u9884\u6d4b\u6a21\u5757\u7684\u5f71\u54cd\u3002", "motivation": "\u81ea\u52a8\u9a7e\u9a76\u7cfb\u7edf\u4f9d\u8d56\u591a\u4f20\u611f\u5668\u548c\u6df1\u5ea6\u5b66\u4e60\u6a21\u578b\u8fdb\u884c\u969c\u788d\u7269\u68c0\u6d4b\uff0c\u4f46\u68c0\u6d4b\u5ef6\u8fdf\u53ca\u5176\u5bf9\u70b9\u4e91\u6570\u636e\u53d8\u5316\u7684\u5f39\u6027\u5c1a\u672a\u88ab\u5145\u5206\u7406\u89e3\uff0c\u8fd9\u5173\u7cfb\u5230\u7cfb\u7edf\u7684\u5b89\u5168\u6027\u548c\u6709\u6548\u6027\u3002", "method": "\u5bf9Apollo\u548cAutoware\u4e24\u4e2a\u5de5\u4e1a\u7ea7\u81ea\u52a8\u9a7e\u9a76\u7cfb\u7edf\u8fdb\u884c\u969c\u788d\u7269\u68c0\u6d4b\u6a21\u5757\u6027\u80fd\u6d4b\u91cf\u548c\u5efa\u6a21\uff0c\u5f00\u53d1ADPerf\u5de5\u5177\u751f\u6210\u771f\u5b9e\u70b9\u4e91\u6570\u636e\u6d4b\u8bd5\u7528\u4f8b\u6765\u66b4\u9732\u68c0\u6d4b\u5ef6\u8fdf\u95ee\u9898\u3002", "result": "\u8bc4\u4f30\u663e\u793a3D\u969c\u788d\u7269\u68c0\u6d4b\u6a21\u5757\u53ef\u80fd\u6210\u4e3a\u81ea\u52a8\u9a7e\u9a76\u7cfb\u7edf\u5ef6\u8fdf\u589e\u52a0\u7684\u4e3b\u8981\u74f6\u9888\uff0c\u8fd9\u79cd\u4e0d\u5229\u5f71\u54cd\u4f1a\u8fdb\u4e00\u6b65\u4f20\u64ad\u5230\u5176\u4ed6\u6a21\u5757\uff0c\u964d\u4f4e\u7cfb\u7edf\u6574\u4f53\u53ef\u9760\u6027\u3002", "conclusion": "\u9700\u8981\u8fdb\u884c\u969c\u788d\u7269\u68c0\u6d4b\u7ec4\u4ef6\u7684\u6027\u80fd\u6d4b\u8bd5\uff0c\u7279\u522b\u662f3D\u969c\u788d\u7269\u68c0\u6d4b\uff0c\u56e0\u4e3a\u5b83\u4eec\u53ef\u80fd\u6210\u4e3a\u81ea\u52a8\u9a7e\u9a76\u7cfb\u7edf\u5ef6\u8fdf\u589e\u52a0\u7684\u4e3b\u8981\u74f6\u9888\uff0c\u5e76\u5f71\u54cd\u5176\u4ed6\u6a21\u5757\u7684\u53ef\u9760\u6027\u3002"}}
{"id": "2510.13082", "categories": ["cs.PL", "cs.SE", "quant-ph"], "pdf": "https://arxiv.org/pdf/2510.13082", "abs": "https://arxiv.org/abs/2510.13082", "authors": ["Mark Koch", "Agust\u00edn Borgna", "Craig Roy", "Alan Lawrence", "Kartik Singhal", "Seyon Sivarajah", "Ross Duncan"], "title": "Imperative Quantum Programming with Ownership and Borrowing in Guppy", "comment": "Presented at the Fifth International Workshop on Programming\n  Languages for Quantum Computing (PLanQC 2025)", "summary": "Linear types enforce no-cloning and no-deleting theorems in functional\nquantum programming. However, in imperative quantum programming, they have not\ngained widespread adoption. This work aims to develop a quantum type system\nthat combines ergonomic linear typing with imperative semantics and maintains\nsafety guarantees. All ideas presented here have been implemented in\nQuantinuum's Guppy programming language.", "AI": {"tldr": "\u5f00\u53d1\u7ed3\u5408\u7ebf\u6027\u7c7b\u578b\u4e0e\u547d\u4ee4\u5f0f\u8bed\u4e49\u7684\u91cf\u5b50\u7c7b\u578b\u7cfb\u7edf\uff0c\u5df2\u5728Guppy\u7f16\u7a0b\u8bed\u8a00\u4e2d\u5b9e\u73b0", "motivation": "\u7ebf\u6027\u7c7b\u578b\u5728\u51fd\u6570\u5f0f\u91cf\u5b50\u7f16\u7a0b\u4e2d\u5f3a\u5236\u6267\u884c\u65e0\u514b\u9686\u548c\u65e0\u5220\u9664\u5b9a\u7406\uff0c\u4f46\u5728\u547d\u4ee4\u5f0f\u91cf\u5b50\u7f16\u7a0b\u4e2d\u5c1a\u672a\u5e7f\u6cdb\u5e94\u7528", "method": "\u5f00\u53d1\u7ed3\u5408\u4eba\u4f53\u5de5\u5b66\u7ebf\u6027\u7c7b\u578b\u4e0e\u547d\u4ee4\u5f0f\u8bed\u4e49\u7684\u91cf\u5b50\u7c7b\u578b\u7cfb\u7edf\uff0c\u4fdd\u6301\u5b89\u5168\u4fdd\u8bc1", "result": "\u6240\u6709\u60f3\u6cd5\u5df2\u5728Quantinuum\u7684Guppy\u7f16\u7a0b\u8bed\u8a00\u4e2d\u5b9e\u73b0", "conclusion": "\u6210\u529f\u5f00\u53d1\u4e86\u7ed3\u5408\u7ebf\u6027\u7c7b\u578b\u4e0e\u547d\u4ee4\u5f0f\u8bed\u4e49\u7684\u91cf\u5b50\u7c7b\u578b\u7cfb\u7edf"}}
{"id": "2510.13106", "categories": ["cs.SE", "cs.AI", "cs.CL"], "pdf": "https://arxiv.org/pdf/2510.13106", "abs": "https://arxiv.org/abs/2510.13106", "authors": ["Ruoyu Sun", "Da Song", "Jiayang Song", "Yuheng Huang", "Lei Ma"], "title": "TRUSTVIS: A Multi-Dimensional Trustworthiness Evaluation Framework for Large Language Models", "comment": "4 pages, 2 figures, To appear in ASE 2025 Demo Track", "summary": "As Large Language Models (LLMs) continue to revolutionize Natural Language\nProcessing (NLP) applications, critical concerns about their trustworthiness\npersist, particularly in safety and robustness. To address these challenges, we\nintroduce TRUSTVIS, an automated evaluation framework that provides a\ncomprehensive assessment of LLM trustworthiness. A key feature of our framework\nis its interactive user interface, designed to offer intuitive visualizations\nof trustworthiness metrics. By integrating well-known perturbation methods like\nAutoDAN and employing majority voting across various evaluation methods,\nTRUSTVIS not only provides reliable results but also makes complex evaluation\nprocesses accessible to users. Preliminary case studies on models like\nVicuna-7b, Llama2-7b, and GPT-3.5 demonstrate the effectiveness of our\nframework in identifying safety and robustness vulnerabilities, while the\ninteractive interface allows users to explore results in detail, empowering\ntargeted model improvements. Video Link: https://youtu.be/k1TrBqNVg8g", "AI": {"tldr": "TRUSTVIS\u662f\u4e00\u4e2a\u81ea\u52a8\u5316\u8bc4\u4f30\u6846\u67b6\uff0c\u901a\u8fc7\u4ea4\u4e92\u5f0f\u754c\u9762\u548c\u53ef\u89c6\u5316\u5de5\u5177\u5168\u9762\u8bc4\u4f30\u5927\u8bed\u8a00\u6a21\u578b\u7684\u4fe1\u4efb\u5ea6\uff0c\u7279\u522b\u662f\u5b89\u5168\u6027\u548c\u9c81\u68d2\u6027\u3002", "motivation": "\u968f\u7740\u5927\u8bed\u8a00\u6a21\u578b\u5728NLP\u5e94\u7528\u4e2d\u7684\u666e\u53ca\uff0c\u5176\u4fe1\u4efb\u5ea6\u95ee\u9898\uff08\u5c24\u5176\u662f\u5b89\u5168\u6027\u548c\u9c81\u68d2\u6027\uff09\u65e5\u76ca\u7a81\u51fa\uff0c\u9700\u8981\u7cfb\u7edf\u5316\u7684\u8bc4\u4f30\u65b9\u6cd5\u3002", "method": "\u96c6\u6210AutoDAN\u7b49\u6270\u52a8\u65b9\u6cd5\uff0c\u91c7\u7528\u591a\u6570\u6295\u7968\u673a\u5236\uff0c\u901a\u8fc7\u4ea4\u4e92\u5f0f\u7528\u6237\u754c\u9762\u63d0\u4f9b\u76f4\u89c2\u7684\u53ef\u89c6\u5316\u8bc4\u4f30\u6307\u6807\u3002", "result": "\u5728Vicuna-7b\u3001Llama2-7b\u548cGPT-3.5\u7b49\u6a21\u578b\u4e0a\u7684\u521d\u6b65\u6848\u4f8b\u7814\u7a76\u8868\u660e\uff0c\u8be5\u6846\u67b6\u80fd\u6709\u6548\u8bc6\u522b\u5b89\u5168\u6027\u548c\u9c81\u68d2\u6027\u6f0f\u6d1e\u3002", "conclusion": "TRUSTVIS\u4e0d\u4ec5\u63d0\u4f9b\u53ef\u9760\u7684\u8bc4\u4f30\u7ed3\u679c\uff0c\u8fd8\u4f7f\u590d\u6742\u7684\u8bc4\u4f30\u8fc7\u7a0b\u5bf9\u7528\u6237\u66f4\u52a0\u53cb\u597d\uff0c\u6709\u52a9\u4e8e\u9488\u5bf9\u6027\u7684\u6a21\u578b\u6539\u8fdb\u3002"}}
{"id": "2510.13236", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2510.13236", "abs": "https://arxiv.org/abs/2510.13236", "authors": ["Sebastian mateos Nicolajsen"], "title": "Extensibility in Programming Languages: An overview", "comment": null, "summary": "I here conduct an exploration of programming language extensibility, making\nan argument for an often overlooked component of conventional language design.\nNow, this is not a technical detailing of these components, rather, I attempt\nto provide an overview as I myself have lacked during my time investigating\nprogramming languages. Thus, read this as an introduction to the magical world\nof extensibility. Through a literature review, I identify key extensibility\nthemes - Macros, Modules, Types, and Reflection - highlighting diverse\nstrategies for fostering extensibility. The analysis extends to cross-theme\nproperties such as Parametricism and First-class citizen behaviour, introducing\nlayers of complexity by highlighting the importance of customizability and\nflexibility in programming language constructs. By outlining these facets of\nexisting programming languages and research, I aim to inspire future language\ndesigners to assess and consider the extensibility of their creations\ncritically.", "AI": {"tldr": "\u672c\u6587\u63a2\u8ba8\u7f16\u7a0b\u8bed\u8a00\u53ef\u6269\u5c55\u6027\uff0c\u901a\u8fc7\u6587\u732e\u7efc\u8ff0\u8bc6\u522b\u5b8f\u3001\u6a21\u5757\u3001\u7c7b\u578b\u548c\u53cd\u5c04\u7b49\u5173\u952e\u4e3b\u9898\uff0c\u5206\u6790\u53c2\u6570\u5316\u548c\u4e00\u7b49\u516c\u6c11\u884c\u4e3a\u7b49\u8de8\u4e3b\u9898\u7279\u6027\uff0c\u65e8\u5728\u542f\u53d1\u672a\u6765\u8bed\u8a00\u8bbe\u8ba1\u8005\u91cd\u89c6\u53ef\u6269\u5c55\u6027\u3002", "motivation": "\u4f5c\u8005\u5728\u8c03\u67e5\u7f16\u7a0b\u8bed\u8a00\u65f6\u7f3a\u4e4f\u5bf9\u53ef\u6269\u5c55\u6027\u7ec4\u4ef6\u7684\u5168\u9762\u6982\u8ff0\uff0c\u56e0\u6b64\u5e0c\u671b\u4e3a\u8bfb\u8005\u63d0\u4f9b\u8fd9\u4e00\u88ab\u5ffd\u89c6\u4f46\u91cd\u8981\u7684\u8bed\u8a00\u8bbe\u8ba1\u65b9\u9762\u7684\u4ecb\u7ecd\u3002", "method": "\u901a\u8fc7\u6587\u732e\u7efc\u8ff0\u65b9\u6cd5\uff0c\u8bc6\u522b\u548c\u5206\u6790\u7f16\u7a0b\u8bed\u8a00\u53ef\u6269\u5c55\u6027\u7684\u5173\u952e\u4e3b\u9898\u548c\u8de8\u4e3b\u9898\u7279\u6027\u3002", "result": "\u8bc6\u522b\u51fa\u5b8f\u3001\u6a21\u5757\u3001\u7c7b\u578b\u548c\u53cd\u5c04\u56db\u4e2a\u5173\u952e\u53ef\u6269\u5c55\u6027\u4e3b\u9898\uff0c\u5e76\u5206\u6790\u4e86\u53c2\u6570\u5316\u548c\u4e00\u7b49\u516c\u6c11\u884c\u4e3a\u7b49\u8de8\u4e3b\u9898\u7279\u6027\uff0c\u5f3a\u8c03\u4e86\u7f16\u7a0b\u8bed\u8a00\u6784\u9020\u4e2d\u53ef\u5b9a\u5236\u6027\u548c\u7075\u6d3b\u6027\u7684\u91cd\u8981\u6027\u3002", "conclusion": "\u672c\u6587\u65e8\u5728\u542f\u53d1\u672a\u6765\u7f16\u7a0b\u8bed\u8a00\u8bbe\u8ba1\u8005\u6279\u5224\u6027\u5730\u8bc4\u4f30\u548c\u8003\u8651\u5176\u8bbe\u8ba1\u7684\u53ef\u6269\u5c55\u6027\uff0c\u8ba4\u8bc6\u5230\u53ef\u5b9a\u5236\u6027\u548c\u7075\u6d3b\u6027\u5728\u8bed\u8a00\u6784\u9020\u4e2d\u7684\u91cd\u8981\u6027\u3002"}}
{"id": "2510.13413", "categories": ["cs.LO", "cs.DC", "D.2.4; D.1.3"], "pdf": "https://arxiv.org/pdf/2510.13413", "abs": "https://arxiv.org/abs/2510.13413", "authors": ["Paul D. Hovland"], "title": "VSS Challenge Problem: Verifying the Correctness of AllReduce Algorithms in the MPICH Implementation of MPI", "comment": "In Proceedings VSS 2025, arXiv:2510.12314", "summary": "We describe a challenge problem for verification based on the MPICH\nimplementation of MPI. The MPICH implementation includes several algorithms for\nallreduce, all of which should be functionally equivalent to reduce followed by\nbroadcast. We created standalone versions of three algorithms and verified two\nof them using CIVL.", "AI": {"tldr": "\u57fa\u4e8eMPICH\u5b9e\u73b0\u7684MPI\u9a8c\u8bc1\u6311\u6218\u95ee\u9898\uff0c\u9a8c\u8bc1\u4e09\u79cdallreduce\u7b97\u6cd5\u7684\u529f\u80fd\u7b49\u6548\u6027", "motivation": "MPICH\u5b9e\u73b0\u5305\u542b\u591a\u79cdallreduce\u7b97\u6cd5\uff0c\u9700\u8981\u9a8c\u8bc1\u5b83\u4eec\u4e0ereduce+broadcast\u7684\u529f\u80fd\u7b49\u6548\u6027", "method": "\u521b\u5efa\u4e09\u79cd\u7b97\u6cd5\u7684\u72ec\u7acb\u7248\u672c\uff0c\u4f7f\u7528CIVL\u5de5\u5177\u9a8c\u8bc1\u5176\u4e2d\u4e24\u79cd", "result": "\u6210\u529f\u9a8c\u8bc1\u4e86\u4e09\u79cd\u7b97\u6cd5\u4e2d\u7684\u4e24\u79cd", "conclusion": "\u9a8c\u8bc1\u4e86MPICH\u4e2d\u90e8\u5206allreduce\u7b97\u6cd5\u7684\u529f\u80fd\u6b63\u786e\u6027"}}
{"id": "2510.13128", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.13128", "abs": "https://arxiv.org/abs/2510.13128", "authors": ["Yujie Liu", "Mingxuan Zhu", "Shengyu Cheng", "Dan Hao"], "title": "Isolating Compiler Bugs through Compilation Steps Analysis", "comment": null, "summary": "Compilers are essential to software systems, and their bugs can propagate to\ndependent software. Ensuring compiler correctness is critical. However,\nisolating compiler bugs remains challenging due to the internal complexity of\ncompiler execution. Existing techniques primarily mutate compilation inputs to\ngenerate passing and failing tests, but often lack causal analysis of internal\nsteps, limiting their effectiveness.\n  To address this limitation, we propose CompSCAN, a novel compiler bug\nisolation technique that applies analysis over the sequence of compilation\nsteps. CompSCAN follows a three-stage process: (1) extracting the array of\ncompilation steps that leads to the original failure, (2) identifying\nbug-causing steps and collecting corresponding compiler code elements, and (3)\ncalculating suspicious scores for each code element and outputting a suspicious\nranking list as the bug isolation result.\n  We evaluate CompSCAN on 185 real-world LLVM and GCC bugs. Results show that\nCompSCAN outperforms state-of-the-art techniques in both effectiveness and\nefficiency. CompSCAN successfully isolates 50, 85, 100, and 123 bugs within the\nTop-1/3/5/10 ranks, respectively. Compared with ETEM and ODFL, two\nstate-of-the-art compiler bug isolation techniques, CompSCAN achieves relative\nimprovements of 44.51% / 50.18% / 36.24% / 24.49% over ETEM, and 31.58% /\n49.12% / 44.93% / 21.78% over ODFL on those metrics. Moreover, CompSCAN runs\nfaster on average per bug than both baselines.", "AI": {"tldr": "CompSCAN\u662f\u4e00\u79cd\u65b0\u9896\u7684\u7f16\u8bd1\u5668bug\u9694\u79bb\u6280\u672f\uff0c\u901a\u8fc7\u5206\u6790\u7f16\u8bd1\u6b65\u9aa4\u5e8f\u5217\u6765\u8bc6\u522b\u5bfc\u81f4bug\u7684\u7f16\u8bd1\u6b65\u9aa4\u548c\u4ee3\u7801\u5143\u7d20\uff0c\u5728\u771f\u5b9eLLVM\u548cGCC bug\u4e0a\u8868\u73b0\u51fa\u4f18\u4e8e\u73b0\u6709\u6280\u672f\u7684\u6548\u679c\u548c\u6548\u7387\u3002", "motivation": "\u7f16\u8bd1\u5668\u5bf9\u8f6f\u4ef6\u7cfb\u7edf\u81f3\u5173\u91cd\u8981\uff0c\u4f46\u5176bug\u4f1a\u4f20\u64ad\u5230\u4f9d\u8d56\u8f6f\u4ef6\u4e2d\u3002\u73b0\u6709\u6280\u672f\u4e3b\u8981\u901a\u8fc7\u53d8\u5f02\u7f16\u8bd1\u8f93\u5165\u751f\u6210\u6d4b\u8bd5\u7528\u4f8b\uff0c\u4f46\u7f3a\u4e4f\u5bf9\u5185\u90e8\u6b65\u9aa4\u7684\u56e0\u679c\u5206\u6790\uff0c\u9650\u5236\u4e86\u6709\u6548\u6027\u3002", "method": "CompSCAN\u91c7\u7528\u4e09\u9636\u6bb5\u8fc7\u7a0b\uff1a(1)\u63d0\u53d6\u5bfc\u81f4\u539f\u59cb\u5931\u8d25\u7684\u7f16\u8bd1\u6b65\u9aa4\u5e8f\u5217\uff0c(2)\u8bc6\u522bbug\u5bfc\u81f4\u6b65\u9aa4\u5e76\u6536\u96c6\u5bf9\u5e94\u7684\u7f16\u8bd1\u5668\u4ee3\u7801\u5143\u7d20\uff0c(3)\u8ba1\u7b97\u6bcf\u4e2a\u4ee3\u7801\u5143\u7d20\u7684\u53ef\u7591\u5206\u6570\u5e76\u8f93\u51fa\u53ef\u7591\u6392\u540d\u5217\u8868\u3002", "result": "\u5728185\u4e2a\u771f\u5b9eLLVM\u548cGCC bug\u4e0a\u8bc4\u4f30\uff0cCompSCAN\u5728Top-1/3/5/10\u6392\u540d\u4e2d\u5206\u522b\u6210\u529f\u9694\u79bb50\u300185\u3001100\u548c123\u4e2abug\uff0c\u76f8\u6bd4ETEM\u548cODFL\u5206\u522b\u670944.51%/50.18%/36.24%/24.49%\u548c31.58%/49.12%/44.93%/21.78%\u7684\u76f8\u5bf9\u6539\u8fdb\uff0c\u4e14\u8fd0\u884c\u901f\u5ea6\u66f4\u5feb\u3002", "conclusion": "CompSCAN\u901a\u8fc7\u5206\u6790\u7f16\u8bd1\u6b65\u9aa4\u5e8f\u5217\u6709\u6548\u63d0\u5347\u4e86\u7f16\u8bd1\u5668bug\u9694\u79bb\u7684\u6548\u679c\u548c\u6548\u7387\uff0c\u4f18\u4e8e\u73b0\u6709\u6700\u5148\u8fdb\u6280\u672f\u3002"}}
{"id": "2510.13426", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2510.13426", "abs": "https://arxiv.org/abs/2510.13426", "authors": ["Sehyeok Park", "Santosh Nagarakatte"], "title": "Fast Trigonometric Functions using the RLIBM Approach", "comment": "In Proceedings VSS 2025, arXiv:2510.12314", "summary": "This paper describes our experience developing polynomial approximations for\ntrigonometric functions that produce correctly rounded results for multiple\nrepresentations and rounding modes using the RLIBM approach. A key challenge\nwith trigonometric functions concerns range reduction with \"pi\", which reduces\na given input in the domain of a 32-bit float to a small domain. Any rounding\nerror in the value of \"pi\" is amplified during range reduction, which can\nresult in wrong results. We describe our experience implementing fast range\nreduction techniques that maintain a large number of bits of \"pi\" both with\nfloating-point and integer computations. The resulting implementations for\ntrigonometric functions are fast and produce correctly rounded results for all\ninputs for multiple representations up to 32-bits with a single implementation.", "AI": {"tldr": "\u5f00\u53d1\u4e09\u89d2\u51fd\u6570\u7684\u591a\u9879\u5f0f\u8fd1\u4f3c\u65b9\u6cd5\uff0c\u4f7f\u7528RLIBM\u65b9\u6cd5\u4e3a\u591a\u79cd\u8868\u793a\u5f62\u5f0f\u548c\u820d\u5165\u6a21\u5f0f\u751f\u6210\u6b63\u786e\u820d\u5165\u7684\u7ed3\u679c\uff0c\u91cd\u70b9\u89e3\u51b3\u57fa\u4e8e\u03c0\u7684\u8303\u56f4\u7f29\u51cf\u95ee\u9898\u3002", "motivation": "\u4e09\u89d2\u51fd\u6570\u8303\u56f4\u7f29\u51cf\u8fc7\u7a0b\u4e2d\u03c0\u503c\u7684\u820d\u5165\u8bef\u5dee\u4f1a\u88ab\u653e\u5927\uff0c\u5bfc\u81f4\u9519\u8bef\u7ed3\u679c\uff0c\u9700\u8981\u5f00\u53d1\u80fd\u591f\u4fdd\u6301\u03c0\u503c\u9ad8\u7cbe\u5ea6\u7684\u5feb\u901f\u8303\u56f4\u7f29\u51cf\u6280\u672f\u3002", "method": "\u4f7f\u7528RLIBM\u65b9\u6cd5\u5b9e\u73b0\u591a\u9879\u5f0f\u8fd1\u4f3c\uff0c\u5f00\u53d1\u6d6e\u70b9\u548c\u6574\u6570\u8ba1\u7b97\u4e2d\u4fdd\u6301\u03c0\u503c\u591a\u4f4d\u7cbe\u5ea6\u7684\u5feb\u901f\u8303\u56f4\u7f29\u51cf\u6280\u672f\u3002", "result": "\u5b9e\u73b0\u4e86\u5feb\u901f\u7684\u4e09\u89d2\u51fd\u6570\u5b9e\u73b0\uff0c\u80fd\u591f\u4e3a\u6240\u670932\u4f4d\u53ca\u4ee5\u4e0b\u8f93\u5165\u7684\u591a\u79cd\u8868\u793a\u5f62\u5f0f\u751f\u6210\u6b63\u786e\u820d\u5165\u7ed3\u679c\uff0c\u4e14\u5355\u4e00\u5b9e\u73b0\u652f\u6301\u591a\u79cd\u8868\u793a\u3002", "conclusion": "\u901a\u8fc7\u4fdd\u6301\u03c0\u503c\u9ad8\u7cbe\u5ea6\u7684\u8303\u56f4\u7f29\u51cf\u6280\u672f\uff0c\u6210\u529f\u5f00\u53d1\u51fa\u5feb\u901f\u4e14\u6b63\u786e\u820d\u5165\u7684\u4e09\u89d2\u51fd\u6570\u5b9e\u73b0\uff0c\u89e3\u51b3\u4e86\u4f20\u7edf\u65b9\u6cd5\u4e2d\u7684\u7cbe\u5ea6\u95ee\u9898\u3002"}}
{"id": "2510.13425", "categories": ["cs.LO", "cs.MS"], "pdf": "https://arxiv.org/pdf/2510.13425", "abs": "https://arxiv.org/abs/2510.13425", "authors": ["Alper Altuntas", "Allison H. Baker", "John Baugh", "Ganesh Gopalakrishnan", "Stephen F. Siegel"], "title": "Specification and Verification for Climate Modeling: Formalization Leading to Impactful Tooling", "comment": "In Proceedings VSS 2025, arXiv:2510.12314", "summary": "Earth System Models (ESMs) are critical for understanding past climates and\nprojecting future scenarios. However, the complexity of these models, which\ninclude large code bases, a wide community of developers, and diverse\ncomputational platforms, poses significant challenges for software quality\nassurance. The increasing adoption of GPUs and heterogeneous architectures\nfurther complicates verification efforts. Traditional verification methods\noften rely on bitwise reproducibility, which is not always feasible,\nparticularly under new compilers or hardware. Manual expert evaluation, on the\nother hand, is subjective and time-consuming. Formal methods offer a\nmathematically rigorous alternative, yet their application in ESM development\nhas been limited due to the lack of climate model-specific representations and\ntools. Here, we advocate for the broader adoption of formal methods in climate\nmodeling. In particular, we identify key aspects of ESMs that are well suited\nto formal specification and introduce abstraction approaches for a tailored\nframework. To demonstrate this approach, we present a case study using CIVL\nmodel checker to formally verify a bug fix in an ocean mixing parameterization\nscheme. Our goal is to develop accessible, domain-specific formal tools that\nenhance model confidence and support more efficient and reliable ESM\ndevelopment.", "AI": {"tldr": "\u672c\u6587\u4e3b\u5f20\u5728\u5730\u7403\u7cfb\u7edf\u6a21\u578b(ESM)\u5f00\u53d1\u4e2d\u66f4\u5e7f\u6cdb\u91c7\u7528\u5f62\u5f0f\u5316\u65b9\u6cd5\uff0c\u4ee5\u89e3\u51b3\u4f20\u7edf\u9a8c\u8bc1\u65b9\u6cd5\u7684\u5c40\u9650\u6027\uff0c\u5e76\u901a\u8fc7\u6848\u4f8b\u7814\u7a76\u5c55\u793a\u4e86\u4f7f\u7528CIVL\u6a21\u578b\u68c0\u67e5\u5668\u9a8c\u8bc1\u6d77\u6d0b\u6df7\u5408\u53c2\u6570\u5316\u65b9\u6848\u4e2dbug\u4fee\u590d\u7684\u6709\u6548\u6027\u3002", "motivation": "\u5730\u7403\u7cfb\u7edf\u6a21\u578b\u7684\u590d\u6742\u6027\uff08\u5927\u578b\u4ee3\u7801\u5e93\u3001\u591a\u6837\u5316\u5f00\u53d1\u793e\u533a\u548c\u8ba1\u7b97\u5e73\u53f0\uff09\u7ed9\u8f6f\u4ef6\u8d28\u91cf\u4fdd\u8bc1\u5e26\u6765\u91cd\u5927\u6311\u6218\u3002\u4f20\u7edf\u9a8c\u8bc1\u65b9\u6cd5\u5982\u6bd4\u7279\u7ea7\u53ef\u91cd\u73b0\u6027\u4e0d\u603b\u662f\u53ef\u884c\uff0c\u800c\u4eba\u5de5\u4e13\u5bb6\u8bc4\u4f30\u4e3b\u89c2\u4e14\u8017\u65f6\u3002\u5f62\u5f0f\u5316\u65b9\u6cd5\u63d0\u4f9b\u4e86\u6570\u5b66\u4e25\u8c28\u7684\u66ff\u4ee3\u65b9\u6848\u3002", "method": "\u8bc6\u522b\u9002\u5408\u5f62\u5f0f\u5316\u89c4\u8303\u7684ESM\u5173\u952e\u65b9\u9762\uff0c\u5f15\u5165\u5b9a\u5236\u5316\u6846\u67b6\u7684\u62bd\u8c61\u65b9\u6cd5\uff0c\u4f7f\u7528CIVL\u6a21\u578b\u68c0\u67e5\u5668\u5bf9\u6d77\u6d0b\u6df7\u5408\u53c2\u6570\u5316\u65b9\u6848\u4e2d\u7684bug\u4fee\u590d\u8fdb\u884c\u5f62\u5f0f\u5316\u9a8c\u8bc1\u3002", "result": "\u6210\u529f\u6f14\u793a\u4e86\u5f62\u5f0f\u5316\u65b9\u6cd5\u5728\u6c14\u5019\u5efa\u6a21\u4e2d\u7684\u5e94\u7528\uff0c\u901a\u8fc7\u6848\u4f8b\u7814\u7a76\u9a8c\u8bc1\u4e86\u6d77\u6d0b\u6df7\u5408\u53c2\u6570\u5316\u65b9\u6848\u4e2dbug\u4fee\u590d\u7684\u6b63\u786e\u6027\u3002", "conclusion": "\u5f00\u53d1\u53ef\u8bbf\u95ee\u7684\u3001\u9886\u57df\u7279\u5b9a\u7684\u5f62\u5f0f\u5316\u5de5\u5177\u80fd\u591f\u589e\u5f3a\u6a21\u578b\u7f6e\u4fe1\u5ea6\uff0c\u652f\u6301\u66f4\u9ad8\u6548\u53ef\u9760\u7684\u5730\u7403\u7cfb\u7edf\u6a21\u578b\u5f00\u53d1\u3002"}}
{"id": "2510.13176", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.13176", "abs": "https://arxiv.org/abs/2510.13176", "authors": ["Haolin Pan", "Chao Zha", "Jinyuan Dong", "Mingjie Xing", "Yanjun Wu"], "title": "GRACE: Globally-Seeded Representation-Aware Cluster-Specific Evolution for Compiler Auto-Tuning", "comment": null, "summary": "Compiler pass selection and phase ordering present a significant challenge in\nachieving optimal program performance, particularly for objectives like code\nsize reduction. Standard compiler heuristics offer general applicability but\noften yield suboptimal, program-specific results due to their one-size-fits-all\nnature. While iterative compilation can find tailored solutions, its\nprohibitive search cost limits practical use. Machine learning approaches\npromise faster inference but frequently struggle with generalization to unseen\nprograms. This paper introduces GRACE, a novel framework for compiler\nauto-tuning, demonstrated for LLVM IR instruction count optimization. GRACE\neffectively curtails the search space by leveraging pass synergies and a\nweighted scoring method to generate initial high-quality candidate sequences\nand a pass pool. It then employs contrastive learning, using pass\nsequence-based data augmentation, to create program embeddings that facilitate\nsimilarity-aware clustering. Evolutionary search within these clusters yields a\ncoreset of $k$ specialized pass sequences designed for robust generalization to\nunseen programs. At test time, GRACE efficiently selects the best coreset\nsequence and refines it using lightweight techniques. Experimental results on\nseven diverse datasets show that GRACE reduces LLVM IR instruction count by an\naverage of 10.09% on LLVM 10.0.0 and 10.19% on LLVM 18.1.6 compared to opt -Oz,\nwhile incurring an average tuning time of less than 1s per program,\ndemonstrating its state-of-the-art performance and practical effectiveness.", "AI": {"tldr": "GRACE\u662f\u4e00\u4e2a\u7f16\u8bd1\u5668\u81ea\u52a8\u8c03\u4f18\u6846\u67b6\uff0c\u901a\u8fc7\u5229\u7528pass\u534f\u540c\u6548\u5e94\u548c\u5bf9\u6bd4\u5b66\u4e60\u6765\u51cf\u5c11\u641c\u7d22\u7a7a\u95f4\uff0c\u5728LLVM IR\u6307\u4ee4\u6570\u4f18\u5316\u4e0a\u5b9e\u73b0\u4e86\u663e\u8457\u7684\u6027\u80fd\u63d0\u5347\uff0c\u5e73\u5747\u51cf\u5c1110%\u4ee5\u4e0a\u7684\u6307\u4ee4\u6570\uff0c\u540c\u65f6\u4fdd\u6301\u6bcf\u7a0b\u5e8f\u5c11\u4e8e1\u79d2\u7684\u8c03\u4f18\u65f6\u95f4\u3002", "motivation": "\u7f16\u8bd1\u5668pass\u9009\u62e9\u548c\u9636\u6bb5\u6392\u5e8f\u5bf9\u7a0b\u5e8f\u6027\u80fd\u4f18\u5316\u81f3\u5173\u91cd\u8981\uff0c\u4f46\u4f20\u7edf\u542f\u53d1\u5f0f\u65b9\u6cd5\u6548\u679c\u4e0d\u4f73\uff0c\u8fed\u4ee3\u7f16\u8bd1\u641c\u7d22\u6210\u672c\u8fc7\u9ad8\uff0c\u673a\u5668\u5b66\u4e60\u65b9\u6cd5\u6cdb\u5316\u80fd\u529b\u6709\u9650\uff0c\u9700\u8981\u4e00\u79cd\u65e2\u9ad8\u6548\u53c8\u80fd\u826f\u597d\u6cdb\u5316\u7684\u81ea\u52a8\u8c03\u4f18\u65b9\u6cd5\u3002", "method": "GRACE\u6846\u67b6\u901a\u8fc7pass\u534f\u540c\u6548\u5e94\u548c\u52a0\u6743\u8bc4\u5206\u751f\u6210\u9ad8\u8d28\u91cf\u5019\u9009\u5e8f\u5217\u548cpass\u6c60\uff0c\u4f7f\u7528\u5bf9\u6bd4\u5b66\u4e60\u548c\u57fa\u4e8epass\u5e8f\u5217\u7684\u6570\u636e\u589e\u5f3a\u521b\u5efa\u7a0b\u5e8f\u5d4c\u5165\uff0c\u8fdb\u884c\u76f8\u4f3c\u6027\u611f\u77e5\u805a\u7c7b\uff0c\u5728\u805a\u7c7b\u5185\u4f7f\u7528\u8fdb\u5316\u641c\u7d22\u751f\u6210\u6838\u5fc3\u96c6\uff0c\u6700\u540e\u901a\u8fc7\u8f7b\u91cf\u7ea7\u6280\u672f\u9009\u62e9\u548c\u4f18\u5316\u6700\u4f73\u5e8f\u5217\u3002", "result": "\u57287\u4e2a\u4e0d\u540c\u6570\u636e\u96c6\u4e0a\u7684\u5b9e\u9a8c\u8868\u660e\uff0cGRACE\u76f8\u6bd4opt -Oz\u5e73\u5747\u51cf\u5c11LLVM IR\u6307\u4ee4\u657010.09%(LLVM 10.0.0)\u548c10.19%(LLVM 18.1.6)\uff0c\u5e73\u5747\u8c03\u4f18\u65f6\u95f4\u6bcf\u7a0b\u5e8f\u5c11\u4e8e1\u79d2\u3002", "conclusion": "GRACE\u5728\u7f16\u8bd1\u5668\u81ea\u52a8\u8c03\u4f18\u65b9\u9762\u5b9e\u73b0\u4e86\u6700\u5148\u8fdb\u7684\u6027\u80fd\uff0c\u901a\u8fc7\u6709\u6548\u7684\u641c\u7d22\u7a7a\u95f4\u7f29\u51cf\u548c\u76f8\u4f3c\u6027\u611f\u77e5\u65b9\u6cd5\uff0c\u5728\u4fdd\u6301\u9ad8\u6548\u8c03\u4f18\u7684\u540c\u65f6\u5b9e\u73b0\u4e86\u5bf9\u672a\u89c1\u7a0b\u5e8f\u7684\u826f\u597d\u6cdb\u5316\u80fd\u529b\u3002"}}
{"id": "2510.13725", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2510.13725", "abs": "https://arxiv.org/abs/2510.13725", "authors": ["Celia Mengyue Li", "Sophie Pull", "Steven Ramsay"], "title": "A Complementary Approach to Incorrectness Typing", "comment": "Version conditionally accepted to POPL'26, with reviewer suggestions\n  incorporated", "summary": "We introduce a new two-sided type system for verifying the correctness and\nincorrectness of functional programs with atoms and pattern matching. A key\nidea in the work is that types should range over sets of normal forms, rather\nthan sets of values, and this allows us to define a complement operator on\ntypes that acts as a negation on typing formulas. We show that the complement\nallows us to derive a wide range of refutation principles within the system,\nincluding the type-theoretic analogue of co-implication, and we use them to\ncertify that a number of Erlang-like programs go wrong. An expressive\naxiomatisation of the complement operator via subtyping is shown decidable, and\nthe type system as a whole is shown to be not only sound, but also complete for\nnormal forms.", "AI": {"tldr": "\u63d0\u51fa\u4e86\u4e00\u79cd\u65b0\u7684\u53cc\u9762\u7c7b\u578b\u7cfb\u7edf\uff0c\u7528\u4e8e\u9a8c\u8bc1\u5e26\u6709\u539f\u5b50\u548c\u6a21\u5f0f\u5339\u914d\u7684\u51fd\u6570\u5f0f\u7a0b\u5e8f\u7684\u6b63\u786e\u6027\u548c\u9519\u8bef\u6027\u3002\u6838\u5fc3\u601d\u60f3\u662f\u7c7b\u578b\u5e94\u8be5\u8986\u76d6\u8303\u5f0f\u96c6\u5408\u800c\u975e\u503c\u96c6\u5408\uff0c\u8fd9\u5141\u8bb8\u5b9a\u4e49\u7c7b\u578b\u4e0a\u7684\u8865\u96c6\u8fd0\u7b97\u7b26\u4f5c\u4e3a\u7c7b\u578b\u516c\u5f0f\u7684\u5426\u5b9a\u3002", "motivation": "\u9700\u8981\u9a8c\u8bc1\u51fd\u6570\u5f0f\u7a0b\u5e8f\u7684\u6b63\u786e\u6027\u548c\u9519\u8bef\u6027\uff0c\u7279\u522b\u662f\u9488\u5bf9Erlang\u7c7b\u7a0b\u5e8f\u4e2d\u7684\u9519\u8bef\u60c5\u51b5\u3002\u4f20\u7edf\u7c7b\u578b\u7cfb\u7edf\u96be\u4ee5\u540c\u65f6\u5904\u7406\u6b63\u786e\u6027\u9a8c\u8bc1\u548c\u9519\u8bef\u6027\u8bc1\u660e\u3002", "method": "\u4f7f\u7528\u57fa\u4e8e\u8303\u5f0f\u96c6\u5408\u800c\u975e\u503c\u96c6\u5408\u7684\u7c7b\u578b\u7cfb\u7edf\uff0c\u5f15\u5165\u8865\u96c6\u8fd0\u7b97\u7b26\u4f5c\u4e3a\u7c7b\u578b\u5426\u5b9a\uff0c\u901a\u8fc7\u5b50\u7c7b\u578b\u5316\u7684\u8868\u8fbe\u6027\u516c\u7406\u5316\u6765\u5b9e\u73b0\u3002", "result": "\u8865\u96c6\u8fd0\u7b97\u7b26\u80fd\u591f\u63a8\u5bfc\u51fa\u5e7f\u6cdb\u7684\u5426\u5b9a\u539f\u5219\uff0c\u5305\u62ec\u7c7b\u578b\u7406\u8bba\u4e2d\u7684\u5171\u8574\u542b\u7c7b\u4f3c\u7269\u3002\u7cfb\u7edf\u88ab\u8bc1\u660e\u662f\u53ef\u5224\u5b9a\u7684\uff0c\u5e76\u4e14\u5bf9\u4e8e\u8303\u5f0f\u662f\u5b8c\u5907\u7684\u3002", "conclusion": "\u8be5\u7c7b\u578b\u7cfb\u7edf\u4e0d\u4ec5\u80fd\u9a8c\u8bc1\u7a0b\u5e8f\u6b63\u786e\u6027\uff0c\u8fd8\u80fd\u8bc1\u660e\u7a0b\u5e8f\u9519\u8bef\u6027\uff0c\u4e3a\u51fd\u6570\u5f0f\u7a0b\u5e8f\u7684\u5168\u9762\u9a8c\u8bc1\u63d0\u4f9b\u4e86\u6709\u6548\u5de5\u5177\u3002"}}
{"id": "2510.13427", "categories": ["cs.LO", "cs.DC", "cs.MS"], "pdf": "https://arxiv.org/pdf/2510.13427", "abs": "https://arxiv.org/abs/2510.13427", "authors": ["Junchao Zhang"], "title": "Verification Challenges in Sparse Matrix Vector Multiplication in High Performance Computing: Part I", "comment": "In Proceedings VSS 2025, arXiv:2510.12314", "summary": "Sparse matrix vector multiplication (SpMV) is a fundamental kernel in\nscientific codes that rely on iterative solvers. In this first part of our\nwork, we present both a sequential and a basic MPI parallel implementations of\nSpMV, aiming to provide a challenge problem for the scientific software\nverification community. The implementations are described in the context of the\nPETSc library.", "AI": {"tldr": "\u672c\u6587\u4ecb\u7ecd\u4e86\u7a00\u758f\u77e9\u9635\u5411\u91cf\u4e58\u6cd5(SpMV)\u7684\u987a\u5e8f\u548c\u57fa\u672cMPI\u5e76\u884c\u5b9e\u73b0\uff0c\u4f5c\u4e3a\u79d1\u5b66\u8f6f\u4ef6\u9a8c\u8bc1\u793e\u533a\u7684\u6311\u6218\u95ee\u9898", "motivation": "SpMV\u662f\u4f9d\u8d56\u8fed\u4ee3\u6c42\u89e3\u5668\u7684\u79d1\u5b66\u4ee3\u7801\u4e2d\u7684\u57fa\u672c\u5185\u6838\uff0c\u65e8\u5728\u4e3a\u79d1\u5b66\u8f6f\u4ef6\u9a8c\u8bc1\u793e\u533a\u63d0\u4f9b\u6311\u6218\u95ee\u9898", "method": "\u5728PETSc\u5e93\u80cc\u666f\u4e0b\u5b9e\u73b0\u4e86\u987a\u5e8f\u548c\u57fa\u672cMPI\u5e76\u884c\u7684SpMV\u5b9e\u73b0", "result": "\u63d0\u4f9b\u4e86\u53ef\u7528\u7684SpMV\u5b9e\u73b0\u4f5c\u4e3a\u9a8c\u8bc1\u57fa\u51c6", "conclusion": "\u8fd9\u4e9b\u5b9e\u73b0\u53ef\u4f5c\u4e3a\u79d1\u5b66\u8f6f\u4ef6\u9a8c\u8bc1\u793e\u533a\u7684\u6311\u6218\u95ee\u9898"}}
{"id": "2510.13184", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.13184", "abs": "https://arxiv.org/abs/2510.13184", "authors": ["Haolin Pan", "Jinyuan Dong", "Mingjie Xing", "Yanjun Wu"], "title": "Synergy-Guided Compiler Auto-Tuning of Nested LLVM Pass Pipelines", "comment": null, "summary": "Compiler optimization relies on sequences of passes to improve program\nperformance. Selecting and ordering these passes automatically, known as\ncompiler auto-tuning, is challenging due to the large and complex search space.\nExisting approaches generally assume a linear sequence of passes, a model\ncompatible with legacy compilers but fundamentally misaligned with the\nhierarchical design of the LLVM New Pass Manager. This misalignment prevents\nthem from guaranteeing the generation of syntactically valid optimization\npipelines. In this work, we present a new auto-tuning framework built from the\nground up for the New Pass Manager. We introduce a formal grammar to define the\nspace of valid nested pipelines and a forest-based data structure for their\nnative representation. Upon this foundation, we develop a structure-aware\nGenetic Algorithm whose operators manipulate these forests directly, ensuring\nthat all candidate solutions are valid by construction. The framework first\nmines synergistic pass relationships to guide the search. An optional\nrefinement stage further explores subtle performance variations arising from\ndifferent valid structural arrangements.\n  We evaluate our approach on seven benchmark datasets using LLVM 18.1.6. The\ndiscovered pipelines achieve an average of 13.62% additional instruction count\nreduction compared to the standard opt -Oz optimization level, showing that our\nframework is capable of navigating this complex, constrained search space to\nidentify valid and effective pass pipelines.", "AI": {"tldr": "\u63d0\u51fa\u4e86\u4e00\u4e2a\u4e13\u4e3aLLVM\u65b0Pass\u7ba1\u7406\u5668\u8bbe\u8ba1\u7684\u7f16\u8bd1\u5668\u81ea\u52a8\u8c03\u4f18\u6846\u67b6\uff0c\u4f7f\u7528\u5f62\u5f0f\u5316\u8bed\u6cd5\u5b9a\u4e49\u6709\u6548\u5d4c\u5957\u7ba1\u9053\u7a7a\u95f4\uff0c\u901a\u8fc7\u57fa\u4e8e\u68ee\u6797\u7684\u6570\u636e\u7ed3\u6784\u548c\u7ed3\u6784\u611f\u77e5\u9057\u4f20\u7b97\u6cd5\u786e\u4fdd\u751f\u6210\u8bed\u6cd5\u6709\u6548\u7684\u4f18\u5316\u7ba1\u9053\u3002", "motivation": "\u73b0\u6709\u7f16\u8bd1\u5668\u81ea\u52a8\u8c03\u4f18\u65b9\u6cd5\u5047\u8bbe\u7ebf\u6027pass\u5e8f\u5217\uff0c\u8fd9\u4e0eLLVM\u65b0Pass\u7ba1\u7406\u5668\u7684\u5206\u5c42\u8bbe\u8ba1\u4e0d\u5339\u914d\uff0c\u65e0\u6cd5\u4fdd\u8bc1\u751f\u6210\u8bed\u6cd5\u6709\u6548\u7684\u4f18\u5316\u7ba1\u9053\u3002", "method": "\u4f7f\u7528\u5f62\u5f0f\u5316\u8bed\u6cd5\u5b9a\u4e49\u6709\u6548\u5d4c\u5957\u7ba1\u9053\u7a7a\u95f4\uff0c\u5f00\u53d1\u57fa\u4e8e\u68ee\u6797\u7684\u6570\u636e\u7ed3\u6784\u8868\u793a\u7ba1\u9053\uff0c\u6784\u5efa\u7ed3\u6784\u611f\u77e5\u9057\u4f20\u7b97\u6cd5\u76f4\u63a5\u64cd\u4f5c\u8fd9\u4e9b\u68ee\u6797\u7ed3\u6784\uff0c\u786e\u4fdd\u6240\u6709\u5019\u9009\u89e3\u5728\u6784\u9020\u65f6\u5c31\u662f\u6709\u6548\u7684\u3002", "result": "\u5728LLVM 18.1.6\u4e0a\u8bc4\u4f307\u4e2a\u57fa\u51c6\u6570\u636e\u96c6\uff0c\u53d1\u73b0\u7684\u7ba1\u9053\u76f8\u6bd4\u6807\u51c6opt -Oz\u4f18\u5316\u7ea7\u522b\u5e73\u5747\u989d\u5916\u51cf\u5c1113.62%\u7684\u6307\u4ee4\u8ba1\u6570\u3002", "conclusion": "\u8be5\u6846\u67b6\u80fd\u591f\u5728\u8fd9\u4e2a\u590d\u6742\u3001\u53d7\u9650\u7684\u641c\u7d22\u7a7a\u95f4\u4e2d\u5bfc\u822a\uff0c\u8bc6\u522b\u51fa\u6709\u6548\u4e14\u9ad8\u6548\u7684pass\u7ba1\u9053\u3002"}}
{"id": "2510.13428", "categories": ["cs.LO", "D.2.4; I.6"], "pdf": "https://arxiv.org/pdf/2510.13428", "abs": "https://arxiv.org/abs/2510.13428", "authors": ["Andrew R. Siegel"], "title": "Verification Challenge: Fractional Cascading for Multi-Nuclide Grid Lookup", "comment": "In Proceedings VSS 2025, arXiv:2510.12314", "summary": "We present a verification challenge based on the fractional cascading (FC)\ntechnique for accelerating repeated searches across a collection of sorted\narrays. The specific context is nuclear cross section lookup in a simulation\ncode, where a material consists of many nuclides, each with its own sorted\nenergy grid. A naive search performs a binary search in each array\nindividually. The FC-based cascade grid structure reduces this cost by\nperforming a single binary search followed by constant-time refinements. The\nchallenge consists of verifying the correctness of the FC algorithm with\nrespect to the naive approach and validating its structural properties.", "AI": {"tldr": "\u9a8c\u8bc1\u57fa\u4e8e\u5206\u6570\u7ea7\u8054(FC)\u6280\u672f\u7684\u91cd\u590d\u641c\u7d22\u52a0\u901f\u7b97\u6cd5\u7684\u6b63\u786e\u6027\u548c\u7ed3\u6784\u7279\u6027\uff0c\u5e94\u7528\u4e8e\u6838\u622a\u9762\u67e5\u627e\u573a\u666f", "motivation": "\u5728\u6838\u6a21\u62df\u4ee3\u7801\u4e2d\uff0c\u6750\u6599\u5305\u542b\u591a\u4e2a\u6838\u7d20\uff0c\u6bcf\u4e2a\u6838\u7d20\u90fd\u6709\u6392\u5e8f\u7684\u80fd\u91cf\u7f51\u683c\u3002\u6734\u7d20\u65b9\u6cd5\u9700\u8981\u5bf9\u6bcf\u4e2a\u6570\u7ec4\u5355\u72ec\u8fdb\u884c\u4e8c\u5206\u641c\u7d22\uff0c\u6548\u7387\u8f83\u4f4e\u3002FC\u7ea7\u8054\u7f51\u683c\u7ed3\u6784\u901a\u8fc7\u5355\u6b21\u4e8c\u5206\u641c\u7d22\u548c\u5e38\u6570\u65f6\u95f4\u7cbe\u5316\u6765\u964d\u4f4e\u641c\u7d22\u6210\u672c", "method": "\u57fa\u4e8e\u5206\u6570\u7ea7\u8054(FC)\u6280\u672f\u6784\u5efa\u7ea7\u8054\u7f51\u683c\u7ed3\u6784\uff0c\u901a\u8fc7\u5355\u6b21\u4e8c\u5206\u641c\u7d22\u548c\u540e\u7eed\u7684\u5e38\u6570\u65f6\u95f4\u7cbe\u5316\u6765\u52a0\u901f\u91cd\u590d\u641c\u7d22", "result": "\u63d0\u51fa\u4e86\u9a8c\u8bc1FC\u7b97\u6cd5\u76f8\u5bf9\u4e8e\u6734\u7d20\u65b9\u6cd5\u7684\u6b63\u786e\u6027\u53ca\u5176\u7ed3\u6784\u7279\u6027\u7684\u6311\u6218", "conclusion": "\u9700\u8981\u9a8c\u8bc1FC\u7b97\u6cd5\u5728\u6838\u622a\u9762\u67e5\u627e\u5e94\u7528\u4e2d\u7684\u6b63\u786e\u6027\u548c\u7ed3\u6784\u7279\u6027"}}
{"id": "2510.13423", "categories": ["cs.SE", "cs.MS"], "pdf": "https://arxiv.org/pdf/2510.13423", "abs": "https://arxiv.org/abs/2510.13423", "authors": ["Matthew Sottile", "Mohit Tekriwal", "John Sarracino"], "title": "Towards Richer Challenge Problems for Scientific Computing Correctness", "comment": "In Proceedings VSS 2025, arXiv:2510.12314", "summary": "Correctness in scientific computing (SC) is gaining increasing attention in\nthe formal methods (FM) and programming languages (PL) community. Existing\nPL/FM verification techniques struggle with the complexities of realistic SC\napplications. Part of the problem is a lack of a common understanding between\nthe SC and PL/FM communities of machine-verifiable correctness challenges and\ndimensions of correctness in SC applications.\n  To address this gap, we call for specialized challenge problems to inform the\ndevelopment and evaluation of FM/PL verification techniques for correctness in\nSC. These specialized challenges are intended to augment existing problems\nstudied by FM/PL researchers for general programs to ensure the needs of SC\napplications can be met. We propose several dimensions of correctness relevant\nto scientific computing, and discuss some guidelines and criteria for designing\nchallenge problems to evaluate correctness in scientific computing.", "AI": {"tldr": "\u672c\u6587\u547c\u5401\u4e3a\u79d1\u5b66\u8ba1\u7b97\u9886\u57df\u5f00\u53d1\u4e13\u95e8\u7684\u9a8c\u8bc1\u6311\u6218\u95ee\u9898\uff0c\u4ee5\u5f25\u8865\u5f62\u5f0f\u5316\u65b9\u6cd5\u4e0e\u79d1\u5b66\u8ba1\u7b97\u793e\u533a\u4e4b\u95f4\u7684\u7406\u89e3\u5dee\u8ddd\uff0c\u5e76\u63d0\u51fa\u79d1\u5b66\u8ba1\u7b97\u6b63\u786e\u6027\u7684\u591a\u4e2a\u7ef4\u5ea6\u3002", "motivation": "\u73b0\u6709\u7f16\u7a0b\u8bed\u8a00\u548c\u5f62\u5f0f\u5316\u65b9\u6cd5\u9a8c\u8bc1\u6280\u672f\u96be\u4ee5\u5e94\u5bf9\u73b0\u5b9e\u79d1\u5b66\u8ba1\u7b97\u5e94\u7528\u7684\u590d\u6742\u6027\uff0c\u79d1\u5b66\u8ba1\u7b97\u4e0e\u5f62\u5f0f\u5316\u65b9\u6cd5\u793e\u533a\u4e4b\u95f4\u7f3a\u4e4f\u5bf9\u673a\u5668\u53ef\u9a8c\u8bc1\u6b63\u786e\u6027\u6311\u6218\u7684\u5171\u540c\u7406\u89e3\u3002", "method": "\u63d0\u51fa\u4e3a\u79d1\u5b66\u8ba1\u7b97\u8bbe\u8ba1\u4e13\u95e8\u7684\u6311\u6218\u95ee\u9898\uff0c\u8fd9\u4e9b\u6311\u6218\u65e8\u5728\u8865\u5145\u5f62\u5f0f\u5316\u65b9\u6cd5\u7814\u7a76\u8005\u7814\u7a76\u7684\u4e00\u822c\u7a0b\u5e8f\u95ee\u9898\uff0c\u786e\u4fdd\u6ee1\u8db3\u79d1\u5b66\u8ba1\u7b97\u5e94\u7528\u7684\u9700\u6c42\u3002", "result": "\u63d0\u51fa\u4e86\u79d1\u5b66\u8ba1\u7b97\u76f8\u5173\u6b63\u786e\u6027\u7684\u591a\u4e2a\u7ef4\u5ea6\uff0c\u5e76\u8ba8\u8bba\u4e86\u8bbe\u8ba1\u8bc4\u4f30\u79d1\u5b66\u8ba1\u7b97\u6b63\u786e\u6027\u7684\u6311\u6218\u95ee\u9898\u7684\u6307\u5bfc\u539f\u5219\u548c\u6807\u51c6\u3002", "conclusion": "\u9700\u8981\u4e13\u95e8\u9488\u5bf9\u79d1\u5b66\u8ba1\u7b97\u7684\u6311\u6218\u95ee\u9898\u6765\u6307\u5bfc\u548c\u8bc4\u4f30\u5f62\u5f0f\u5316\u65b9\u6cd5/\u7f16\u7a0b\u8bed\u8a00\u9a8c\u8bc1\u6280\u672f\u7684\u53d1\u5c55\uff0c\u4ee5\u89e3\u51b3\u79d1\u5b66\u8ba1\u7b97\u9886\u57df\u7684\u6b63\u786e\u6027\u95ee\u9898\u3002"}}
{"id": "2510.13424", "categories": ["cs.SE", "D.2.5; G.1.3"], "pdf": "https://arxiv.org/pdf/2510.13424", "abs": "https://arxiv.org/abs/2510.13424", "authors": ["Alexander C. Wilton"], "title": "Verifying a Sparse Matrix Algorithm Using Symbolic Execution", "comment": "In Proceedings VSS 2025, arXiv:2510.12314", "summary": "Scientific software is, by its very nature, complex. It is mathematical and\nhighly optimized which makes it prone to subtle bugs not as easily detected by\ntraditional testing. We outline how symbolic execution can be used to write\ntests similar to traditional unit tests while providing stronger verification\nguarantees and apply this methodology to a sparse matrix algorithm.", "AI": {"tldr": "\u4f7f\u7528\u7b26\u53f7\u6267\u884c\u6765\u6d4b\u8bd5\u79d1\u5b66\u8f6f\u4ef6\uff0c\u7279\u522b\u662f\u7a00\u758f\u77e9\u9635\u7b97\u6cd5\uff0c\u63d0\u4f9b\u6bd4\u4f20\u7edf\u5355\u5143\u6d4b\u8bd5\u66f4\u5f3a\u7684\u9a8c\u8bc1\u4fdd\u8bc1", "motivation": "\u79d1\u5b66\u8f6f\u4ef6\u56e0\u5176\u6570\u5b66\u6027\u548c\u9ad8\u5ea6\u4f18\u5316\u800c\u590d\u6742\uff0c\u5bb9\u6613\u4ea7\u751f\u4f20\u7edf\u6d4b\u8bd5\u96be\u4ee5\u68c0\u6d4b\u7684\u7ec6\u5fae\u9519\u8bef", "method": "\u91c7\u7528\u7b26\u53f7\u6267\u884c\u65b9\u6cd5\u7f16\u5199\u7c7b\u4f3c\u4f20\u7edf\u5355\u5143\u6d4b\u8bd5\u7684\u6d4b\u8bd5\uff0c\u5e94\u7528\u4e8e\u7a00\u758f\u77e9\u9635\u7b97\u6cd5", "result": "\u7b26\u53f7\u6267\u884c\u80fd\u591f\u63d0\u4f9b\u66f4\u5f3a\u7684\u9a8c\u8bc1\u4fdd\u8bc1", "conclusion": "\u7b26\u53f7\u6267\u884c\u662f\u6d4b\u8bd5\u590d\u6742\u79d1\u5b66\u8f6f\u4ef6\u7684\u6709\u6548\u65b9\u6cd5\uff0c\u80fd\u591f\u68c0\u6d4b\u4f20\u7edf\u6d4b\u8bd5\u96be\u4ee5\u53d1\u73b0\u7684\u9519\u8bef"}}
{"id": "2510.13561", "categories": ["cs.SE", "cs.AI", "68N30"], "pdf": "https://arxiv.org/pdf/2510.13561", "abs": "https://arxiv.org/abs/2510.13561", "authors": ["Peng Di", "Faqiang Chen", "Xiao Bai", "Hongjun Yang", "Qingfeng Li", "Ganglin Wei", "Jian Mou", "Feng Shi", "Keting Chen", "Peng Tang", "Zhitao Shen", "Zheng Li", "Wenhui Shi", "Junwei Guo", "Hang Yu"], "title": "OpenDerisk: An Industrial Framework for AI-Driven SRE, with Design, Implementation, and Case Studies", "comment": "23 pages", "summary": "The escalating complexity of modern software imposes an unsustainable\noperational burden on Site Reliability Engineering (SRE) teams, demanding\nAI-driven automation that can emulate expert diagnostic reasoning. Existing\nsolutions, from traditional AI methods to general-purpose multi-agent systems,\nfall short: they either lack deep causal reasoning or are not tailored for the\nspecialized, investigative workflows unique to SRE. To address this gap, we\npresent OpenDerisk, a specialized, open-source multi-agent framework\narchitected for SRE. OpenDerisk integrates a diagnostic-native collaboration\nmodel, a pluggable reasoning engine, a knowledge engine, and a standardized\nprotocol (MCP) to enable specialist agents to collectively solve complex,\nmulti-domain problems. Our comprehensive evaluation demonstrates that\nOpenDerisk significantly outperforms state-of-the-art baselines in both\naccuracy and efficiency. This effectiveness is validated by its large-scale\nproduction deployment at Ant Group, where it serves over 3,000 daily users\nacross diverse scenarios, confirming its industrial-grade scalability and\npractical impact. OpenDerisk is open source and available at\nhttps://github.com/derisk-ai/OpenDerisk/", "AI": {"tldr": "OpenDerisk\u662f\u4e00\u4e2a\u4e13\u4e3aSRE\u8bbe\u8ba1\u7684\u5f00\u6e90\u591a\u667a\u80fd\u4f53\u6846\u67b6\uff0c\u901a\u8fc7\u8bca\u65ad\u539f\u751f\u534f\u4f5c\u6a21\u578b\u3001\u53ef\u63d2\u62d4\u63a8\u7406\u5f15\u64ce\u548c\u77e5\u8bc6\u5f15\u64ce\uff0c\u663e\u8457\u63d0\u5347\u4e86\u590d\u6742\u8f6f\u4ef6\u95ee\u9898\u7684\u8bca\u65ad\u51c6\u786e\u6027\u548c\u6548\u7387\u3002", "motivation": "\u73b0\u4ee3\u8f6f\u4ef6\u590d\u6742\u6027\u4e0d\u65ad\u589e\u52a0\uff0c\u7ed9SRE\u56e2\u961f\u5e26\u6765\u6c89\u91cd\u8fd0\u7ef4\u8d1f\u62c5\uff0c\u9700\u8981\u80fd\u591f\u6a21\u62df\u4e13\u5bb6\u8bca\u65ad\u63a8\u7406\u7684AI\u9a71\u52a8\u81ea\u52a8\u5316\u89e3\u51b3\u65b9\u6848\u3002\u73b0\u6709\u65b9\u6cd5\u8981\u4e48\u7f3a\u4e4f\u6df1\u5ea6\u56e0\u679c\u63a8\u7406\u80fd\u529b\uff0c\u8981\u4e48\u4e0d\u9002\u7528\u4e8eSRE\u7279\u6709\u7684\u4e13\u4e1a\u5316\u8c03\u67e5\u5de5\u4f5c\u6d41\u7a0b\u3002", "method": "\u5f00\u53d1\u4e86OpenDerisk\u6846\u67b6\uff0c\u5305\u542b\u8bca\u65ad\u539f\u751f\u534f\u4f5c\u6a21\u578b\u3001\u53ef\u63d2\u62d4\u63a8\u7406\u5f15\u64ce\u3001\u77e5\u8bc6\u5f15\u64ce\u548c\u6807\u51c6\u5316\u534f\u8bae(MCP)\uff0c\u4f7f\u4e13\u4e1a\u667a\u80fd\u4f53\u80fd\u591f\u534f\u4f5c\u89e3\u51b3\u590d\u6742\u7684\u591a\u9886\u57df\u95ee\u9898\u3002", "result": "\u7efc\u5408\u8bc4\u4f30\u663e\u793aOpenDerisk\u5728\u51c6\u786e\u6027\u548c\u6548\u7387\u4e0a\u663e\u8457\u4f18\u4e8e\u6700\u5148\u8fdb\u7684\u57fa\u7ebf\u65b9\u6cd5\u3002\u5df2\u5728\u8682\u8681\u96c6\u56e2\u5927\u89c4\u6a21\u751f\u4ea7\u90e8\u7f72\uff0c\u670d\u52a1\u8d85\u8fc73000\u540d\u65e5\u5e38\u7528\u6237\uff0c\u9a8c\u8bc1\u4e86\u5176\u5de5\u4e1a\u7ea7\u53ef\u6269\u5c55\u6027\u548c\u5b9e\u9645\u5f71\u54cd\u3002", "conclusion": "OpenDerisk\u6210\u529f\u586b\u8865\u4e86SRE\u9886\u57dfAI\u81ea\u52a8\u5316\u89e3\u51b3\u65b9\u6848\u7684\u7a7a\u767d\uff0c\u63d0\u4f9b\u4e86\u4e13\u95e8\u8bbe\u8ba1\u7684\u5f00\u6e90\u591a\u667a\u80fd\u4f53\u6846\u67b6\uff0c\u5728\u5b9e\u9645\u751f\u4ea7\u4e2d\u8bc1\u660e\u4e86\u5176\u6709\u6548\u6027\u548c\u53ef\u6269\u5c55\u6027\u3002"}}
{"id": "2510.13575", "categories": ["cs.SE", "D.2.5"], "pdf": "https://arxiv.org/pdf/2510.13575", "abs": "https://arxiv.org/abs/2510.13575", "authors": ["Han Fu", "Sigrid Eldh", "Kristian Wiklund", "Andreas Ermedahl", "Philipp Haller", "Cyrille Artho"], "title": "Auto-repair without test cases: How LLMs fix compilation errors in large industrial embedded code", "comment": "9 pages, 4 figures, conference: 2025 28th Euromicro Conference on\n  Digital System Design (DSD)", "summary": "The co-development of hardware and software in industrial embedded systems\nfrequently leads to compilation errors during continuous integration (CI).\nAutomated repair of such failures is promising, but existing techniques rely on\ntest cases, which are not available for non-compilable code.\n  We employ an automated repair approach for compilation errors driven by large\nlanguage models (LLMs). Our study encompasses the collection of more than 40000\ncommits from the product's source code. We assess the performance of an\nindustrial CI system enhanced by four state-of-the-art LLMs, comparing their\noutcomes with manual corrections provided by human programmers. LLM-equipped CI\nsystems can resolve up to 63 % of the compilation errors in our baseline\ndataset. Among the fixes associated with successful CI builds, 83 % are deemed\nreasonable. Moreover, LLMs significantly reduce debugging time, with the\nmajority of successful cases completed within 8 minutes, compared to hours\ntypically required for manual debugging.", "AI": {"tldr": "\u4f7f\u7528\u5927\u578b\u8bed\u8a00\u6a21\u578b\u81ea\u52a8\u4fee\u590d\u5de5\u4e1a\u5d4c\u5165\u5f0f\u7cfb\u7edf\u4e2d\u7f16\u8bd1\u9519\u8bef\uff0c\u5728CI\u7cfb\u7edf\u4e2d\u53ef\u89e3\u51b363%\u7684\u7f16\u8bd1\u9519\u8bef\uff0c83%\u7684\u4fee\u590d\u65b9\u6848\u5408\u7406\uff0c\u4e14\u5c06\u8c03\u8bd5\u65f6\u95f4\u4ece\u6570\u5c0f\u65f6\u7f29\u77ed\u81f38\u5206\u949f\u5185\u3002", "motivation": "\u5de5\u4e1a\u5d4c\u5165\u5f0f\u7cfb\u7edf\u4e2d\u8f6f\u786c\u4ef6\u534f\u540c\u5f00\u53d1\u7ecf\u5e38\u5728\u6301\u7eed\u96c6\u6210\u8fc7\u7a0b\u4e2d\u51fa\u73b0\u7f16\u8bd1\u9519\u8bef\uff0c\u73b0\u6709\u4fee\u590d\u6280\u672f\u4f9d\u8d56\u6d4b\u8bd5\u7528\u4f8b\uff0c\u4f46\u4e0d\u53ef\u7f16\u8bd1\u4ee3\u7801\u6ca1\u6709\u6d4b\u8bd5\u7528\u4f8b\u53ef\u7528\u3002", "method": "\u91c7\u7528\u57fa\u4e8e\u5927\u578b\u8bed\u8a00\u6a21\u578b\u7684\u81ea\u52a8\u4fee\u590d\u65b9\u6cd5\uff0c\u6536\u96c6\u4e8640000\u591a\u4e2a\u4ea7\u54c1\u6e90\u4ee3\u7801\u63d0\u4ea4\uff0c\u8bc4\u4f30\u4e86\u56db\u79cd\u6700\u5148\u8fdbLLM\u5728\u5de5\u4e1aCI\u7cfb\u7edf\u4e2d\u7684\u8868\u73b0\uff0c\u5e76\u4e0e\u4eba\u5de5\u4fee\u590d\u8fdb\u884c\u6bd4\u8f83\u3002", "result": "LLM\u589e\u5f3a\u7684CI\u7cfb\u7edf\u53ef\u89e3\u51b3\u57fa\u7ebf\u6570\u636e\u96c6\u4e2d63%\u7684\u7f16\u8bd1\u9519\u8bef\uff0c\u5176\u4e2d83%\u7684\u6210\u529f\u4fee\u590d\u88ab\u8ba4\u4e3a\u662f\u5408\u7406\u7684\u3002LLM\u663e\u8457\u51cf\u5c11\u8c03\u8bd5\u65f6\u95f4\uff0c\u5927\u591a\u6570\u6210\u529f\u6848\u4f8b\u57288\u5206\u949f\u5185\u5b8c\u6210\u3002", "conclusion": "\u5927\u578b\u8bed\u8a00\u6a21\u578b\u5728\u81ea\u52a8\u4fee\u590d\u7f16\u8bd1\u9519\u8bef\u65b9\u9762\u8868\u73b0\u4f18\u5f02\uff0c\u80fd\u591f\u6709\u6548\u89e3\u51b3\u5de5\u4e1a\u5d4c\u5165\u5f0f\u7cfb\u7edf\u4e2d\u7684\u7f16\u8bd1\u95ee\u9898\uff0c\u5927\u5e45\u63d0\u9ad8\u5f00\u53d1\u6548\u7387\u3002"}}
{"id": "2510.13692", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.13692", "abs": "https://arxiv.org/abs/2510.13692", "authors": ["Deepak A. Cherian"], "title": "Property Testing for Ocean Models. Can We Specify It? (Invited Talk)", "comment": "In Proceedings VSS 2025, arXiv:2510.12314", "summary": "I take inspiration from the property-testing literature, particularly the\nwork of Prof. John Hughes, and explore how such ideas might be applied to\nnumerical models of the ocean. Specifically, I ask whether geophysical fluid\ndynamics (GFD) theory, expressed as property tests, might be used to address\nthe oracle problem of testing the correctness of ocean models. I propose that a\nnumber of simple idealized GFD problems can be framed as property tests. These\nexamples clearly illustrate how physics naturally lends itself to specifying\nproperty tests. Which of these proposed tests might be most feasible and\nuseful, remains to be seen.", "AI": {"tldr": "\u63a2\u7d22\u5982\u4f55\u5c06\u5c5e\u6027\u6d4b\u8bd5\u7406\u8bba\u5e94\u7528\u4e8e\u6d77\u6d0b\u6570\u503c\u6a21\u578b\uff0c\u5229\u7528\u5730\u7403\u7269\u7406\u6d41\u4f53\u52a8\u529b\u5b66\u7406\u8bba\u4f5c\u4e3a\u5c5e\u6027\u6d4b\u8bd5\u6765\u89e3\u51b3\u6d77\u6d0b\u6a21\u578b\u6b63\u786e\u6027\u9a8c\u8bc1\u7684oracle\u95ee\u9898\u3002", "motivation": "\u4ece\u5c5e\u6027\u6d4b\u8bd5\u6587\u732e\u4e2d\u83b7\u5f97\u7075\u611f\uff0c\u7279\u522b\u662fJohn Hughes\u6559\u6388\u7684\u5de5\u4f5c\uff0c\u63a2\u7d22\u8fd9\u4e9b\u601d\u60f3\u5982\u4f55\u5e94\u7528\u4e8e\u6d77\u6d0b\u6570\u503c\u6a21\u578b\uff0c\u89e3\u51b3\u6d4b\u8bd5\u6d77\u6d0b\u6a21\u578b\u6b63\u786e\u6027\u65f6\u9762\u4e34\u7684oracle\u95ee\u9898\u3002", "method": "\u63d0\u51fa\u5c06\u4e00\u7cfb\u5217\u7b80\u5355\u7684\u7406\u60f3\u5316\u5730\u7403\u7269\u7406\u6d41\u4f53\u52a8\u529b\u5b66\u95ee\u9898\u6846\u67b6\u5316\u4e3a\u5c5e\u6027\u6d4b\u8bd5\uff0c\u5229\u7528\u7269\u7406\u5b66\u81ea\u7136\u7279\u6027\u6765\u6307\u5b9a\u5c5e\u6027\u6d4b\u8bd5\u3002", "result": "\u901a\u8fc7\u793a\u4f8b\u6e05\u6670\u5730\u5c55\u793a\u4e86\u7269\u7406\u5b66\u5982\u4f55\u81ea\u7136\u5730\u9002\u7528\u4e8e\u5c5e\u6027\u6d4b\u8bd5\u7684\u89c4\u8303\u5236\u5b9a\uff0c\u4f46\u5177\u4f53\u54ea\u4e9b\u6d4b\u8bd5\u6700\u53ef\u884c\u548c\u6709\u7528\u4ecd\u9700\u8fdb\u4e00\u6b65\u7814\u7a76\u3002", "conclusion": "\u5730\u7403\u7269\u7406\u6d41\u4f53\u52a8\u529b\u5b66\u7406\u8bba\u53ef\u4ee5\u4f5c\u4e3a\u5c5e\u6027\u6d4b\u8bd5\u6765\u9a8c\u8bc1\u6d77\u6d0b\u6a21\u578b\u7684\u6b63\u786e\u6027\uff0c\u4f46\u9700\u8981\u8fdb\u4e00\u6b65\u786e\u5b9a\u54ea\u4e9b\u6d4b\u8bd5\u6700\u5177\u53ef\u884c\u6027\u548c\u5b9e\u7528\u6027\u3002"}}
{"id": "2510.13697", "categories": ["cs.SE", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.13697", "abs": "https://arxiv.org/abs/2510.13697", "authors": ["Maksim Sapronov", "Evgeniy Glukhov"], "title": "On Pretraining for Project-Level Code Completion", "comment": null, "summary": "Repository-level pretraining is commonly used to enable large language models\nfor code to leverage codebase-wide context. This enhances their ability to\ngenerate accurate and context-aware code completions. In this work, we\ninvestigate how different repository-processing strategies affect in-context\nlearning in OpenCoder, a 1.5B-parameter model. We extend its context window\nfrom 4,096 to 16,384 tokens by training on additional 1B tokens of curated\nrepository-level data. Despite relying on a smaller dataset than competing\nmodels (which often use hundreds of billions of tokens), our model achieves\ncomparable performance on the Long Code Arena benchmark. We find that various\nrepository-processing techniques yield similarly strong results, with the\nprimary gain coming from adapting to a new rotary positional embedding (RoPE)\nscaling parameter. Finally, we show that a simpler file-level training approach\nat the original sequence length remains highly effective, opening up\nrepository-level code completion research to settings with more constrained\ndata and compute resources.", "AI": {"tldr": "\u8bba\u6587\u7814\u7a76\u4e86\u4e0d\u540c\u4ed3\u5e93\u5904\u7406\u7b56\u7565\u5bf9\u4ee3\u7801\u6a21\u578b\u4e0a\u4e0b\u6587\u5b66\u4e60\u7684\u5f71\u54cd\uff0c\u901a\u8fc7\u6269\u5c55OpenCoder\u6a21\u578b\u7684\u4e0a\u4e0b\u6587\u7a97\u53e3\u5e76\u8bad\u7ec3\u4ed3\u5e93\u7ea7\u6570\u636e\uff0c\u5728\u8f83\u5c0f\u6570\u636e\u96c6\u4e0b\u53d6\u5f97\u4e86\u4e0e\u7ade\u4e89\u6a21\u578b\u76f8\u5f53\u7684\u6027\u80fd\u3002", "motivation": "\u63a2\u7d22\u4ed3\u5e93\u7ea7\u9884\u8bad\u7ec3\u4e2d\u4e0d\u540c\u5904\u7406\u7b56\u7565\u5bf9\u4ee3\u7801\u6a21\u578b\u4e0a\u4e0b\u6587\u5b66\u4e60\u80fd\u529b\u7684\u5f71\u54cd\uff0c\u7279\u522b\u662f\u5728\u6709\u9650\u6570\u636e\u548c\u8ba1\u7b97\u8d44\u6e90\u4e0b\u7684\u6709\u6548\u6027\u3002", "method": "\u5c06OpenCoder\u6a21\u578b\u7684\u4e0a\u4e0b\u6587\u7a97\u53e3\u4ece4,096\u6269\u5c55\u523016,384\u4e2atoken\uff0c\u572810\u4ebf\u4e2a\u7cbe\u9009\u4ed3\u5e93\u7ea7token\u4e0a\u8fdb\u884c\u8bad\u7ec3\uff0c\u6bd4\u8f83\u4e0d\u540c\u4ed3\u5e93\u5904\u7406\u6280\u672f\u3002", "result": "\u5728Long Code Arena\u57fa\u51c6\u6d4b\u8bd5\u4e2d\u53d6\u5f97\u4e86\u4e0e\u7ade\u4e89\u6a21\u578b\u76f8\u5f53\u7684\u6027\u80fd\uff0c\u53d1\u73b0\u4e0d\u540c\u4ed3\u5e93\u5904\u7406\u6280\u672f\u6548\u679c\u76f8\u4f3c\uff0c\u4e3b\u8981\u6536\u76ca\u6765\u81ea\u9002\u5e94\u65b0\u7684RoPE\u7f29\u653e\u53c2\u6570\u3002", "conclusion": "\u66f4\u7b80\u5355\u7684\u6587\u4ef6\u7ea7\u8bad\u7ec3\u65b9\u6cd5\u5728\u539f\u59cb\u5e8f\u5217\u957f\u5ea6\u4e0b\u4ecd\u7136\u975e\u5e38\u6709\u6548\uff0c\u4e3a\u8d44\u6e90\u53d7\u9650\u73af\u5883\u4e0b\u7684\u4ed3\u5e93\u7ea7\u4ee3\u7801\u8865\u5168\u7814\u7a76\u5f00\u8f9f\u4e86\u53ef\u80fd\u6027\u3002"}}

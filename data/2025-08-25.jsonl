{"id": "2508.16305", "categories": ["cs.FL"], "pdf": "https://arxiv.org/pdf/2508.16305", "abs": "https://arxiv.org/abs/2508.16305", "authors": ["Edi Muškardin", "Tamim Burgstaller"], "title": "Passive Model Learning of Visibly Deterministic Context-free Grammars", "comment": null, "summary": "We present PAPNI, a passive automata learning algorithm capable of learning\ndeterministic context-free grammars, which are modeled with visibly\ndeterministic pushdown automata. PAPNI is a generalization of RPNI, a passive\nautomata learning algorithm capable of learning regular languages from positive\nand negative samples. PAPNI uses RPNI as its underlying learning algorithm\nwhile assuming a priori knowledge of the visibly deterministic input alphabet,\nthat is, the alphabet decomposition into symbols that push to the stack, pop\nfrom the stack, or do not affect the stack.\n  In this paper, we show how passive learning of deterministic pushdown\nautomata can be viewed as a preprocessing step of standard RPNI\nimplementations. We evaluate the proposed approach on various deterministic\ncontext-free grammars found in the literature and compare the predictive\naccuracy of learned models with RPNI."}
{"id": "2508.16384", "categories": ["cs.FL", "cs.SE"], "pdf": "https://arxiv.org/pdf/2508.16384", "abs": "https://arxiv.org/abs/2508.16384", "authors": ["Gabriel Dengler", "Sven Apel", "Holger Hermanns"], "title": "Automata Learning -- Expect Delays!", "comment": "Accepted at Integrated Formal Methods (iFM) 2025", "summary": "This paper studies active automata learning (AAL) in the presence of\nstochastic delays. We consider Mealy machines that have stochastic delays\nassociated with each transition and explore how the learner can efficiently\narrive at faithful estimates of those machines, the precision of which\ncrucially relies on repetitive sampling of transition delays. While it is\npossible to na\\\"ively integrate the delay sampling into AAL algorithms such as\n$L^*$, this leads to considerable oversampling near the root of the state\nspace. We address this problem by separating conceptually the learning of\nbehavior and delays such that the learner uses the information gained while\nlearning the logical behavior to arrive at efficient input sequences for\ncollecting the needed delay samples. We put emphasis on treating cases in which\nidentical input/output behaviors might stem from distinct delay\ncharacteristics. Finally, we provide empirical evidence that our method\noutperforms the na\\\"ive baseline across a wide range of benchmarks and\ninvestigate its applicability in a realistic setting by studying the join order\nin a relational database."}
{"id": "2508.16063", "categories": ["cs.PL", "cs.FL"], "pdf": "https://arxiv.org/pdf/2508.16063", "abs": "https://arxiv.org/abs/2508.16063", "authors": ["Paul Krogmeier", "P. Madhusudan"], "title": "Synthesizing DSLs for Few-Shot Learning", "comment": null, "summary": "We study the problem of synthesizing domain-specific languages (DSLs) for\nfew-shot learning in symbolic domains. Given a base language and instances of\nfew-shot learning problems, where each instance is split into training and\ntesting samples, the DSL synthesis problem asks for a grammar over the base\nlanguage that guarantees that small expressions solving training samples also\nsolve corresponding testing samples. We prove that the problem is decidable for\na class of languages whose semantics over fixed structures can be evaluated by\ntree automata and when expression size corresponds to parse tree depth in the\ngrammar, and, furthermore, the grammars solving the problem correspond to a\nregular set of trees. We also prove decidability results for variants of the\nproblem where DSLs are only required to express solutions for input learning\nproblems and where DSLs are defined using macro grammars."}
{"id": "2508.15866", "categories": ["cs.PL", "cs.LG", "cs.SE"], "pdf": "https://arxiv.org/pdf/2508.15866", "abs": "https://arxiv.org/abs/2508.15866", "authors": ["Lingxiao Li", "Salar Rahili", "Yiwei Zhao"], "title": "Correctness-Guaranteed Code Generation via Constrained Decoding", "comment": "Published at COLM 2025", "summary": "Language Models (LMs) are increasingly being used for code generation, but\nensuring the correctness of generated programs remains a significant challenge.\nAlthough imperfect code may be acceptable during software development with\nhuman oversight, domains such as video games and robotics require one-shot\ncorrectness for runtime-critical components. We present a constrained decoding\nalgorithm for generating semantically correct programs that incorporates a\ncontext-sensitive parser, which, at each step, outputs a regular expression\nthat satisfies a critical non-extensible property to guide the generation of\nthe next token sequence that can continue to a correct program. To build such a\ncontext-sensitive parser, we propose a framework of a dynamic tree of parsers\n(ToP) during parsing, where each parser corresponds to a modular context-free\ngrammar enriched with contextual information such as variable scopes and type\nconstraints, with tree branches representing ambiguity in the future code\nsegment. We demonstrate our approach through sLua, a strongly typed variant of\nLua, showing that our method can generate semantically correct programs\nconforming to any prescribed scripting API. We further show that, with careful\ndesign, our semantic guarantees extend to runtime correctness, as validated in\nthe application of generating game mechanics for a roguelike video game."}
{"id": "2508.15856", "categories": ["cs.LO"], "pdf": "https://arxiv.org/pdf/2508.15856", "abs": "https://arxiv.org/abs/2508.15856", "authors": ["Mikoláš Janota"], "title": "Experimental Results for Vampire on the Equational Theories Project", "comment": null, "summary": "Equational Theories Project is a collaborative effort, which explores the\nvalidity of certain first-order logic implications of certain kind. The project\nhas been completed but triggered further research. This report investigates how\nmuch can be automatically proven and disproven by the automated theorem prover\nVampire. An interesting conclusion is that Vampire can prove all the considered\nimplications that hold and also is able to refute a vast majority of those that\ndo not hold."}
{"id": "2508.15941", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2508.15941", "abs": "https://arxiv.org/abs/2508.15941", "authors": ["Imen Trabelsi", "Brahim Mahmoudi", "Jean Baptiste Minani", "Naouel Moha", "Yann-Gaël Guéhéneuc"], "title": "A Systematic Literature Review of Machine Learning Approaches for Migrating Monolithic Systems to Microservices", "comment": null, "summary": "Scalability and maintainability challenges in monolithic systems have led to\nthe adoption of microservices, which divide systems into smaller, independent\nservices. However, migrating existing monolithic systems to microservices is a\ncomplex and resource-intensive task, which can benefit from machine learning\n(ML) to automate some of its phases. Choosing the right ML approach for\nmigration remains challenging for practitioners. Previous works studied\nseparately the objectives, artifacts, techniques, tools, and benefits and\nchallenges of migrating monolithic systems to microservices. No work has yet\ninvestigated systematically existing ML approaches for this migration to\nunderstand the \\revised{automated migration phases}, inputs used, ML techniques\napplied, evaluation processes followed, and challenges encountered. We present\na systematic literature review (SLR) that aggregates, synthesises, and\ndiscusses the approaches and results of 81 primary studies (PSs) published\nbetween 2015 and 2024. We followed the Preferred Reporting Items for Systematic\nReview and Meta-Analysis (PRISMA) statement to report our findings and answer\nour research questions (RQs). We extract and analyse data from these PSs to\nanswer our RQs. We synthesise the findings in the form of a classification that\nshows the usage of ML techniques in migrating monolithic systems to\nmicroservices. The findings reveal that some phases of the migration process,\nsuch as monitoring and service identification, are well-studied, while others,\nlike packaging microservices, remain unexplored. Additionally, the findings\nhighlight key challenges, including limited data availability, scalability and\ncomplexity constraints, insufficient tool support, and the absence of\nstandardized benchmarking, emphasizing the need for more holistic solutions."}
{"id": "2508.15898", "categories": ["cs.PL", "cs.CR"], "pdf": "https://arxiv.org/pdf/2508.15898", "abs": "https://arxiv.org/abs/2508.15898", "authors": ["Matthew Sotoudeh", "Zachary Yedidia"], "title": "Automated Formal Verification of a Software Fault Isolation System", "comment": "Short paper to appear at FMCAD 2025, https://fmcad.org/", "summary": "Software fault isolation (SFI) is a popular way to sandbox untrusted\nsoftware. A key component of SFI is the verifier that checks the untrusted code\nis written in a subset of the machine language that guarantees it never reads\nor writes outside of a region of memory dedicated to the sandbox. Soundness\nbugs in the SFI verifier would break the SFI security model and allow the\nsupposedly sandboxed code to read protected memory. In this paper, we address\nthe concern of SFI verifier bugs by performing an automated formal verification\nof a recent SFI system called Lightweight Fault Isolation (LFI). In particular,\nwe formally verify that programs accepted by the LFI verifier never read or\nwrite to memory outside of a designated sandbox region."}
{"id": "2508.15878", "categories": ["cs.LO", "cs.AI", "cs.CL", "cs.LG"], "pdf": "https://arxiv.org/pdf/2508.15878", "abs": "https://arxiv.org/abs/2508.15878", "authors": ["Terry Jingchen Zhang", "Wenyuan Jiang", "Rongchuan Liu", "Yisong Wang", "Junran Yang", "Ning Wang", "Nicole Ni", "Yinya Huang", "Mrinmaya Sachan"], "title": "Lean Meets Theoretical Computer Science: Scalable Synthesis of Theorem Proving Challenges in Formal-Informal Pairs", "comment": "Accepted to AI4MATH@ICML2025", "summary": "Formal theorem proving (FTP) has emerged as a critical foundation for\nevaluating the reasoning capabilities of large language models, enabling\nautomated verification of mathematical proofs at scale. However, progress has\nbeen constrained by limited datasets due to the high cost of manual curation\nand the scarcity of challenging problems with verified formal-informal\ncorrespondences. We propose leveraging theoretical computer science (TCS) as a\nscalable source of rigorous proof problems, where algorithmic definitions\nenable automated generation of arbitrarily many challenging theorem-proof\npairs. We demonstrate this approach on two TCS domains: Busy Beaver problems,\nwhich involve proving bounds on Turing machine halting behavior, and Mixed\nBoolean Arithmetic problems, which combine logical and arithmetic reasoning.\nOur framework automatically synthesizes problems with parallel formal (Lean4)\nand informal (Markdown) specifications, creating a scalable pipeline for\ngenerating verified proof challenges. Evaluation on frontier models reveals\nsubstantial gaps in automated theorem proving: while DeepSeekProver-V2-671B\nachieves 57.5\\% success on Busy Beaver problems, it manages only 12\\% on Mixed\nBoolean Arithmetic problems. These results highlight the difficulty of\nlong-form proof generation even for problems that are computationally easy to\nverify, demonstrating the value of TCS domains for advancing automated\nreasoning research."}
{"id": "2508.16025", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2508.16025", "abs": "https://arxiv.org/abs/2508.16025", "authors": ["Saba Naqvi", "Mohammad Baqar"], "title": "Breaking Barriers in Software Testing: The Power of AI-Driven Automation", "comment": "10 Pages", "summary": "Software testing remains critical for ensuring reliability, yet traditional\napproaches are slow, costly, and prone to gaps in coverage. This paper presents\nan AI-driven framework that automates test case generation and validation using\nnatural language processing (NLP), reinforcement learning (RL), and predictive\nmodels, embedded within a policy-driven trust and fairness model. The approach\ntranslates natural language requirements into executable tests, continuously\noptimizes them through learning, and validates outcomes with real-time analysis\nwhile mitigating bias. Case studies demonstrate measurable gains in defect\ndetection, reduced testing effort, and faster release cycles, showing that\nAI-enhanced testing improves both efficiency and reliability. By addressing\nintegration and scalability challenges, the framework illustrates how AI can\nshift testing from a reactive, manual process to a proactive, adaptive system\nthat strengthens software quality in increasingly complex environments."}
{"id": "2508.16063", "categories": ["cs.PL", "cs.FL"], "pdf": "https://arxiv.org/pdf/2508.16063", "abs": "https://arxiv.org/abs/2508.16063", "authors": ["Paul Krogmeier", "P. Madhusudan"], "title": "Synthesizing DSLs for Few-Shot Learning", "comment": null, "summary": "We study the problem of synthesizing domain-specific languages (DSLs) for\nfew-shot learning in symbolic domains. Given a base language and instances of\nfew-shot learning problems, where each instance is split into training and\ntesting samples, the DSL synthesis problem asks for a grammar over the base\nlanguage that guarantees that small expressions solving training samples also\nsolve corresponding testing samples. We prove that the problem is decidable for\na class of languages whose semantics over fixed structures can be evaluated by\ntree automata and when expression size corresponds to parse tree depth in the\ngrammar, and, furthermore, the grammars solving the problem correspond to a\nregular set of trees. We also prove decidability results for variants of the\nproblem where DSLs are only required to express solutions for input learning\nproblems and where DSLs are defined using macro grammars."}
{"id": "2508.16146", "categories": ["cs.LO", "cs.DB"], "pdf": "https://arxiv.org/pdf/2508.16146", "abs": "https://arxiv.org/abs/2508.16146", "authors": ["Nicolas Fröhlich", "Phokion G. Kolaitis", "Arne Meier"], "title": "Disjunctions of Two Dependence Atoms", "comment": null, "summary": "Dependence logic is a formalism that augments the syntax of first-order logic\nwith dependence atoms asserting that the value of a variable is determined by\nthe values of some other variables, i.e., dependence atoms express functional\ndependencies in relational databases. On finite structures, dependence logic\ncaptures NP, hence there are sentences of dependence logic whose model-checking\nproblem is NP-complete. In fact, it is known that there are disjunctions of\nthree dependence atoms whose model-checking problem is NP-complete. Motivated\nfrom considerations in database theory, we study the model-checking problem for\ndisjunctions of two unary dependence atoms and establish a trichotomy theorem,\nnamely, for every such formula, one of the following is true for the\nmodel-checking problem: (i) it is NL-complete; (ii) it is LOGSPACE-complete;\n(iii) it is first-order definable (hence, in AC[0]). Furthermore, we classify\nthe complexity of the model-checking problem for disjunctions of two arbitrary\ndependence atoms, and also characterize when such a disjunction is coherent,\ni.e., when it satisfies a certain small-model property. Along the way, we\nidentify a new class of 2CNF-formulas whose satisfiability problem is\nLOGSPACE-complete."}
{"id": "2508.16053", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2508.16053", "abs": "https://arxiv.org/abs/2508.16053", "authors": ["Shadikur Rahman", "Umme Ayman Koana", "Hasibul Karim Shanto", "Mahmuda Akter", "Chitra Roy", "Aras M. Ismael"], "title": "Measuring the effectiveness of code review comments in GitHub repositories: A machine learning approach", "comment": null, "summary": "This paper illustrates an empirical study of the working efficiency of\nmachine learning techniques in classifying code review text by semantic\nmeaning. The code review comments from the source control repository in GitHub\nwere extracted for development activity from the existing year for three\nopen-source projects. Apart from that, programmers need to be aware of their\ncode and point out their errors. In that case, it is a must to classify the\nsentiment polarity of the code review comments to avoid an error. We manually\nlabelled 13557 code review comments generated by three open source projects in\nGitHub during the existing year. In order to recognize the sentiment polarity\n(or sentiment orientation) of code reviews, we use seven machine learning\nalgorithms and compare those results to find the better ones. Among those\nLinear Support Vector Classifier(SVC) classifier technique achieves higher\naccuracy than others. This study will help programmers to make any solution\nbased on code reviews by avoiding misconceptions."}
{"id": "2508.16125", "categories": ["cs.PL", "cs.SE"], "pdf": "https://arxiv.org/pdf/2508.16125", "abs": "https://arxiv.org/abs/2508.16125", "authors": ["Zhenyang Xu", "Hongxu Xu", "Yongqiang Tian", "Xintong Zhou", "Chengnian Sun"], "title": "Leveraging Large Language Models to Detect Missed Peephole Optimizations", "comment": null, "summary": "By replacing small, suboptimal instruction sequences within programs with a\nmore efficient equivalent, peephole optimization can not only directly optimize\ncode size and performance, but also potentially enables further transformations\nin the subsequent optimization pipeline. Although peephole optimization is a\ncritical class of compiler optimizations, discovering new and effective\npeephole optimizations is challenging as the instruction sets can be extremely\ncomplex and diverse. Previous methods either do not scale well or can only\ncapture a limited subset of peephole optimizations. In this work, we leverage\nLarge Language Models (LLMs) to detect missed peephole optimizations. We\npropose Lampo, a novel automated framework that synergistically combines the\ncreative but unreliable code optimization ability of LLMs with rigorous\ncorrectness verification performed by translation validation tools, integrated\nin a feedback-driven iterative process. Through a comprehensive evaluation\nwithin LLVM ecosystems, we show that Lampo can successfully detect up to 17 out\nof 25 previously reported missed optimizations in LLVM on average, and that 22\nout of 25 can potentially be found by Lampo with different LLMs. For\ncomparison, the state-of-the-art superoptimizer for LLVM, Souper, identified 15\nof them. Moreover, within seven months of development and intermittent\nexperiments, Lampo found 26 missed peephole optimizations, 15 of which have\nbeen confirmed and 6 already fixed. These results demonstrate Lampo's strong\npotential in continuously detecting missed peephole optimizations."}
{"id": "2508.16242", "categories": ["cs.LO", "cs.AI", "68T27", "I.2.3"], "pdf": "https://arxiv.org/pdf/2508.16242", "abs": "https://arxiv.org/abs/2508.16242", "authors": ["Alexander Steen"], "title": "A Reduction of Input/Output Logics to SAT", "comment": "32 pages", "summary": "Deontic logics are formalisms for reasoning over norms, obligations,\npermissions and prohibitions. Input/Output (I/O) Logics are a particular family\nof so-called norm-based deontic logics that formalize conditional norms outside\nof the underlying object logic language, where conditional norms do not carry a\ntruth-value themselves. In this paper, an automation approach for I/O logics is\npresented that makes use of suitable reductions to (sequences of) propositional\nsatisfiability problems. A prototypical implementation, named rio (reasoner for\ninput/output logics), of the proposed procedures is presented and applied to\nillustrative examples."}
{"id": "2508.16071", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2508.16071", "abs": "https://arxiv.org/abs/2508.16071", "authors": ["Mahinthan Chandramohan", "Jovan Jancic", "Yuntong Zhang", "Padmanabhan Krishnan"], "title": "From Benchmark Data To Applicable Program Repair: An Experience Report", "comment": null, "summary": "This paper describes our approach to automated program repair. We combine\nvarious techniques from the literature to achieve this. Our experiments show\nthat our approach performs better than other techniques on standard benchmarks.\nHowever, on closer inspection, none of these techniques work on realistic\ndefects that we see in industry.\n  We find that augmenting code with formal specifications enables LLMs to\ngenerate higher-quality unit tests, especially for complex production code with\nimproved coverage of edge cases and exception handling. However, specifications\nadd little value for well-understood errors (e.g., null pointer, index out of\nbounds), but are beneficial for logic and string manipulation errors. Despite\nencouraging benchmark results, real-world adoption is limited since passing\ntests do not guarantee correct patches. Current challenges include insufficient\nexpressiveness of the JML specification language, necessitating advanced\nverification tools and richer predicates. Our ongoing work is exploring\ncontract automata, programming by example, and testcase repair, with a focus on\nintegrating human feedback and measuring productivity gains - highlighting the\ngap between academic benchmarks and practical industry needs"}
{"id": "2508.16522", "categories": ["cs.PL", "cs.DC"], "pdf": "https://arxiv.org/pdf/2508.16522", "abs": "https://arxiv.org/abs/2508.16522", "authors": ["Rohan Yadav", "Joseph Guman", "Sean Treichler", "Michael Garland", "Alex Aiken", "Fredrik Kjolstad", "Michael Bauer"], "title": "On the Duality of Task and Actor Programming Models", "comment": null, "summary": "Programming models for distributed and heterogeneous machines are rapidly\ngrowing in popularity to meet the demands of modern workloads. Task and actor\nmodels are common choices that offer different trade-offs between development\nproductivity and achieved performance. Task-based models offer better\nproductivity and composition of software, whereas actor-based models routinely\ndeliver better peak performance due to lower overheads. While task-based and\nactor-based models appear to be different superficially, we demonstrate these\nprogramming models are duals of each other. Importantly, we show that this\nduality extends beyond functionality to performance, and elucidate techniques\nthat let task-based systems deliver performance competitive with actor-based\nsystems without compromising productivity. We apply these techniques to both\nRealm, an explicitly parallel task-based runtime, as well as Legion, an\nimplicitly parallel task-based runtime. We show these techniques reduce Realm's\noverheads by between 1.7-5.3x, coming within a factor of two of the overheads\nimposed by heavily optimized actor-based systems like Charm++ and MPI. We\nfurther show that our techniques enable between 1.3-5.0x improved strong\nscaling of unmodified Legion applications."}
{"id": "2508.16345", "categories": ["cs.LO", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2508.16345", "abs": "https://arxiv.org/abs/2508.16345", "authors": ["Asger Horn Brorholt", "Andreas Holck Høeg-Petersen", "Peter Gjøl Jensen", "Kim Guldstrand Larsen", "Marius Mikučionis", "Christian Schilling", "Andrzej Wąsowski"], "title": "Uppaal Coshy: Automatic Synthesis of Compact Shields for Hybrid Systems", "comment": "12 pages and 6 figures. Additional abstract of 4 pages and 4 figures.\n  Extended version with supplementary material for an article to appear in the\n  2025 International Conference on Reachability Problems (RP)", "summary": "We present Uppaal Coshy, a tool for automatic synthesis of a safety strategy\n-- or shield -- for Markov decision processes over continuous state spaces and\ncomplex hybrid dynamics. The general methodology is to partition the state\nspace and then solve a two-player safety game, which entails a number of\nalgorithmically hard problems such as reachability for hybrid systems. The\ngeneral philosophy of Uppaal Coshy is to approximate hard-to-obtain solutions\nusing simulations. Our implementation is fully automatic and supports the\nexpressive formalism of Uppaal models, which encompass stochastic hybrid\nautomata. The precision of our partition-based approach benefits from using\nfiner grids, which however are not efficient to store. We include an algorithm\ncalled Caap to efficiently compute a compact representation of a shield in the\nform of a decision tree, which yields significant reductions."}
{"id": "2508.16104", "categories": ["cs.SE", "cs.RO"], "pdf": "https://arxiv.org/pdf/2508.16104", "abs": "https://arxiv.org/abs/2508.16104", "authors": ["Arturo Miguel Russell Bernal", "Maureen Petterson", "Pedro Antonio Alarcon Granadeno", "Michael Murphy", "James Mason", "Jane Cleland-Huang"], "title": "Validating Terrain Models in Digital Twins for Trustworthy sUAS Operations", "comment": "Submitted to EDTconf 2025", "summary": "With the increasing deployment of small Unmanned Aircraft Systems (sUAS) in\nunfamiliar and complex environments, Environmental Digital Twins (EDT) that\ncomprise weather, airspace, and terrain data are critical for safe flight\nplanning and for maintaining appropriate altitudes during search and\nsurveillance operations. With the expansion of sUAS capabilities through edge\nand cloud computing, accurate EDT are also vital for advanced sUAS\ncapabilities, like geolocation. However, real-world sUAS deployment introduces\nsignificant sources of uncertainty, necessitating a robust validation process\nfor EDT components. This paper focuses on the validation of terrain models, one\nof the key components of an EDT, for real-world sUAS tasks. These models are\nconstructed by fusing U.S. Geological Survey (USGS) datasets and satellite\nimagery, incorporating high-resolution environmental data to support mission\ntasks. Validating both the terrain models and their operational use by sUAS\nunder real-world conditions presents significant challenges, including limited\ndata granularity, terrain discontinuities, GPS and sensor inaccuracies, visual\ndetection uncertainties, as well as onboard resources and timing constraints.\nWe propose a 3-Dimensions validation process grounded in software engineering\nprinciples, following a workflow across granularity of tests, simulation to\nreal world, and the analysis of simple to edge conditions. We demonstrate our\napproach using a multi-sUAS platform equipped with a Terrain-Aware Digital\nShadow."}
{"id": "2508.16517", "categories": ["cs.SE", "cs.PL"], "pdf": "https://arxiv.org/pdf/2508.16517", "abs": "https://arxiv.org/abs/2508.16517", "authors": ["Bingkun Yao", "Ning Wang", "Xiangfeng Liu", "Yuxin Du", "Yuchen Hu", "Hong Gao", "Zhe Jiang", "Nan Guan"], "title": "ARSP: Automated Repair of Verilog Designs via Semantic Partitioning", "comment": null, "summary": "Debugging functional Verilog bugs consumes a significant portion of front-end\ndesign time. While Large Language Models (LLMs) have demonstrated great\npotential in mitigating this effort, existing LLM-based automated debugging\nmethods underperform on industrial-scale modules. A major reason for this is\nbug signal dilution in long contexts, where a few bug-relevant tokens are\noverwhelmed by hundreds of unrelated lines, diffusing the model's attention. To\naddress this issue, we introduce ARSP, a two-stage system that mitigates\ndilution via semantics-guided fragmentation. A Partition LLM splits a module\ninto semantically tight fragments; a Repair LLM patches each fragment; edits\nare merged without altering unrelated logic. A synthetic data framework\ngenerates fragment-level training pairs spanning bug types, design styles, and\nscales to supervise both models. Experiments show that ARSP achieves 77.92%\npass@1 and 83.88% pass@5, outperforming mainstream commercial LLMs including\nClaude-3.7 and SOTA automated Verilog debugging tools Strider and MEIC. Also,\nsemantic partitioning improves pass@1 by 11.6% and pass@5 by 10.2% over\nwhole-module debugging, validating the effectiveness of fragment-level scope\nreduction in LLM-based Verilog debugging."}
{"id": "2508.16131", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2508.16131", "abs": "https://arxiv.org/abs/2508.16131", "authors": ["Zoe Kotti", "Konstantina Dritsa", "Diomidis Spinellis", "Panos Louridas"], "title": "The Fools are Certain; the Wise are Doubtful: Exploring LLM Confidence in Code Completion", "comment": "30 pages, 10 figures", "summary": "Code completion entails the task of providing missing tokens given a\nsurrounding context. It can boost developer productivity while providing a\npowerful code discovery tool. Following the Large Language Model (LLM) wave,\ncode completion has been approached with diverse LLMs fine-tuned on code (code\nLLMs). The performance of code LLMs can be assessed with downstream and\nintrinsic metrics. Downstream metrics are usually employed to evaluate the\npractical utility of a model, but can be unreliable and require complex\ncalculations and domain-specific knowledge. In contrast, intrinsic metrics such\nas perplexity, entropy, and mutual information, which measure model confidence\nor uncertainty, are simple, versatile, and universal across LLMs and tasks, and\ncan serve as proxies for functional correctness and hallucination risk in\nLLM-generated code. Motivated by this, we evaluate the confidence of LLMs when\ngenerating code by measuring code perplexity across programming languages,\nmodels, and datasets using various LLMs, and a sample of 1008 files from 657\nGitHub projects. We find that strongly-typed languages exhibit lower perplexity\nthan dynamically typed languages. Scripting languages also demonstrate higher\nperplexity. Perl appears universally high in perplexity, whereas Java appears\nlow. Code perplexity depends on the employed LLM, but not on the code dataset.\nAlthough code comments often increase perplexity, the language ranking based on\nperplexity is barely affected by their presence. LLM researchers, developers,\nand users can employ our findings to assess the benefits and suitability of\nLLM-based code completion in specific software projects based on how language,\nmodel choice, and code characteristics impact model confidence."}
{"id": "2508.16165", "categories": ["cs.SE", "cs.AI", "cs.HC"], "pdf": "https://arxiv.org/pdf/2508.16165", "abs": "https://arxiv.org/abs/2508.16165", "authors": ["Sebastian Lubos", "Alexander Felfernig", "Gerhard Leitner", "Julian Schwazer"], "title": "Towards Recommending Usability Improvements with Multimodal Large Language Models", "comment": null, "summary": "Usability describes a set of essential quality attributes of user interfaces\n(UI) that influence human-computer interaction. Common evaluation methods, such\nas usability testing and inspection, are effective but resource-intensive and\nrequire expert involvement. This makes them less accessible for smaller\norganizations. Recent advances in multimodal LLMs offer promising opportunities\nto automate usability evaluation processes partly by analyzing textual, visual,\nand structural aspects of software interfaces. To investigate this possibility,\nwe formulate usability evaluation as a recommendation task, where multimodal\nLLMs rank usability issues by severity. We conducted an initial\nproof-of-concept study to compare LLM-generated usability improvement\nrecommendations with usability expert assessments. Our findings indicate the\npotential of LLMs to enable faster and more cost-effective usability\nevaluation, which makes it a practical alternative in contexts with limited\nexpert resources."}
{"id": "2508.16181", "categories": ["cs.SE", "cs.AI", "cs.SY", "eess.SY"], "pdf": "https://arxiv.org/pdf/2508.16181", "abs": "https://arxiv.org/abs/2508.16181", "authors": ["Zirui Li", "Stephan Husung", "Haoze Wang"], "title": "LLM-Assisted Semantic Alignment and Integration in Collaborative Model-Based Systems Engineering Using SysML v2", "comment": "Accepted by IEEE ISSE 2025, DOI pending", "summary": "Cross-organizational collaboration in Model-Based Systems Engineering (MBSE)\nfaces many challenges in achieving semantic alignment across independently\ndeveloped system models. SysML v2 introduces enhanced structural modularity and\nformal semantics, offering a stronger foundation for interoperable modeling.\nMeanwhile, GPT-based Large Language Models (LLMs) provide new capabilities for\nassisting model understanding and integration. This paper proposes a\nstructured, prompt-driven approach for LLM-assisted semantic alignment of SysML\nv2 models. The core contribution lies in the iterative development of an\nalignment approach and interaction prompts, incorporating model extraction,\nsemantic matching, and verification. The approach leverages SysML v2 constructs\nsuch as alias, import, and metadata extensions to support traceable, soft\nalignment integration. It is demonstrated with a GPT-based LLM through an\nexample of a measurement system. Benefits and limitations are discussed."}
{"id": "2508.16273", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2508.16273", "abs": "https://arxiv.org/abs/2508.16273", "authors": ["Maria Teresa Rossi", "Martina De Sanctis", "Ludovico Iovino", "Manuel Wimmer"], "title": "A Systematic Mapping Study on Smart Cities Modeling Approaches", "comment": null, "summary": "The Smart City concept was introduced to define an idealized city\ncharacterized by automation and connection. It then evolved rapidly by\nincluding further aspects, such as economy, environment. Since then, many\npublications have explored various aspects of Smart Cities across different\napplication domains and research communities, acknowledging the\ninterdisciplinary nature of this subject. In particular, our interest focuses\non how smart cities are designed and modeled, as a whole or as regards with\ntheir subsystems, when dealing with the accomplishment of the research goals in\nthis complex and heterogeneous domain. To this aim, we performed a systematic\nmapping study on smart cities modeling approaches identifying the relevant\ncontributions (i) to get an overview of existing research approaches, (ii) to\nidentify whether there are any publication trends, and (iii) to identify\npossible future research directions. We followed the guidelines for conducting\nsystematic mapping studies by Petersen et al. to analyze smart cities modeling\npublications. Our analysis revealed the following main findings: (i) smart\ngovernance is the most investigated and modeled smart city dimension; (ii) the\nmost used modeling approaches are business, architectural, and ontological\nmodeling approaches, spanning multiple application fields; (iii) the great\nmajority of existing technologies for modeling smart cities are not yet proven\nin operational environments; (iv) diverse research communities publish their\nresults in a multitude of different venues which further motivates the\npresented literature study. Researchers can use our results for better\nunderstanding the state-of-the-art in modeling smart cities, and as a\nfoundation for further analysis of specific approaches about smart cities\nmodeling. Lastly, we also discuss the impact of our analysis for the\nModel-Driven Engineering community."}
{"id": "2508.16307", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2508.16307", "abs": "https://arxiv.org/abs/2508.16307", "authors": ["Jinsheng Ba", "Yuancheng Jiang", "Manuel Rigger"], "title": "Metamorphic Coverage", "comment": null, "summary": "Metamorphic testing is a widely used methodology that examines an expected\nrelation between pairs of executions to automatically find bugs, such as\ncorrectness bugs. We found that code coverage cannot accurately measure the\nextent to which code is validated and mutation testing is computationally\nexpensive for evaluating metamorphic testing methods. In this work, we propose\nMetamorphic Coverage (MC), a coverage metric that examines the distinct code\nexecuted by pairs of test inputs within metamorphic testing. Our intuition is\nthat, typically, a bug can be observed if the corresponding code is executed\nwhen executing either test input but not the other one, so covering more\ndifferential code covered by pairs of test inputs might be more likely to\nexpose bugs. While most metamorphic testing methods have been based on this\ngeneral intuition, our work defines and systematically evaluates MC on five\nwidely used metamorphic testing methods for testing database engines,\ncompilers, and constraint solvers. The code measured by MC overlaps with the\nbug-fix locations of 50 of 64 bugs found by metamorphic testing methods, and MC\nhas a stronger positive correlation with bug numbers than line coverage. MC is\n4x more sensitive than line coverage in distinguishing testing methods'\neffectiveness, and the average value of MC is 6x smaller than line coverage\nwhile still capturing the part of the program that is being tested. MC required\n359x less time than mutation testing. Based on a case study for an automated\ndatabase system testing approach, we demonstrate that when used for feedback\nguidance, MC significantly outperforms code coverage, by finding 41\\% more\nbugs. Consequently, this work might have broad applications for assessing\nmetamorphic testing methods and improving test-case generation."}
{"id": "2508.16318", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2508.16318", "abs": "https://arxiv.org/abs/2508.16318", "authors": ["Juan C. Alonso", "Alberto Martin-Lopez", "Sergio Segura", "Gabriele Bavota", "Antonio Ruiz-Cortés"], "title": "SATORI: Static Test Oracle Generation for REST APIs", "comment": "Accepted for publication at 40th IEEE/ACM International Conference on\n  Automated Software Engineering, ASE 2025", "summary": "REST API test case generation tools are evolving rapidly, with growing\ncapabilities for the automated generation of complex tests. However, despite\ntheir strengths in test data generation, these tools are constrained by the\ntypes of test oracles they support, often limited to crashes, regressions, and\nnoncompliance with API specifications or design standards. This paper\nintroduces SATORI (Static API Test ORacle Inference), a black-box approach for\ngenerating test oracles for REST APIs by analyzing their OpenAPI Specification.\nSATORI uses large language models to infer the expected behavior of an API by\nanalyzing the properties of the response fields of its operations, such as\ntheir name and descriptions. To foster its adoption, we extended the\nPostmanAssertify tool to automatically convert the test oracles reported by\nSATORI into executable assertions. Evaluation results on 17 operations from 12\nindustrial APIs show that SATORI can automatically generate up to hundreds of\nvalid test oracles per operation. SATORI achieved an F1-score of 74.3%,\noutperforming the state-of-the-art dynamic approach AGORA+ (69.3%)-which\nrequires executing the API-when generating comparable oracle types. Moreover,\nour findings show that static and dynamic oracle inference methods are\ncomplementary: together, SATORI and AGORA+ found 90% of the oracles in our\nannotated ground-truth dataset. Notably, SATORI uncovered 18 bugs in popular\nAPIs (Amadeus Hotel, Deutschebahn, FDIC, GitLab, Marvel, OMDb and Vimeo)\nleading to documentation updates by the API maintainers."}
{"id": "2508.16341", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2508.16341", "abs": "https://arxiv.org/abs/2508.16341", "authors": ["Sebastian Copei", "Oliver Hohlfeld", "Jens Kosiol"], "title": "The (C)omprehensive (A)rchitecture (P)attern (I)ntegration method: Navigating the sea of technology", "comment": null, "summary": "The technological landscape changes daily, making it nearly impossible for a\nsingle person to be aware of all trends or available tools that may or may not\nbe suitable for their software project. This makes tool selection and\narchitectural design decisions a complex problem, especially for large-scale\nsoftware systems. To tackle this issue, we introduce CAPI, the Comprehensive\nArchitecture Pattern Integration method that uses a diagnostic decision tree to\nsuggest architectural patterns depending on user needs. By suggesting patterns\ninstead of tools, the overall complexity for further decisions is lower as\nthere are fewer architectural patterns than tools due to the abstract nature of\npatterns. Moreover, since tools implement patterns, each non-proposed pattern\nreduces the number of tools to choose from, reducing complexity. We iteratively\ndeveloped CAPI, evaluating its understandability and usability in small studies\nwith academic participants. When satisfied with the outcome, we performed a\nuser-study with industry representatives to investigate the state-of-the-art in\ntechnology selection and the effectiveness of our proposed method. We find that\ntechnology selection is largely performed via trial and error, that CAPI is\nuniformly perceived as helpful, and that CAPI is able to reproduce the\nproductive architectural environments of our participants."}
{"id": "2508.16402", "categories": ["cs.SE", "cs.CL"], "pdf": "https://arxiv.org/pdf/2508.16402", "abs": "https://arxiv.org/abs/2508.16402", "authors": ["Zihan Wang", "Jiaze Chen", "Zhicheng Liu", "Markus Mak", "Yidi Du", "Geonsik Moon", "Luoqi Xu", "Aaron Tua", "Kunshuo Peng", "Jiayi Lu", "Mingfei Xia", "Boqian Zou", "Chenyang Ran", "Guang Tian", "Shoutai Zhu", "Yeheng Duan", "Zhenghui Kang", "Zhenxing Lin", "Shangshu Li", "Qiang Luo", "Qingshen Long", "Zhiyong Chen", "Yihan Xiao", "Yurong Wu", "Daoguang Zan", "Yuyi Fu", "Mingxuan Wang", "Ming Ding"], "title": "AetherCode: Evaluating LLMs' Ability to Win In Premier Programming Competitions", "comment": "15 pages", "summary": "Competitive programming has emerged as a critical benchmark for evaluating\nthe reasoning and coding capabilities of Large Language Models (LLMs). Despite\nimpressive progress on existing benchmarks, we argue that current evaluations\noverstate model proficiency, masking a substantial gap between LLMs and elite\nhuman programmers. This gap arises from two key limitations: insufficient\ndifficulty and scope of benchmark problems, and evaluation bias from\nlow-quality test cases. To address these shortcomings, we present AetherCode, a\nnew benchmark that draws problems from premier programming competitions such as\nIOI and ICPC, offering broader coverage and higher difficulty. AetherCode\nfurther incorporates comprehensive, expert-validated test suites built through\na hybrid of automated generation and human curation, ensuring rigorous and\nreliable assessment. By combining challenging problem design with robust\nevaluation, AetherCode provides a more faithful measure of LLM capabilities and\nsets a new standard for future research in code reasoning."}
{"id": "2508.16419", "categories": ["cs.SE", "cs.LG"], "pdf": "https://arxiv.org/pdf/2508.16419", "abs": "https://arxiv.org/abs/2508.16419", "authors": ["Akshay Mhatre", "Noujoud Nader", "Patrick Diehl", "Deepti Gupta"], "title": "LLM-GUARD: Large Language Model-Based Detection and Repair of Bugs and Security Vulnerabilities in C++ and Python", "comment": null, "summary": "Large Language Models (LLMs) such as ChatGPT-4, Claude 3, and LLaMA 4 are\nincreasingly embedded in software/application development, supporting tasks\nfrom code generation to debugging. Yet, their real-world effectiveness in\ndetecting diverse software bugs, particularly complex, security-relevant\nvulnerabilities, remains underexplored. This study presents a systematic,\nempirical evaluation of these three leading LLMs using a benchmark of\nfoundational programming errors, classic security flaws, and advanced,\nproduction-grade bugs in C++ and Python. The dataset integrates real code from\nSEED Labs, OpenSSL (via the Suresoft GLaDOS database), and PyBugHive, validated\nthrough local compilation and testing pipelines. A novel multi-stage,\ncontext-aware prompting protocol simulates realistic debugging scenarios, while\na graded rubric measures detection accuracy, reasoning depth, and remediation\nquality. Our results show that all models excel at identifying syntactic and\nsemantic issues in well-scoped code, making them promising for educational use\nand as first-pass reviewers in automated code auditing. Performance diminishes\nin scenarios involving complex security vulnerabilities and large-scale\nproduction code, with ChatGPT-4 and Claude 3 generally providing more nuanced\ncontextual analyses than LLaMA 4. This highlights both the promise and the\npresent constraints of LLMs in serving as reliable code analysis tools."}
{"id": "2508.16445", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2508.16445", "abs": "https://arxiv.org/abs/2508.16445", "authors": ["Sonia Nicoletti", "Paolo Ciancarini"], "title": "Using LLMs and Essence to Support Software Practice Adoption", "comment": null, "summary": "Recent advancements in natural language processing (NLP) have enabled the\ndevelopment of automated tools that support various domains, including software\nengineering. However, while NLP and artificial intelligence (AI) research has\nextensively focused on tasks such as code generation, less attention has been\ngiven to automating support for the adoption of best practices, the evolution\nof ways of working, and the monitoring of process health. This study addresses\nthis gap by exploring the integration of Essence, a standard and thinking\nframework for managing software engineering practices, with large language\nmodels (LLMs). To this end, a specialised chatbot was developed to assist\nstudents and professionals in understanding and applying Essence. The chatbot\nemploys a retrieval-augmented generation (RAG) system to retrieve relevant\ncontextual information from a curated knowledge base. Four different LLMs were\nused to create multiple chatbot configurations, each evaluated both as a base\nmodel and augmented with the RAG system. The system performance was evaluated\nthrough both the relevance of retrieved context and the quality of generated\nresponses. Comparative analysis against the general-purpose LLMs demonstrated\nthat the proposed system consistently outperforms its baseline counterpart in\ndomain-specific tasks. By facilitating access to structured software\nengineering knowledge, this work contributes to bridging the gap between\ntheoretical frameworks and practical application, potentially improving process\nmanagement and the adoption of software development practices. While further\nvalidation through user studies is required, these findings highlight the\npotential of LLM-based automation to enhance learning and decision-making in\nsoftware engineering."}
{"id": "2508.16499", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2508.16499", "abs": "https://arxiv.org/abs/2508.16499", "authors": ["Kazuki Kusama", "Honglin Shu", "Masanari Kondo", "Yasutaka Kamei"], "title": "How Small is Enough? Empirical Evidence of Quantized Small Language Models for Automated Program Repair", "comment": null, "summary": "Background: Large language models (LLMs) have greatly improved the accuracy\nof automated program repair (APR) methods. However, LLMs are constrained by\nhigh computational resource requirements. Aims: We focus on small language\nmodels (SLMs), which perform well even with limited computational resources\ncompared to LLMs. We aim to evaluate whether SLMs can achieve competitive\nperformance in APR tasks. Method: We conducted experiments on the QuixBugs\nbenchmark to compare the bug-fixing accuracy of SLMs and LLMs. We also analyzed\nthe impact of int8 quantization on APR performance. Results: The latest SLMs\ncan fix bugs as accurately as--or even more accurately than--LLMs. Also, int8\nquantization had minimal effect on APR accuracy while significantly reducing\nmemory requirements. Conclusions: SLMs present a viable alternative to LLMs for\nAPR, offering competitive accuracy with lower computational costs, and\nquantization can further enhance their efficiency without compromising\neffectiveness."}
{"id": "2508.16517", "categories": ["cs.SE", "cs.PL"], "pdf": "https://arxiv.org/pdf/2508.16517", "abs": "https://arxiv.org/abs/2508.16517", "authors": ["Bingkun Yao", "Ning Wang", "Xiangfeng Liu", "Yuxin Du", "Yuchen Hu", "Hong Gao", "Zhe Jiang", "Nan Guan"], "title": "ARSP: Automated Repair of Verilog Designs via Semantic Partitioning", "comment": null, "summary": "Debugging functional Verilog bugs consumes a significant portion of front-end\ndesign time. While Large Language Models (LLMs) have demonstrated great\npotential in mitigating this effort, existing LLM-based automated debugging\nmethods underperform on industrial-scale modules. A major reason for this is\nbug signal dilution in long contexts, where a few bug-relevant tokens are\noverwhelmed by hundreds of unrelated lines, diffusing the model's attention. To\naddress this issue, we introduce ARSP, a two-stage system that mitigates\ndilution via semantics-guided fragmentation. A Partition LLM splits a module\ninto semantically tight fragments; a Repair LLM patches each fragment; edits\nare merged without altering unrelated logic. A synthetic data framework\ngenerates fragment-level training pairs spanning bug types, design styles, and\nscales to supervise both models. Experiments show that ARSP achieves 77.92%\npass@1 and 83.88% pass@5, outperforming mainstream commercial LLMs including\nClaude-3.7 and SOTA automated Verilog debugging tools Strider and MEIC. Also,\nsemantic partitioning improves pass@1 by 11.6% and pass@5 by 10.2% over\nwhole-module debugging, validating the effectiveness of fragment-level scope\nreduction in LLM-based Verilog debugging."}
{"id": "2508.16125", "categories": ["cs.PL", "cs.SE"], "pdf": "https://arxiv.org/pdf/2508.16125", "abs": "https://arxiv.org/abs/2508.16125", "authors": ["Zhenyang Xu", "Hongxu Xu", "Yongqiang Tian", "Xintong Zhou", "Chengnian Sun"], "title": "Leveraging Large Language Models to Detect Missed Peephole Optimizations", "comment": null, "summary": "By replacing small, suboptimal instruction sequences within programs with a\nmore efficient equivalent, peephole optimization can not only directly optimize\ncode size and performance, but also potentially enables further transformations\nin the subsequent optimization pipeline. Although peephole optimization is a\ncritical class of compiler optimizations, discovering new and effective\npeephole optimizations is challenging as the instruction sets can be extremely\ncomplex and diverse. Previous methods either do not scale well or can only\ncapture a limited subset of peephole optimizations. In this work, we leverage\nLarge Language Models (LLMs) to detect missed peephole optimizations. We\npropose Lampo, a novel automated framework that synergistically combines the\ncreative but unreliable code optimization ability of LLMs with rigorous\ncorrectness verification performed by translation validation tools, integrated\nin a feedback-driven iterative process. Through a comprehensive evaluation\nwithin LLVM ecosystems, we show that Lampo can successfully detect up to 17 out\nof 25 previously reported missed optimizations in LLVM on average, and that 22\nout of 25 can potentially be found by Lampo with different LLMs. For\ncomparison, the state-of-the-art superoptimizer for LLVM, Souper, identified 15\nof them. Moreover, within seven months of development and intermittent\nexperiments, Lampo found 26 missed peephole optimizations, 15 of which have\nbeen confirmed and 6 already fixed. These results demonstrate Lampo's strong\npotential in continuously detecting missed peephole optimizations."}
{"id": "2508.16384", "categories": ["cs.FL", "cs.SE"], "pdf": "https://arxiv.org/pdf/2508.16384", "abs": "https://arxiv.org/abs/2508.16384", "authors": ["Gabriel Dengler", "Sven Apel", "Holger Hermanns"], "title": "Automata Learning -- Expect Delays!", "comment": "Accepted at Integrated Formal Methods (iFM) 2025", "summary": "This paper studies active automata learning (AAL) in the presence of\nstochastic delays. We consider Mealy machines that have stochastic delays\nassociated with each transition and explore how the learner can efficiently\narrive at faithful estimates of those machines, the precision of which\ncrucially relies on repetitive sampling of transition delays. While it is\npossible to na\\\"ively integrate the delay sampling into AAL algorithms such as\n$L^*$, this leads to considerable oversampling near the root of the state\nspace. We address this problem by separating conceptually the learning of\nbehavior and delays such that the learner uses the information gained while\nlearning the logical behavior to arrive at efficient input sequences for\ncollecting the needed delay samples. We put emphasis on treating cases in which\nidentical input/output behaviors might stem from distinct delay\ncharacteristics. Finally, we provide empirical evidence that our method\noutperforms the na\\\"ive baseline across a wide range of benchmarks and\ninvestigate its applicability in a realistic setting by studying the join order\nin a relational database."}

{"id": "2507.18792", "categories": ["cs.PL", "cs.SE"], "pdf": "https://arxiv.org/pdf/2507.18792", "abs": "https://arxiv.org/abs/2507.18792", "authors": ["Zixu Zhou"], "title": "Decompiling Rust: An Empirical Study of Compiler Optimizations and Reverse Engineering Challenges", "comment": null, "summary": "Decompiling Rust binaries is challenging due to the language's rich type\nsystem, aggressive compiler optimizations, and widespread use of high-level\nabstractions. In this work, we conduct a benchmark-driven evaluation of\ndecompilation quality across core Rust features and compiler build modes. Our\nautomated scoring framework shows that generic types, trait methods, and error\nhandling constructs significantly reduce decompilation quality, especially in\nrelease builds. Through representative case studies, we analyze how specific\nlanguage constructs affect control flow, variable naming, and type information\nrecovery. Our findings provide actionable insights for tool developers and\nhighlight the need for Rust-aware decompilation strategies."}
{"id": "2507.18885", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2507.18885", "abs": "https://arxiv.org/abs/2507.18885", "authors": ["Qiyuan Xu", "Renxi Wang", "Haonan Li", "David Sanan", "Conrad Watt"], "title": "IsaMini: Redesigned Isabelle Proof Lanugage for Machine Learning", "comment": null, "summary": "Neural Theorem Proving (NTP) employs deep learning methods, particularly\nLarge Language Models (LLMs), to automate formal proofs in proof assistants.\nThis approach holds promise for reducing the dramatic labor costs or\ncomputation costs required in proof engineering, which is fundamental to formal\nverification and other software engineering methods. The paper explores the\npotential of improving NTP by redesigning the proof language, given that LLMs'\ncapabilities depend highly on representations. We introduce \\emph{MiniLang}, a\nredesigned proof language for Isabelle/HOL incorporating an improved version of\nSledgehammer. Experiments show MiniLang benefits two fine-tuned LLMs by\nimproving the success rate on the PISA benchmark by up to 29\\% in comparison to\ngeneration of Isar proof script. The success rate under one attempt (so-called\n\\emph{pass@1}) reaches 69.1\\%, exceeding the previous Baldur's pass@64\n(65.7\\%); The pass@8 reaches 79.2\\%, exceeding the state-of-the-art on PISA\n(71.0\\%) achieved by Magnushammer."}
{"id": "2507.19015", "categories": ["cs.PL", "cs.LO", "cs.SE"], "pdf": "https://arxiv.org/pdf/2507.19015", "abs": "https://arxiv.org/abs/2507.19015", "authors": ["Samuel Xifaras", "Panagiotis Manolios", "Andrew T. Walter", "William Robertson"], "title": "An Enumerative Embedding of the Python Type System in ACL2s", "comment": "In Proceedings ACL2 2025, arXiv:2507.18567", "summary": "Python is a high-level interpreted language that has become an industry\nstandard in a wide variety of applications. In this paper, we take a first step\ntowards using ACL2s to reason about Python code by developing an embedding of a\nsubset of the Python type system in ACL2s. The subset of Python types we\nsupport includes many of the most commonly used type annotations as well as\nuser-defined types comprised of supported types. We provide ACL2s definitions\nof these types, as well as defdata enumerators that are customized to provide\ncode coverage and identify errors in Python programs. Using the ACL2s\nembedding, we can generate instances of types that can then be used as inputs\nto fuzz Python programs, which allows us to identify bugs in Python code that\nare not detected by state-of-the-art Python type checkers. We evaluate our work\nagainst four open-source repositories, extracting their type information and\ngenerating inputs for fuzzing functions with type signatures that are in the\nsupported subset of Python types. Note that we only use the type signatures of\nfunctions to generate inputs and treat the bodies of functions as black boxes.\nWe measure code coverage, which ranges from about 68% to more than 80%, and\nidentify code patterns that hinder coverage such as complex branch conditions\nand external file system dependencies. We conclude with a discussion of the\nresults and recommendations for future work."}
{"id": "2507.19176", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2507.19176", "abs": "https://arxiv.org/abs/2507.19176", "authors": ["Weijun Chen", "Yuxi Fu", "Huan Long"], "title": "A Programming Language for Feasible Solutions", "comment": null, "summary": "Runtime efficiency and termination are crucial properties in the studies of\nprogram verification. Instead of dealing with these issues in an ad hoc manner,\nit would be useful to develop a robust framework in which such properties are\nguaranteed by design. This paper introduces a new imperative programming\nlanguage whose design is grounded in a static type system that ensures the\nfollowing equivalence property: All definable programs are guaranteed to run in\npolynomial time; Conversely, all problems solvable in polynomial time can be\nsolved by some programs of the language. The contribution of this work is\ntwofold. On the theoretical side, the foundational equivalence property is\nestablished, and the proof of the equivalence theorem is non-trivial. On the\npractical side, a programming approach is proposed that can streamline program\nanalysis and verification for feasible computations. An interpreter for the\nlanguage has been implemented, demonstrating the feasibility of the approach in\npractice."}
{"id": "2507.18718", "categories": ["cs.LO", "F.4.1"], "pdf": "https://arxiv.org/pdf/2507.18718", "abs": "https://arxiv.org/abs/2507.18718", "authors": ["Ronald Fagin", "Neil Immerman", "Phokion Kolaitis", "Jonathan Lenchner", "Rik Sengupta"], "title": "Who Wins the Multi-Structural Game?", "comment": "27 pages, 7 figures", "summary": "Combinatorial games played between two players, called Spoiler and\nDuplicator, have often been used to capture syntactic properties of formal\nlogical languages. For instance, the widely used Ehrenfeucht-Fra\\\"iss\\'e (EF)\ngame captures the syntactic measure of quantifier rank of first-order formulas.\nFor every such game, there is an associated natural decision problem: \"given an\ninstance of the game, does Spoiler win the game on that instance?\" For EF\ngames, this problem was shown to be PSPACE-complete by Pezzoli in 1998. In this\npresent paper, we show that the same problem for the *multi-structural* (MS)\ngames of recent interest is PSPACE-hard, but contained in NEXPTIME. In the\nprocess, we also resolve an open problem posed by Pezzoli about the dependence\nof the hardness results for EF games on the arity of the schema under\nconsideration. Our techniques combine adaptations of Pezzoli's constructions\ntogether with insights from the theory of inapproximability of optimization\nproblems, as well as the recently developed technique of parallel play for MS\ngames."}
{"id": "2507.18726", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.18726", "abs": "https://arxiv.org/abs/2507.18726", "authors": ["Sadia Afrin Mim"], "title": "Exploring the Landscape of Fairness Interventions in Software Engineering", "comment": null, "summary": "Current developments in AI made it broadly significant for reducing human\nlabor and expenses across several essential domains, including healthcare and\nfinance. However, the application of AI in the actual world poses multiple\nrisks and disadvantages due to potential risk factors in data (e.g., biased\ndataset). Practitioners developed a number of fairness interventions for\naddressing these kinds of problems. The paper acts as a survey, summarizing the\nvarious studies and approaches that have been developed to address fairness\nissues"}
{"id": "2507.18755", "categories": ["cs.SE", "cs.AI", "cs.PL"], "pdf": "https://arxiv.org/pdf/2507.18755", "abs": "https://arxiv.org/abs/2507.18755", "authors": ["Chandra Maddila", "Adam Tait", "Claire Chang", "Daniel Cheng", "Nauman Ahmad", "Vijayaraghavan Murali", "Marshall Roch", "Arnaud Avondet", "Aaron Meltzer", "Victor Montalvao", "Michael Hopko", "Chris Waterson", "Parth Thakkar", "Renuka Fernandez", "Kristian Kristensen", "Sivan Barzily", "Sherry Chen", "Rui Abreu", "Nachiappan Nagappan", "Payam Shodjai", "Killian Murphy", "James Everingham", "Aparna Ramani", "Peter C. Rigby"], "title": "Agentic Program Repair from Test Failures at Scale: A Neuro-symbolic approach with static analysis and test execution feedback", "comment": null, "summary": "Aim: With the advent of LLMs, sophisticated agentic program repair has become\nviable at large organizations with large codebases. In this work, we develop an\nEngineering Agent that fixes the source code based on test failures at scale\nacross diverse software offerings internally.\n  Method: Using Llama as the base, we employ the ReAct harness to develop an\nagent. We start with a test failure that was triaged by a rule-based test\nfailure bot. We then set up an agentic harness and allow the agent to reason\nand run a set of 15 actions from reading a file to generating a patch. We\nprovide feedback to the agent through static analysis and test failures so it\ncan refine its solution. We leverage an LLM-as-a-Judge to ensure that the patch\nconforms to the standards followed by a human review to land fixes.\n  Benchmark Findings: We curated offline benchmarks for our patch generator,\nthe Engineering Agent loop, and the LLM-as-a-Judge. In offline evaluations we\nfound that a specialized 70B model is highly competitive with the much larger\nbut vanilla Llama-405B. In an ablation study, we found that the ReAct harness\n(neural model) benefited from the symbolic information from static analysis\ntools and test execution traces. A model that strikes a balance between the\nsolve rate and error rate vs the cost and latency has a benchmark solve rate of\n42.3% using an average 11.8 feedback iterations.\n  Production Findings: In a three month period, 80% of the generated fixes were\nreviewed, of which 31.5% were landed (25.5% of the total number of generated\nfixes).\n  Feedback from Engineers: We used open coding to extract qualitative themes\nfrom engineers' feedback. We saw positive feedback in the form of quick\napprovals, gratitude, and surprise. We also found mixed feedback when the\nEngineering Agent's solution was partially correct and it served as a good\nstarting point."}
{"id": "2507.18798", "categories": ["cs.LO"], "pdf": "https://arxiv.org/pdf/2507.18798", "abs": "https://arxiv.org/abs/2507.18798", "authors": ["Victor Barroso-Nascimento"], "title": "Higher-order Kripke models for intuitionistic and non-classical modal logics", "comment": null, "summary": "This paper introduces higher-order Kripke models, a generalization of\nstandard Kripke models that is remarkably close to Kripke's original idea -\nboth mathematically and conceptually. Standard Kripke models are now considered\n$0$-ary models, whereas an $n$-ary model for $n > 0$ is a model whose set of\nobjects (''possible worlds'') contains only $(n-1)$-ary Kripke models. Models\nwith infinitely many layers are also considered. This framework is obtained by\npromoting a radical change of perspective in how modal semantics for\nnon-classical logics are defined: just like classical modalities are obtained\nthrough use of an accessibility relation between classical propositional\nmodels, non-classical modalities are now obtained through use of an\naccessibility relation between non-classical propositional models (even when\nthey are Kripke models already). The paper introduces the new models after\ndealing specifically with the case of intuitionistic modal logic. It is shown\nthat, depending on which intuitionistic $0$-ary propositional models are\nallowed, we may obtain $1$-ary models equivalent to either birelational models\nfor $IK$ or for a new logic called $MK$. Those $1$-ary models have an intuitive\nreading that adds to the interpretation of intuitionistic models in terms of\n''timelines'' the concept of ''alternative timelines''. More generally, the\n$1$-ary models can be read as defining a concept of ''alternative'' for any\nsubstantive interpretation of the $0$-ary models. The semantic clauses for\nnecessity and possibility of $MK$ are also modular and can be used to obtain\nsimilar modal semantics for every non-classical logic, each of which can be\nprovided with a similar intuitive reading. After intuitionistic modal logic is\ndealt with, the general structure of High-order Kripke Models and some of its\nvariants are defined, and a series of conjectures about their properties are\nstated."}
{"id": "2507.18755", "categories": ["cs.SE", "cs.AI", "cs.PL"], "pdf": "https://arxiv.org/pdf/2507.18755", "abs": "https://arxiv.org/abs/2507.18755", "authors": ["Chandra Maddila", "Adam Tait", "Claire Chang", "Daniel Cheng", "Nauman Ahmad", "Vijayaraghavan Murali", "Marshall Roch", "Arnaud Avondet", "Aaron Meltzer", "Victor Montalvao", "Michael Hopko", "Chris Waterson", "Parth Thakkar", "Renuka Fernandez", "Kristian Kristensen", "Sivan Barzily", "Sherry Chen", "Rui Abreu", "Nachiappan Nagappan", "Payam Shodjai", "Killian Murphy", "James Everingham", "Aparna Ramani", "Peter C. Rigby"], "title": "Agentic Program Repair from Test Failures at Scale: A Neuro-symbolic approach with static analysis and test execution feedback", "comment": null, "summary": "Aim: With the advent of LLMs, sophisticated agentic program repair has become\nviable at large organizations with large codebases. In this work, we develop an\nEngineering Agent that fixes the source code based on test failures at scale\nacross diverse software offerings internally.\n  Method: Using Llama as the base, we employ the ReAct harness to develop an\nagent. We start with a test failure that was triaged by a rule-based test\nfailure bot. We then set up an agentic harness and allow the agent to reason\nand run a set of 15 actions from reading a file to generating a patch. We\nprovide feedback to the agent through static analysis and test failures so it\ncan refine its solution. We leverage an LLM-as-a-Judge to ensure that the patch\nconforms to the standards followed by a human review to land fixes.\n  Benchmark Findings: We curated offline benchmarks for our patch generator,\nthe Engineering Agent loop, and the LLM-as-a-Judge. In offline evaluations we\nfound that a specialized 70B model is highly competitive with the much larger\nbut vanilla Llama-405B. In an ablation study, we found that the ReAct harness\n(neural model) benefited from the symbolic information from static analysis\ntools and test execution traces. A model that strikes a balance between the\nsolve rate and error rate vs the cost and latency has a benchmark solve rate of\n42.3% using an average 11.8 feedback iterations.\n  Production Findings: In a three month period, 80% of the generated fixes were\nreviewed, of which 31.5% were landed (25.5% of the total number of generated\nfixes).\n  Feedback from Engineers: We used open coding to extract qualitative themes\nfrom engineers' feedback. We saw positive feedback in the form of quick\napprovals, gratitude, and surprise. We also found mixed feedback when the\nEngineering Agent's solution was partially correct and it served as a good\nstarting point."}
{"id": "2507.19012", "categories": ["cs.LO", "cs.PL"], "pdf": "https://arxiv.org/pdf/2507.19012", "abs": "https://arxiv.org/abs/2507.19012", "authors": ["Alessandro Coglio", "Eric McCarthy"], "title": "A Formalization of the Yul Language and Some Verified Yul Code Transformations", "comment": "In Proceedings ACL2 2025, arXiv:2507.18567", "summary": "Yul is an intermediate language used in the compilation of the Solidity\nprogramming language for Ethereum smart contracts. The compiler applies\ncustomizable sequences of transformations to Yul code. To help ensure the\ncorrectness of these transformations and their sequencing, we used the ACL2\ntheorem prover to develop a formalization of the syntax and semantics of Yul,\nproofs relating static and dynamic semantics, a formalization of some Yul code\ntransformations, and correctness proofs for these transformations."}
{"id": "2507.19008", "categories": ["cs.LO", "F.4.1"], "pdf": "https://arxiv.org/pdf/2507.19008", "abs": "https://arxiv.org/abs/2507.19008", "authors": ["Grant Jurgensen"], "title": "A Proof of the Schröder-Bernstein Theorem in ACL2", "comment": "In Proceedings ACL2 2025, arXiv:2507.18567", "summary": "The Schr\\\"oder-Bernstein theorem states that, for any two sets P and Q, if\nthere exists an injection from P to Q and an injection from Q to P, then there\nmust exist a bijection between the two sets. Classically, it follows that the\nordering of the cardinal numbers is antisymmetric. We describe a formulation\nand verification of the Schr\\\"oder-Bernstein theorem in ACL2 following a\nwell-known proof, introducing a theory of chains to define a non-computable\nwitness."}
{"id": "2507.18812", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2507.18812", "abs": "https://arxiv.org/abs/2507.18812", "authors": ["Yiping Jia", "Zhen Ming Jiang", "Shayan Noei", "Ying Zou"], "title": "MemoCoder: Automated Function Synthesis using LLM-Supported Agents", "comment": null, "summary": "With the widespread adoption of Large Language Models (LLMs) such as GitHub\nCopilot and ChatGPT, developers increasingly rely on AI-assisted tools to\nsupport code generation. While LLMs can generate syntactically correct\nsolutions for well-structured programming tasks, they often struggle with\nchallenges that require iterative debugging, error handling, or adaptation to\ndiverse problem structures. Existing approaches such as fine-tuning or\nself-repair strategies either require costly retraining or lack mechanisms to\naccumulate and reuse knowledge from previous attempts.\n  To address these limitations, we propose MemoCoder, a multi-agent framework\nthat enables collaborative problem solving and persistent learning from past\nfixes. At the core of MemoCoder is a Fixing Knowledge Set, which stores\nsuccessful repairs and supports retrieval for future tasks. A central Mentor\nAgent supervises the repair process by identifying recurring error patterns and\nrefining high-level fixing strategies, providing a novel supervisory role that\nguides the self-repair loop. We evaluate MemoCoder across three public\nbenchmarks -- MBPP, HumanEval, and LiveCodeBench -- spanning a range of problem\ncomplexities. Experimental results show that MemoCoder consistently outperforms\nboth zero-shot prompting and a Self-Repair strategy, with improvements ranging\nfrom 3.1% to 12.1% in Pass@10 and from 1.4% to 14.5% in Pass@50, demonstrating\nits effectiveness in iterative refinement and knowledge-guided code generation."}
{"id": "2507.19271", "categories": ["cs.SE", "cs.AI", "cs.PL"], "pdf": "https://arxiv.org/pdf/2507.19271", "abs": "https://arxiv.org/abs/2507.19271", "authors": ["Igli Begolli", "Meltem Aksoy", "Daniel Neider"], "title": "Fine-Tuning Multilingual Language Models for Code Review: An Empirical Study on Industrial C# Projects", "comment": null, "summary": "Code review is essential for maintaining software quality but often\ntime-consuming and cognitively demanding, especially in industrial\nenvironments. Recent advancements in language models (LMs) have opened new\navenues for automating core review tasks. This study presents the empirical\nevaluation of monolingual fine-tuning on the performance of open-source LMs\nacross three key automated code review tasks: Code Change Quality Estimation,\nReview Comment Generation, and Code Refinement. We fine-tuned three distinct\nmodels, CodeReviewer, CodeLlama-7B, and DeepSeek-R1-Distill, on a C\\# specific\ndataset combining public benchmarks with industrial repositories. Our study\ninvestigates how different configurations of programming languages and natural\nlanguages in the training data affect LM performance, particularly in comment\ngeneration. Additionally, we benchmark the fine-tuned models against an\nautomated software analysis tool (ASAT) and human reviewers to evaluate their\npractical utility in real-world settings. Our results show that monolingual\nfine-tuning improves model accuracy and relevance compared to multilingual\nbaselines. While LMs can effectively support code review workflows, especially\nfor routine or repetitive tasks, human reviewers remain superior in handling\nsemantically complex or context-sensitive changes. Our findings highlight the\nimportance of language alignment and task-specific adaptation in optimizing LMs\nfor automated code review."}
{"id": "2507.19009", "categories": ["cs.LO"], "pdf": "https://arxiv.org/pdf/2507.19009", "abs": "https://arxiv.org/abs/2507.19009", "authors": ["Carl Kwan"], "title": "RV32I in ACL2", "comment": "In Proceedings ACL2 2025, arXiv:2507.18567", "summary": "We present a simple ACL2 simulator for the RISC-V 32-bit base instruction set\narchitecture, written in the operational semantics style. Like many other ISA\nmodels, our RISC-V state object is a single-threaded object and we prove\nread-over-write, write-over-write, writing-the-read, and state well-formedness\ntheorems. Unlike some other models, we separate the instruction decoding\nfunctions from their semantic counterparts. Accordingly, we verify encoding /\ndecoding functions for each RV32I instruction, the proofs for which are\nentirely automatic."}
{"id": "2507.18833", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.18833", "abs": "https://arxiv.org/abs/2507.18833", "authors": ["Wenyuan Jiang", "Diany Pressato", "Harsh Darji", "Thibaud Lutellier"], "title": "Exploring the Jupyter Ecosystem: An Empirical Study of Bugs and Vulnerabilities", "comment": null, "summary": "Background. Jupyter notebooks are one of the main tools used by data\nscientists. Notebooks include features (configuration scripts, markdown,\nimages, etc.) that make them challenging to analyze compared to traditional\nsoftware. As a result, existing software engineering models, tools, and studies\ndo not capture the uniqueness of Notebook's behavior. Aims. This paper aims to\nprovide a large-scale empirical study of bugs and vulnerabilities in the\nNotebook ecosystem. Method. We collected and analyzed a large dataset of\nNotebooks from two major platforms. Our methodology involved quantitative\nanalyses of notebook characteristics (such as complexity metrics, contributor\nactivity, and documentation) to identify factors correlated with bugs.\nAdditionally, we conducted a qualitative study using grounded theory to\ncategorize notebook bugs, resulting in a comprehensive bug taxonomy. Finally,\nwe analyzed security-related commits and vulnerability reports to assess risks\nassociated with Notebook deployment frameworks. Results. Our findings highlight\nthat configuration issues are among the most common bugs in notebook documents,\nfollowed by incorrect API usage. Finally, we explore common vulnerabilities\nassociated with popular deployment frameworks to better understand risks\nassociated with Notebook development. Conclusions. This work highlights that\nnotebooks are less well-supported than traditional software, resulting in more\ncomplex code, misconfiguration, and poor maintenance."}
{"id": "2507.19010", "categories": ["cs.LO", "cs.SC"], "pdf": "https://arxiv.org/pdf/2507.19010", "abs": "https://arxiv.org/abs/2507.19010", "authors": ["Mayank Manjrekar"], "title": "On Automating Proofs of Multiplier Adder Trees using the RTL Books", "comment": "In Proceedings ACL2 2025, arXiv:2507.18567", "summary": "We present an experimental, verified clause processor ctv-cp that fits into\nthe framework used at Arm for formal verification of arithmetic hardware\ndesigns. This largely automates the ACL2 proof development effort for integer\nmultiplier modules that exist in designs ranging from floating-point division\nto matrix multiplication."}
{"id": "2507.18957", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.18957", "abs": "https://arxiv.org/abs/2507.18957", "authors": ["Jianming Chang", "Jieke Shi", "Yunbo Lyu", "Xin Zhou", "Lulu Wang", "Zhou Yang", "Bixin Li", "David Lo"], "title": "SLICEMATE: Accurate and Scalable Static Program Slicing via LLM-Powered Agents", "comment": null, "summary": "Static program slicing, which extracts the executable portions of a program\nthat affect the values at a specific location, supports many software analysis\ntasks such as debugging and security auditing. However, traditional slicing\ntools rely on computationally expensive reachability analysis over dependency\ngraphs, which struggle to scale to large programs and often fail to handle code\nwith incomplete syntax. Recently emerged learning-based methods, while more\nrobust to such cases, still fall short of achieving comparable performance to\ntraditional methods on well-formed code.\n  In this work, we propose SliceMate, a novel static program slicing solution\npowered by Large Language Model (LLM) agents. It bypasses the need for explicit\ndependency graph construction and achieving superior slicing accuracy.\nConcretely, SliceMate integrates three specialized agents: (1) a synthesis\nagent that produces candidate slices by incrementally expanding the scan scope\nacross functions and files guided by LLM-inferred dependencies; (2) a\nverification agent that performs conciseness and completeness checks of the\ncandidate slices, detecting missing or irrelevant statements; and (3) a\nrefinement agent that repairs the slices with minimal edits in accordance with\nthe verification results. These agents are orchestrated by a control module\nthat ensures timely convergence and outputs high-quality slices without manual\nintervention. For rigorous evaluation, we construct a new and high-quality\nbenchmark, SliceBench, comprising 2,200 manually annotated Java and Python\nprograms, with program lengths ranging from 5 to 8,577 lines, significantly\nlarger than those in existing slicing benchmarks. Experimental results show\nthat SliceMate greatly outperforms both traditional and learning-based slicing\ntools."}
{"id": "2507.19012", "categories": ["cs.LO", "cs.PL"], "pdf": "https://arxiv.org/pdf/2507.19012", "abs": "https://arxiv.org/abs/2507.19012", "authors": ["Alessandro Coglio", "Eric McCarthy"], "title": "A Formalization of the Yul Language and Some Verified Yul Code Transformations", "comment": "In Proceedings ACL2 2025, arXiv:2507.18567", "summary": "Yul is an intermediate language used in the compilation of the Solidity\nprogramming language for Ethereum smart contracts. The compiler applies\ncustomizable sequences of transformations to Yul code. To help ensure the\ncorrectness of these transformations and their sequencing, we used the ACL2\ntheorem prover to develop a formalization of the syntax and semantics of Yul,\nproofs relating static and dynamic semantics, a formalization of some Yul code\ntransformations, and correctness proofs for these transformations."}
{"id": "2507.18982", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.18982", "abs": "https://arxiv.org/abs/2507.18982", "authors": ["Amir Hossain Raaj", "Fairuz Nawer Meem", "Sadia Afrin Mim"], "title": "Classifying Issues in Open-source GitHub Repositories", "comment": null, "summary": "GitHub is the most widely used platform for software maintenance in the\nopen-source community. Developers report issues on GitHub from time to time\nwhile facing difficulties. Having labels on those issues can help developers\neasily address those issues with prior knowledge of labels. However, most of\nthe GitHub repositories do not maintain regular labeling for the issues. The\ngoal of this work is to classify issues in the open-source community using ML\n\\& DNN models. There are thousands of open-source repositories on GitHub. Some\nof the repositories label their issues properly whereas some of them do not.\nWhen issues are pre-labeled, the problem-solving process and the immediate\nassignment of corresponding personnel are facilitated for the team, thereby\nexpediting the development process. In this work, we conducted an analysis of\nprominent GitHub open-source repositories. We classified the issues in some\ncommon labels which are: API, Documentation, Enhancement, Question, Easy,\nHelp-wanted, Dependency, CI, Waiting for OP's response, Test, Bug, etc. Our\nstudy shows that DNN models outperf"}
{"id": "2507.19013", "categories": ["cs.LO", "cs.NI"], "pdf": "https://arxiv.org/pdf/2507.19013", "abs": "https://arxiv.org/abs/2507.19013", "authors": ["Ankit Kumar", "Panagiotis Manolios"], "title": "A Formalization of the Correctness of the Floodsub Protocol", "comment": "In Proceedings ACL2 2025, arXiv:2507.18567", "summary": "Floodsub is a simple, robust and popular peer-to-peer publish/subscribe\n(pubsub) protocol, where nodes can arbitrarily leave or join the network,\nsubscribe to or unsubscribe from topics and forward newly received messages to\nall of their neighbors, except the sender or the originating peer. To show the\ncorrectness of Floodsub, we propose its specification: Broadcastsub, in which\nimplementation details like network connections and neighbor subscriptions are\nelided. To show that Floodsub does really implement Broadcastsub, one would\nhave to show that the two systems have related infinite computations. We prove\nthis by reasoning locally about states and their successors using Well-Founded\nSimulation (WFS). In this paper, we focus on the mechanization of a proof which\nshows that Floodsub is a simulation refinement of Broadcastsub using WFS. To\nthe best of our knowledge, ours is the first mechanized refinement-based\nverification of a real world pubsub protocol."}
{"id": "2507.19027", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.19027", "abs": "https://arxiv.org/abs/2507.19027", "authors": ["Aleksi Huotala", "Miikka Kuutila", "Mika Mäntylä"], "title": "SESR-Eval: Dataset for Evaluating LLMs in the Title-Abstract Screening of Systematic Reviews", "comment": "12 pages (10 + 2 pages for references)", "summary": "Background: The use of large language models (LLMs) in the title-abstract\nscreening process of systematic reviews (SRs) has shown promising results, but\nsuffers from limited performance evaluation. Aims: Create a benchmark dataset\nto evaluate the performance of LLMs in the title-abstract screening process of\nSRs. Provide evidence whether using LLMs in title-abstract screening in\nsoftware engineering is advisable. Method: We start with 169 SR research\nartifacts and find 24 of those to be suitable for inclusion in the dataset.\nUsing the dataset we benchmark title-abstract screening using 9 LLMs. Results:\nWe present the SESR-Eval (Software Engineering Systematic Review Evaluation)\ndataset containing 34,528 labeled primary studies, sourced from 24 secondary\nstudies published in software engineering (SE) journals. Most LLMs performed\nsimilarly and the differences in screening accuracy between secondary studies\nare greater than differences between LLMs. The cost of using an LLM is\nrelatively low - less than $40 per secondary study even for the most expensive\nmodel. Conclusions: Our benchmark enables monitoring AI performance in the\nscreening task of SRs in software engineering. At present, LLMs are not yet\nrecommended for automating the title-abstract screening process, since accuracy\nvaries widely across secondary studies, and no LLM managed a high recall with\nreasonable precision. In future, we plan to investigate factors that influence\nLLM screening performance between studies."}
{"id": "2507.19014", "categories": ["cs.LO", "D.2.4"], "pdf": "https://arxiv.org/pdf/2507.19014", "abs": "https://arxiv.org/abs/2507.19014", "authors": ["Andrew T. Walter", "Panagiotis Manolios"], "title": "An ACL2s Interface to Z3", "comment": "In Proceedings ACL2 2025, arXiv:2507.18567", "summary": "We present Lisp-Z3, an extension to the ACL2s systems programming framework\n(ASPF) that supports the use of the Z3 satisfiability modulo theories (SMT)\nsolver. Lisp-Z3 allows one to develop tools written using the full feature set\nof Common Lisp that can use both ACL2/s (either ACL2 or ACL2s) and Z3 as\nservices, combining the power of SMT and interactive theorem proving. Lisp-Z3\nis usable by anyone who would like to interact with Z3 from Common Lisp, as it\ndoes not depend on the availability of ACL2/s. We discuss the use of Lisp-Z3 in\nthree applications. The first is a Sudoku solver. The second is SeqSolve, a\nstring solver which solved a larger number of benchmark problems more quickly\nthan any other existing solver at the time of its publishing. Finally, Lisp-Z3\nwas also used in the context of hardware-in-the-loop fuzzing of wireless\nrouters, where low latency was an important goal. The latter two applications\nleveraged the ability of Lisp-Z3 to integrate Z3 with ACL2s code. We have\nfurther plans to use Lisp-Z3 inside of ACL2s to provide more powerful automated\nsupport for dependent types, and in particular more efficient generation of\ncounterexamples to properties involving dependent types. This paper describes\nthe usage and implementation of Lisp-Z3, as well as an evaluation of its use in\nthe aforementioned applications."}
{"id": "2507.19113", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.19113", "abs": "https://arxiv.org/abs/2507.19113", "authors": ["Liliana Pasquale", "Azzurra Ragone", "Emanuele Piemontese", "Armin Amiri Darban"], "title": "Exploring the Use of LLMs for Requirements Specification in an IT Consulting Company", "comment": "11 pages, 5 figures. Accepted for presentation at the Industrial\n  Innovation Track of the 33rd IEEE International Requirements Engineering\n  Conference (RE 2025), Valencia, Spain", "summary": "In practice, requirements specification remains a critical challenge. The\nknowledge necessary to generate a specification can often be fragmented across\ndiverse sources (e.g., meeting minutes, emails, and high-level product\ndescriptions), making the process cumbersome and time-consuming. In this paper,\nwe report our experience using large language models (LLMs) in an IT consulting\ncompany to automate the requirements specification process. In this company,\nrequirements are specified using a Functional Design Specification (FDS), a\ndocument that outlines the functional requirements and features of a system,\napplication, or process. We provide LLMs with a summary of the requirements\nelicitation documents and FDS templates, prompting them to generate Epic FDS\n(including high-level product descriptions) and user stories, which are\nsubsequently compiled into a complete FDS document. We compared the correctness\nand quality of the FDS generated by three state-of-the-art LLMs against those\nproduced by human analysts. Our results show that LLMs can help automate and\nstandardize the requirements specification, reducing time and human effort.\nHowever, the quality of LLM-generated FDS highly depends on inputs and often\nrequires human revision. Thus, we advocate for a synergistic approach in which\nan LLM serves as an effective drafting tool while human analysts provide the\ncritical contextual and technical oversight necessary for high-quality\nrequirements engineering (RE) documentation."}
{"id": "2507.19061", "categories": ["cs.LO"], "pdf": "https://arxiv.org/pdf/2507.19061", "abs": "https://arxiv.org/abs/2507.19061", "authors": ["Alice Tarzariol", "Marco Maratea", "Mauro Vallati"], "title": "A CASP-based Solution for Traffic Signal Optimisation", "comment": "To appear in Theory and Practice of Logic Programming (TPLP),\n  Proceedings of ICLP 2025", "summary": "In the context of urban traffic control, traffic signal optimisation is the\nproblem of determining the optimal green length for each signal in a set of\ntraffic signals. The literature has effectively tackled such a problem, mostly\nwith automated planning techniques leveraging the PDDL+ language and solvers.\nHowever, such language has limitations when it comes to specifying optimisation\nstatements and computing optimal plans. In this paper, we provide an\nalternative solution to the traffic signal optimisation problem based on\nConstraint Answer Set Programming (CASP). We devise an encoding in a CASP\nlanguage, which is then solved by means of clingcon 3, a system extending the\nwell-known ASP solver clingo. We performed experiments on real historical data\nfrom the town of Huddersfield in the UK, comparing our approach to the PDDL+\nmodel that obtained the best results for the considered benchmark. The results\nshowed the potential of our approach for tackling the traffic signal\noptimisation problem and improving the solution quality of the PDDL+ plans."}
{"id": "2507.19115", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2507.19115", "abs": "https://arxiv.org/abs/2507.19115", "authors": ["Shweta Ramesh", "Joy Bose", "Hamender Singh", "A K Raghavan", "Sujoy Roychowdhury", "Giriprasad Sridhara", "Nishrith Saini", "Ricardo Britto"], "title": "Automated Code Review Using Large Language Models at Ericsson: An Experience Report", "comment": null, "summary": "Code review is one of the primary means of assuring the quality of released\nsoftware along with testing and static analysis. However, code review requires\nexperienced developers who may not always have the time to perform an in-depth\nreview of code. Thus, automating code review can help alleviate the cognitive\nburden on experienced software developers allowing them to focus on their\nprimary activities of writing code to add new features and fix bugs. In this\npaper, we describe our experience in using Large Language Models towards\nautomating the code review process in Ericsson. We describe the development of\na lightweight tool using LLMs and static program analysis. We then describe our\npreliminary experiments with experienced developers in evaluating our code\nreview tool and the encouraging results."}
{"id": "2507.19245", "categories": ["cs.LO", "cs.AI", "68T27, 03B70, 68Q55"], "pdf": "https://arxiv.org/pdf/2507.19245", "abs": "https://arxiv.org/abs/2507.19245", "authors": ["Faruk Alpay", "Bugra Kilictas", "Taylan Alpay"], "title": "Transfinite Fixed Points in Alpay Algebra as Ordinal Game Equilibria in Dependent Type Theory", "comment": "21 pages, 1 figure", "summary": "This paper contributes to the Alpay Algebra by demonstrating that the stable\noutcome of a self referential process, obtained by iterating a transformation\nthrough all ordinal stages, is identical to the unique equilibrium of an\nunbounded revision dialogue between a system and its environment. The analysis\ninitially elucidates how classical fixed point theorems guarantee such\nconvergence in finite settings and subsequently extends the argument to the\ntransfinite domain, relying upon well founded induction and principles of order\ntheoretic continuity.\n  Furthermore, the resulting transordinal fixed point operator is embedded into\ndependent type theory, a formalization which permits every step of the\ntransfinite iteration and its limit to be verified within a modern proof\nassistant. This procedure yields a machine checked proof that the iterative\ndialogue necessarily stabilizes and that its limit is unique. The result\nprovides a foundation for Alpay's philosophical claim of semantic convergence\nwithin the framework of constructive logic. By unifying concepts from fixed\npoint theory, game semantics, ordinal analysis, and type theory, this research\nestablishes a broadly accessible yet formally rigorous foundation for reasoning\nabout infinite self referential systems and offers practical tools for\ncertifying their convergence within computational environments."}
{"id": "2507.19271", "categories": ["cs.SE", "cs.AI", "cs.PL"], "pdf": "https://arxiv.org/pdf/2507.19271", "abs": "https://arxiv.org/abs/2507.19271", "authors": ["Igli Begolli", "Meltem Aksoy", "Daniel Neider"], "title": "Fine-Tuning Multilingual Language Models for Code Review: An Empirical Study on Industrial C# Projects", "comment": null, "summary": "Code review is essential for maintaining software quality but often\ntime-consuming and cognitively demanding, especially in industrial\nenvironments. Recent advancements in language models (LMs) have opened new\navenues for automating core review tasks. This study presents the empirical\nevaluation of monolingual fine-tuning on the performance of open-source LMs\nacross three key automated code review tasks: Code Change Quality Estimation,\nReview Comment Generation, and Code Refinement. We fine-tuned three distinct\nmodels, CodeReviewer, CodeLlama-7B, and DeepSeek-R1-Distill, on a C\\# specific\ndataset combining public benchmarks with industrial repositories. Our study\ninvestigates how different configurations of programming languages and natural\nlanguages in the training data affect LM performance, particularly in comment\ngeneration. Additionally, we benchmark the fine-tuned models against an\nautomated software analysis tool (ASAT) and human reviewers to evaluate their\npractical utility in real-world settings. Our results show that monolingual\nfine-tuning improves model accuracy and relevance compared to multilingual\nbaselines. While LMs can effectively support code review workflows, especially\nfor routine or repetitive tasks, human reviewers remain superior in handling\nsemantically complex or context-sensitive changes. Our findings highlight the\nimportance of language alignment and task-specific adaptation in optimizing LMs\nfor automated code review."}
{"id": "2507.19424", "categories": ["cs.LO", "18M05"], "pdf": "https://arxiv.org/pdf/2507.19424", "abs": "https://arxiv.org/abs/2507.19424", "authors": ["Elena Di Lavore", "Mario Román", "Paweł Sobociński", "Márk Széles"], "title": "Order in Partial Markov Categories", "comment": "20 pages, MFPS 2025", "summary": "Partial Markov categories are a recent framework for categorical probability\ntheory, providing an abstract account of partial probabilistic computation. In\nthis article, we discuss two order relations on the morphisms of a partial\nMarkov category. In particular, we prove that every partial Markov category is\ncanonically enriched over the category of preordered sets and monotone maps. We\nshow that our construction recovers several well-known order enrichments. We\nalso demonstrate that the existence of codiagonal maps (comparators) is closely\nrelated to order properties of partial Markov categories. We propose a\nsynthetic version of the Cauchy-Schwarz inequality to facilitate inequational\nreasoning in partial Markov categories. We apply this new axiom to prove that\nupdating a prior distribution with an evidence predicate increases the\nlikelihood of the evidence in the posterior."}
{"id": "2507.19275", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.19275", "abs": "https://arxiv.org/abs/2507.19275", "authors": ["Bo Wang", "Pengyang Wang", "Chong Chen", "Qi Sun", "Jieke Shi", "Chengran Yang", "Ming Deng", "Youfang Lin", "Zhou Yang", "David Lo"], "title": "Mut4All: Fuzzing Compilers via LLM-Synthesized Mutators Learned from Bug Reports", "comment": null, "summary": "Mutation-based fuzzing is effective for uncovering compiler bugs, but\ndesigning high-quality mutators for modern languages with complex constructs\n(e.g., templates, macros) remains challenging. Existing methods rely heavily on\nmanual design or human-in-the-loop correction, limiting scalability and\ncross-language generalizability.\n  We present Mut4All, a fully automated, language-agnostic framework that\nsynthesizes mutators using Large Language Models (LLMs) and compiler-specific\nknowledge from bug reports. It consists of three agents: (1) a mutator\ninvention agent that identifies mutation targets and generates mutator metadata\nusing compiler-related insights; (2) a mutator implementation synthesis agent,\nfine-tuned to produce initial implementations; and (3) a mutator refinement\nagent that verifies and corrects the mutators via unit-test feedback.\n  Mut4All processes 1000 bug reports (500 Rust, 500 C++), yielding 319 Rust and\n403 C++ mutators at ~$0.08 each via GPT-4o. Our customized fuzzer, using these\nmutators, finds 62 bugs in Rust compilers (38 new, 7 fixed) and 34 bugs in C++\ncompilers (16 new, 1 fixed). Mut4All outperforms existing methods in both\nunique crash detection and coverage, ranking first on Rust and second on C++."}
{"id": "2507.19015", "categories": ["cs.PL", "cs.LO", "cs.SE"], "pdf": "https://arxiv.org/pdf/2507.19015", "abs": "https://arxiv.org/abs/2507.19015", "authors": ["Samuel Xifaras", "Panagiotis Manolios", "Andrew T. Walter", "William Robertson"], "title": "An Enumerative Embedding of the Python Type System in ACL2s", "comment": "In Proceedings ACL2 2025, arXiv:2507.18567", "summary": "Python is a high-level interpreted language that has become an industry\nstandard in a wide variety of applications. In this paper, we take a first step\ntowards using ACL2s to reason about Python code by developing an embedding of a\nsubset of the Python type system in ACL2s. The subset of Python types we\nsupport includes many of the most commonly used type annotations as well as\nuser-defined types comprised of supported types. We provide ACL2s definitions\nof these types, as well as defdata enumerators that are customized to provide\ncode coverage and identify errors in Python programs. Using the ACL2s\nembedding, we can generate instances of types that can then be used as inputs\nto fuzz Python programs, which allows us to identify bugs in Python code that\nare not detected by state-of-the-art Python type checkers. We evaluate our work\nagainst four open-source repositories, extracting their type information and\ngenerating inputs for fuzzing functions with type signatures that are in the\nsupported subset of Python types. Note that we only use the type signatures of\nfunctions to generate inputs and treat the bodies of functions as black boxes.\nWe measure code coverage, which ranges from about 68% to more than 80%, and\nidentify code patterns that hinder coverage such as complex branch conditions\nand external file system dependencies. We conclude with a discussion of the\nresults and recommendations for future work."}
{"id": "2507.19390", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2507.19390", "abs": "https://arxiv.org/abs/2507.19390", "authors": ["Altaf Allah Abbassi", "Leuson Da Silva", "Amin Nikanjam", "Foutse Khomh"], "title": "ReCatcher: Towards LLMs Regression Testing for Code Generation", "comment": "24 pages, 3 Figures, 2 Tables", "summary": "Large Language Models (LLMs) for code generation evolve rapidly through\nfine-tuning, merging, or new model releases. However, such updates can\nintroduce regressions, not only in correctness but also in code quality and\nperformance. To address this, we present ReCatcher, a regression testing\nframework for Python code generation. ReCatcher systematically compares two\nLLMs, typically a current model and a candidate update, across three\ndimensions: logical correctness, static code quality, and execution\nperformance. We apply ReCatcher to assess regressions across three update\nscenarios, fine-tuning, merging, and model release, using CodeLlama,\nDeepSeek-Coder, and GPT-4o. Our evaluation shows that fine-tuning with\ncross-language datasets increases syntax errors by up to 12%. Merging with\ngeneral-purpose models like Llama2 leads to regressions in correctness by up to\n18%. GPT-4o introduces regressions of up to 50% in handling missing imports\ncompared to GPT-3.5-turbo, while GPT-4o-mini suffers up to 80% performance\ndegradation in execution time versus GPT-4o. Overall, logical correctness,\nperformance, and error handling (e.g., syntax errors and missing imports) are\nthe most regression-prone areas. Comparing ReCatcher with baseline solutions,\nit presents better and consistent accuracy across logical and performance\naspects. ReCatcher highlights the importance of systematic regression\nevaluation before adopting new models, while assisting researchers and\npractitioners in making more informed update decisions."}
{"id": "2507.19403", "categories": ["cs.SE", "cs.AI", "cs.DC", "B.8.2; C.2.4"], "pdf": "https://arxiv.org/pdf/2507.19403", "abs": "https://arxiv.org/abs/2507.19403", "authors": ["Matthias Weiß", "Falk Dettinger", "Michael Weyrich"], "title": "SDVDiag: A Modular Platform for the Diagnosis of Connected Vehicle Functions", "comment": "7 pages, 5 figures", "summary": "Connected and software-defined vehicles promise to offer a broad range of\nservices and advanced functions to customers, aiming to increase passenger\ncomfort and support autonomous driving capabilities. Due to the high\nreliability and availability requirements of connected vehicles, it is crucial\nto resolve any occurring failures quickly. To achieve this however, a complex\ncloud/edge architecture with a mesh of dependencies must be navigated to\ndiagnose the responsible root cause. As such, manual analyses become unfeasible\nsince they would significantly delay the troubleshooting.\n  To address this challenge, this paper presents SDVDiag, an extensible\nplatform for the automated diagnosis of connected vehicle functions. The\nplatform enables the creation of pipelines that cover all steps from initial\ndata collection to the tracing of potential root causes. In addition, SDVDiag\nsupports self-adaptive behavior by the ability to exchange modules at runtime.\nDependencies between functions are detected and continuously updated, resulting\nin a dynamic graph view of the system. In addition, vital system metrics are\nmonitored for anomalies. Whenever an incident is investigated, a snapshot of\nthe graph is taken and augmented by relevant anomalies. Finally, the analysis\nis performed by traversing the graph and creating a ranking of the most likely\ncauses.\n  To evaluate the platform, it is deployed inside an 5G test fleet environment\nfor connected vehicle functions. The results show that injected faults can be\ndetected reliably. As such, the platform offers the potential to gain new\ninsights and reduce downtime by identifying problems and their causes at an\nearly stage."}
{"id": "2507.19432", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.19432", "abs": "https://arxiv.org/abs/2507.19432", "authors": ["Sheikh Shadab Towqir", "Fei He", "Todd Mytkowicz", "Na Meng"], "title": "Resolving Build Conflicts via Example-Based and Rule-Based Program Transformations", "comment": null, "summary": "Merge conflicts often arise when developers integrate changes from different\nsoftware branches. The conflicts can result from overlapping edits in programs\n(i.e., textual conflicts) or cause build and test errors (i.e., build and test\nconflicts). They degrade software quality and hinder programmer productivity.\nWhile several tools detect build conflicts, few offer meaningful support for\nresolving cases like those caused by method removal. To overcome limitations of\nexisting tools, we introduce BUCOR (Build Conflict Resolver), a new conflict\nresolver. BUCOR first detects conflicts by comparing three versions related to\na merging scenario: base b, left l, and right r. To resolve conflicts, it\nemploys two complementary strategies: example-based transformation (BUCOR-E)\nand rule-based transformation (BUCOR-R). BUCOR-R applies predefined rules to\nhandle common, well-understood conflicts. BUCOR-E mines branch versions (l and\nr) for exemplar edits applied to fix related build errors. From these examples,\nit infers and generalizes program transformation patterns to resolve more\ncomplex conflicts.\n  We evaluated BUCOR on 88 real-world build conflicts spanning 21 distinct\nconflict types. BUCOR generated at least one solution for 65 cases and\ncorrectly resolved 43 conflicts. We observed that this hybrid\napproach--combining context-aware, example-based learning with structured,\nrule-based resolution--can effectively help resolve conflicts. Our research\nsheds light on future directions for more intelligent and automated merge\ntools."}
{"id": "2507.19446", "categories": ["cs.SE", "cs.DC", "B.8.2; C.2.4"], "pdf": "https://arxiv.org/pdf/2507.19446", "abs": "https://arxiv.org/abs/2507.19446", "authors": ["Matthias Weiß", "Anish Navalgund", "Johannes Stümpfle", "Falk Dettinger", "Michael Weyrich"], "title": "An OpenSource CI/CD Pipeline for Variant-Rich Software-Defined Vehicles", "comment": "7 pages, 5 figures", "summary": "Software-defined vehicles (SDVs) offer a wide range of connected\nfunctionalities, including enhanced driving behavior and fleet management.\nThese features are continuously updated via over-the-air (OTA) mechanisms,\nresulting in a growing number of software versions and variants due to the\ndiversity of vehicles, cloud/edge environments, and stakeholders involved. The\nlack of a unified integration environment further complicates development, as\nconnected mobility solutions are often built in isolation. To ensure reliable\noperations across heterogeneous systems, a dynamic orchestration of functions\nthat considers hardware and software variability is essential. This paper\npresents an open-source CI/CD pipeline tailored for SDVs. It automates the\nbuild, test, and deployment phases using a combination of containerized\nopen-source tools, creating a standardized, portable, and scalable ecosystem\naccessible to all stakeholders. Additionally, a custom OTA middleware\ndistributes software updates and supports rollbacks across vehicles and backend\nservices. Update variants are derived based on deployment target dependencies\nand hardware configurations. The pipeline also supports continuous development\nand deployment of AI models for autonomous driving features. Its effectiveness\nis evaluated using an automated valet parking (AVP) scenario involving\nTurtleBots and a coordinating backend server. Two object detection variants are\ndeveloped and deployed to match hardware-specific requirements. Results\ndemonstrate seamless OTA updates, correct variant selection, and successful\norchestration across all targets. Overall, the proposed pipeline provides a\nscalable and efficient solution for managing software variants and OTA updates\nin SDVs, contributing to the advancement of future mobility technologies."}
{"id": "2507.18792", "categories": ["cs.PL", "cs.SE"], "pdf": "https://arxiv.org/pdf/2507.18792", "abs": "https://arxiv.org/abs/2507.18792", "authors": ["Zixu Zhou"], "title": "Decompiling Rust: An Empirical Study of Compiler Optimizations and Reverse Engineering Challenges", "comment": null, "summary": "Decompiling Rust binaries is challenging due to the language's rich type\nsystem, aggressive compiler optimizations, and widespread use of high-level\nabstractions. In this work, we conduct a benchmark-driven evaluation of\ndecompilation quality across core Rust features and compiler build modes. Our\nautomated scoring framework shows that generic types, trait methods, and error\nhandling constructs significantly reduce decompilation quality, especially in\nrelease builds. Through representative case studies, we analyze how specific\nlanguage constructs affect control flow, variable naming, and type information\nrecovery. Our findings provide actionable insights for tool developers and\nhighlight the need for Rust-aware decompilation strategies."}
{"id": "2507.19015", "categories": ["cs.PL", "cs.LO", "cs.SE"], "pdf": "https://arxiv.org/pdf/2507.19015", "abs": "https://arxiv.org/abs/2507.19015", "authors": ["Samuel Xifaras", "Panagiotis Manolios", "Andrew T. Walter", "William Robertson"], "title": "An Enumerative Embedding of the Python Type System in ACL2s", "comment": "In Proceedings ACL2 2025, arXiv:2507.18567", "summary": "Python is a high-level interpreted language that has become an industry\nstandard in a wide variety of applications. In this paper, we take a first step\ntowards using ACL2s to reason about Python code by developing an embedding of a\nsubset of the Python type system in ACL2s. The subset of Python types we\nsupport includes many of the most commonly used type annotations as well as\nuser-defined types comprised of supported types. We provide ACL2s definitions\nof these types, as well as defdata enumerators that are customized to provide\ncode coverage and identify errors in Python programs. Using the ACL2s\nembedding, we can generate instances of types that can then be used as inputs\nto fuzz Python programs, which allows us to identify bugs in Python code that\nare not detected by state-of-the-art Python type checkers. We evaluate our work\nagainst four open-source repositories, extracting their type information and\ngenerating inputs for fuzzing functions with type signatures that are in the\nsupported subset of Python types. Note that we only use the type signatures of\nfunctions to generate inputs and treat the bodies of functions as black boxes.\nWe measure code coverage, which ranges from about 68% to more than 80%, and\nidentify code patterns that hinder coverage such as complex branch conditions\nand external file system dependencies. We conclude with a discussion of the\nresults and recommendations for future work."}

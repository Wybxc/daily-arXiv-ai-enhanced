{"id": "2510.10834", "categories": ["cs.FL", "cs.DM", "math.NT"], "pdf": "https://arxiv.org/pdf/2510.10834", "abs": "https://arxiv.org/abs/2510.10834", "authors": ["Jeffrey Shallit"], "title": "The Tribonacci constant and finite automata", "comment": null, "summary": "We show that there is no automaton accepting the Tribonacci representations\nof $n$ and $x$ in parallel, where $\\psi = 1.839\\cdots$ is the Tribonacci\nconstant, and $x= \\lfloor n \\psi \\rfloor$. Similarly, there is no Tribonacci\nautomaton generating the Sturmian characteristic word with slope $\\psi-1$.", "AI": {"tldr": "\u8be5\u8bba\u6587\u8bc1\u660e\u4e86\u4e0d\u5b58\u5728\u63a5\u53d7Tribonacci\u8868\u793a\u548cSturmian\u7279\u5f81\u8bcd\u7684\u81ea\u52a8\u673a", "motivation": "\u7814\u7a76Tribonacci\u5e38\u6570\u76f8\u5173\u7684\u81ea\u52a8\u673a\u8868\u793a\u95ee\u9898\uff0c\u63a2\u7d22Tribonacci\u8868\u793a\u4e0eSturmian\u8bcd\u4e4b\u95f4\u7684\u5173\u7cfb", "method": "\u901a\u8fc7\u6570\u5b66\u8bc1\u660e\u65b9\u6cd5\uff0c\u5206\u6790Tribonacci\u8868\u793a\u548cSturmian\u7279\u5f81\u8bcd\u7684\u81ea\u52a8\u673a\u53ef\u63a5\u53d7\u6027", "result": "\u8bc1\u660e\u4e86\u4e0d\u5b58\u5728\u63a5\u53d7n\u548c\u230an\u03c8\u230b\u7684Tribonacci\u8868\u793a\u7684\u5e76\u884c\u81ea\u52a8\u673a\uff0c\u4e5f\u4e0d\u5b58\u5728\u751f\u6210\u659c\u7387\u4e3a\u03c8-1\u7684Sturmian\u7279\u5f81\u8bcd\u7684Tribonacci\u81ea\u52a8\u673a", "conclusion": "Tribonacci\u5e38\u6570\u76f8\u5173\u7684\u67d0\u4e9b\u8868\u793a\u95ee\u9898\u65e0\u6cd5\u7528\u81ea\u52a8\u673a\u89e3\u51b3\uff0c\u8fd9\u63ed\u793a\u4e86Tribonacci\u7cfb\u7edf\u4e0eSturmian\u7cfb\u7edf\u4e4b\u95f4\u7684\u6839\u672c\u5dee\u5f02"}}
{"id": "2510.11007", "categories": ["cs.PL", "cs.FL"], "pdf": "https://arxiv.org/pdf/2510.11007", "abs": "https://arxiv.org/abs/2510.11007", "authors": ["Antonina Nepeivoda", "Ilya Afanasyev"], "title": "Abstract String Domain Defined with Word Equations as a Reduced Product (Extended Version)", "comment": null, "summary": "We introduce a string-interval abstract domain, where string intervals are\ncharacterized by systems of word equations (encoding lower bounds on string\nvalues) and word disequalities (encoding upper bounds). Building upon the\nlattice structure of string intervals, we define an abstract string object as a\nreduced product on a string property semilattice, determined by\nlength-non-increasing morphisms. We consider several reduction strategies for\nabstract string objects and show that upon these strategies the string object\ndomain forms a lattice. We define basic abstract string operations on the\ndomain, aiming to minimize computational overheads on the reduction, and show\nhow the domain can be used to analyse properties of JavaScript string\nmanipulating programs.", "AI": {"tldr": "\u63d0\u51fa\u4e86\u4e00\u4e2a\u5b57\u7b26\u4e32\u533a\u95f4\u62bd\u8c61\u57df\uff0c\u901a\u8fc7\u5b57\u65b9\u7a0b\u548c\u5b57\u4e0d\u7b49\u5f0f\u6765\u8868\u5f81\u5b57\u7b26\u4e32\u503c\uff0c\u6784\u5efa\u4e86\u57fa\u4e8e\u957f\u5ea6\u975e\u589e\u6001\u5c04\u7684\u62bd\u8c61\u5b57\u7b26\u4e32\u5bf9\u8c61\u683c\u7ed3\u6784\uff0c\u5e76\u5b9a\u4e49\u4e86\u9ad8\u6548\u7684\u62bd\u8c61\u5b57\u7b26\u4e32\u64cd\u4f5c\u6765\u652f\u6301JavaScript\u5b57\u7b26\u4e32\u7a0b\u5e8f\u5206\u6790\u3002", "motivation": "\u4e3a\u4e86\u66f4\u7cbe\u786e\u5730\u5206\u6790JavaScript\u7b49\u8bed\u8a00\u4e2d\u7684\u5b57\u7b26\u4e32\u64cd\u4f5c\u7a0b\u5e8f\uff0c\u9700\u8981\u5f00\u53d1\u80fd\u591f\u5904\u7406\u5b57\u7b26\u4e32\u7ea6\u675f\u7684\u62bd\u8c61\u57df\uff0c\u4ee5\u6355\u83b7\u5b57\u7b26\u4e32\u503c\u7684\u4e0a\u4e0b\u754c\u4fe1\u606f\u3002", "method": "\u5b9a\u4e49\u5b57\u7b26\u4e32\u533a\u95f4\u62bd\u8c61\u57df\uff0c\u4f7f\u7528\u5b57\u65b9\u7a0b\u8868\u793a\u4e0b\u754c\u3001\u5b57\u4e0d\u7b49\u5f0f\u8868\u793a\u4e0a\u754c\uff1b\u6784\u5efa\u57fa\u4e8e\u957f\u5ea6\u975e\u589e\u6001\u5c04\u7684\u5b57\u7b26\u4e32\u5c5e\u6027\u534a\u683c\u4e0a\u7684\u7ea6\u5316\u79ef\uff1b\u8bbe\u8ba1\u591a\u79cd\u7ea6\u5316\u7b56\u7565\u4f7f\u5b57\u7b26\u4e32\u5bf9\u8c61\u57df\u5f62\u6210\u683c\u7ed3\u6784\u3002", "result": "\u5efa\u7acb\u4e86\u5b57\u7b26\u4e32\u533a\u95f4\u62bd\u8c61\u57df\u7684\u683c\u7ed3\u6784\uff0c\u5b9a\u4e49\u4e86\u9ad8\u6548\u7684\u62bd\u8c61\u5b57\u7b26\u4e32\u64cd\u4f5c\uff0c\u6700\u5c0f\u5316\u4e86\u7ea6\u5316\u8ba1\u7b97\u5f00\u9500\uff0c\u80fd\u591f\u6709\u6548\u5206\u6790JavaScript\u5b57\u7b26\u4e32\u64cd\u4f5c\u7a0b\u5e8f\u7684\u6027\u8d28\u3002", "conclusion": "\u8be5\u5b57\u7b26\u4e32\u62bd\u8c61\u57df\u4e3a\u7a0b\u5e8f\u5206\u6790\u63d0\u4f9b\u4e86\u5f3a\u5927\u7684\u7406\u8bba\u57fa\u7840\uff0c\u80fd\u591f\u7cbe\u786e\u5904\u7406\u5b57\u7b26\u4e32\u7ea6\u675f\uff0c\u7279\u522b\u9002\u7528\u4e8eJavaScript\u7b49\u52a8\u6001\u8bed\u8a00\u4e2d\u5b57\u7b26\u4e32\u64cd\u4f5c\u7684\u9759\u6001\u5206\u6790\u3002"}}
{"id": "2510.09950", "categories": ["cs.LO"], "pdf": "https://arxiv.org/pdf/2510.09950", "abs": "https://arxiv.org/abs/2510.09950", "authors": ["Andrei A. Bulatov", "Amirhossein Kazeminia"], "title": "Modular Counting over 3-Element and Conservative Domains", "comment": null, "summary": "In the Constraint Satisfaction Problem (CSP for short) the goal is to decide\nthe existence of a homomorphism from a given relational structure $G$ to a\ngiven relational structure $H$. If the structure $H$ is fixed and $G$ is the\nonly input, the problem is denoted $CSP(H)$. In its counting version,\n$\\#CSP(H)$, the task is to find the number of such homomorphisms. The CSP and\n#CSP have been used to model a wide variety of combinatorial problems and have\nreceived a tremendous amount of attention from researchers from multiple\ndisciplines.\n  In this paper we consider the modular version of the counting CSPs, that is,\nproblems of the form $\\#_pCSP(H)$ of counting the number of homomorphisms to\n$H$ modulo a fixed prime number $p$. Modular counting has been intensively\nstudied during the last decade, although mainly in the case of graph\nhomomorphisms. Here we continue the program of systematic research of modular\ncounting of homomorphisms to general relational structures. The main results of\nthe paper include a new way of reducing modular counting problems to smaller\ndomains and a study of the complexity of such problems over 3-element domains\nand over conservative domains, that is, relational structures that allow to\nexpress (in a certain exact way) every possible unary predicate.", "AI": {"tldr": "\u672c\u6587\u7814\u7a76\u4e86\u7ea6\u675f\u6ee1\u8db3\u95ee\u9898(CSP)\u7684\u6a21\u8ba1\u6570\u7248\u672c\uff0c\u5373\u8ba1\u7b97\u4ece\u7ed9\u5b9a\u5173\u7cfb\u7ed3\u6784\u5230\u56fa\u5b9a\u5173\u7cfb\u7ed3\u6784\u7684\u540c\u6001\u6570\u91cf\u6a21\u7d20\u6570p\u7684\u95ee\u9898\u3002", "motivation": "\u6a21\u8ba1\u6570\u5728\u8fc7\u53bb\u5341\u5e74\u4e2d\u5f97\u5230\u4e86\u6df1\u5165\u7814\u7a76\uff0c\u4f46\u4e3b\u8981\u96c6\u4e2d\u5728\u56fe\u540c\u6001\u9886\u57df\u3002\u672c\u6587\u65e8\u5728\u7cfb\u7edf\u7814\u7a76\u4e00\u822c\u5173\u7cfb\u7ed3\u6784\u7684\u6a21\u540c\u6001\u8ba1\u6570\u95ee\u9898\u3002", "method": "\u63d0\u51fa\u4e86\u4e00\u79cd\u5c06\u6a21\u8ba1\u6570\u95ee\u9898\u7ea6\u7b80\u5230\u66f4\u5c0f\u57df\u7684\u65b0\u65b9\u6cd5\uff0c\u5e76\u7814\u7a76\u4e863\u5143\u7d20\u57df\u548c\u4fdd\u5b88\u57df\u4e0a\u6b64\u7c7b\u95ee\u9898\u7684\u590d\u6742\u6027\u3002", "result": "\u4e3b\u8981\u6210\u679c\u5305\u62ec\u5f00\u53d1\u4e86\u7ea6\u7b80\u6a21\u8ba1\u6570\u95ee\u9898\u5230\u66f4\u5c0f\u57df\u7684\u6280\u672f\uff0c\u5e76\u5206\u6790\u4e863\u5143\u7d20\u57df\u548c\u4fdd\u5b88\u57df\u4e0a\u6a21\u8ba1\u6570\u95ee\u9898\u7684\u590d\u6742\u6027\u7279\u5f81\u3002", "conclusion": "\u672c\u6587\u4e3a\u5173\u7cfb\u7ed3\u6784\u6a21\u540c\u6001\u8ba1\u6570\u7684\u7cfb\u7edf\u7814\u7a76\u63d0\u4f9b\u4e86\u65b0\u7684\u7ea6\u7b80\u65b9\u6cd5\u548c\u590d\u6742\u6027\u5206\u6790\u7ed3\u679c\uff0c\u6269\u5c55\u4e86\u6a21\u8ba1\u6570\u7406\u8bba\u7684\u7814\u7a76\u8303\u56f4\u3002"}}
{"id": "2510.09726", "categories": ["cs.PL", "cs.AI", "cs.SE"], "pdf": "https://arxiv.org/pdf/2510.09726", "abs": "https://arxiv.org/abs/2510.09726", "authors": ["Tilman Hinnerichs", "Reuben Gardos Reid", "Jaap de Jong", "Bart Swinkels", "Pamela Wochner", "Nicolae Filat", "Tudor Magurescu", "Issa Hanou", "Sebastijan Dumancic"], "title": "Herb.jl: A Unifying Program Synthesis Library", "comment": null, "summary": "Program synthesis -- the automatic generation of code given a specification\n-- is one of the most fundamental tasks in artificial intelligence (AI) and\nmany programmers' dream. Numerous synthesizers have been developed to tackle\nprogram synthesis, manifesting different ideas to approach the exponentially\ngrowing program space. While numerous smart program synthesis tools exist,\nreusing and remixing previously developed methods is tedious and\ntime-consuming. We propose Herb.jl, a unifying program synthesis library\nwritten in the Julia programming language, to address these issues. Since\ncurrent methods rely on similar building blocks, we aim to modularize the\nunderlying synthesis algorithm into communicating and fully extendable\nsub-compartments, allowing for straightforward reapplication of these modules.\nTo demonstrate the benefits of using Herb.jl, we show three common use cases:\n1. how to implement a simple problem and grammar, and how to solve it, 2. how\nto implement a previously developed synthesizer with just a few lines of code,\nand 3. how to run a synthesizer against a benchmark.", "AI": {"tldr": "Herb.jl\u662f\u4e00\u4e2a\u7528Julia\u7f16\u7a0b\u8bed\u8a00\u7f16\u5199\u7684\u7edf\u4e00\u7a0b\u5e8f\u5408\u6210\u5e93\uff0c\u65e8\u5728\u6a21\u5757\u5316\u5408\u6210\u7b97\u6cd5\uff0c\u4fbf\u4e8e\u91cd\u7528\u548c\u6269\u5c55\u73b0\u6709\u65b9\u6cd5\u3002", "motivation": "\u73b0\u6709\u7684\u7a0b\u5e8f\u5408\u6210\u5de5\u5177\u867d\u7136\u4f17\u591a\uff0c\u4f46\u91cd\u7528\u548c\u6df7\u5408\u5148\u524d\u5f00\u53d1\u7684\u65b9\u6cd5\u65e2\u7e41\u7410\u53c8\u8017\u65f6\u3002", "method": "\u5c06\u5e95\u5c42\u5408\u6210\u7b97\u6cd5\u6a21\u5757\u5316\u4e3a\u53ef\u901a\u4fe1\u548c\u5b8c\u5168\u53ef\u6269\u5c55\u7684\u5b50\u7ec4\u4ef6\uff0c\u5141\u8bb8\u76f4\u63a5\u91cd\u7528\u8fd9\u4e9b\u6a21\u5757\u3002", "result": "\u5c55\u793a\u4e86\u4e09\u4e2a\u5e38\u89c1\u7528\u4f8b\uff1a\u5b9e\u73b0\u7b80\u5355\u95ee\u9898\u548c\u8bed\u6cd5\u5e76\u89e3\u51b3\u3001\u7528\u5c11\u91cf\u4ee3\u7801\u5b9e\u73b0\u5148\u524d\u5f00\u53d1\u7684\u5408\u6210\u5668\u3001\u5728\u57fa\u51c6\u6d4b\u8bd5\u4e0a\u8fd0\u884c\u5408\u6210\u5668\u3002", "conclusion": "Herb.jl\u63d0\u4f9b\u4e86\u4e00\u4e2a\u7edf\u4e00\u7684\u7a0b\u5e8f\u5408\u6210\u6846\u67b6\uff0c\u7b80\u5316\u4e86\u5408\u6210\u65b9\u6cd5\u7684\u91cd\u7528\u548c\u6269\u5c55\u3002"}}
{"id": "2510.09721", "categories": ["cs.SE", "cs.CL"], "pdf": "https://arxiv.org/pdf/2510.09721", "abs": "https://arxiv.org/abs/2510.09721", "authors": ["Jiale Guo", "Suizhi Huang", "Mei Li", "Dong Huang", "Xingsheng Chen", "Regina Zhang", "Zhijiang Guo", "Han Yu", "Siu-Ming Yiu", "Christian Jensen", "Pietro Lio", "Kwok-Yan Lam"], "title": "A Comprehensive Survey on Benchmarks and Solutions in Software Engineering of LLM-Empowered Agentic System", "comment": "21 pages", "summary": "The integration of LLMs into software engineering has catalyzed a paradigm\nshift from traditional rule-based systems to sophisticated agentic systems\ncapable of autonomous problem-solving. Despite this transformation, the field\nlacks a comprehensive understanding of how benchmarks and solutions\ninterconnect, hindering systematic progress and evaluation. This survey\npresents the first holistic analysis of LLM-empowered software engineering,\nbridging the critical gap between evaluation and solution approaches. We\nanalyze 150+ recent papers and organize them into a comprehensive taxonomy\nspanning two major dimensions: (1) Solutions, categorized into prompt-based,\nfine-tuning-based, and agent-based paradigms, and (2) Benchmarks, covering code\ngeneration, translation, repair, and other tasks. Our analysis reveals how the\nfield has evolved from simple prompt engineering to complex agentic systems\nincorporating planning and decomposition, reasoning and self-refinement, memory\nmechanisms, and tool augmentation. We present a unified pipeline that\nillustrates the complete workflow from task specification to final\ndeliverables, demonstrating how different solution paradigms address varying\ncomplexity levels across software engineering tasks. Unlike existing surveys\nthat focus on isolated aspects, we provide full-spectrum coverage connecting\n50+ benchmarks with their corresponding solution strategies, enabling\nresearchers to identify optimal approaches for specific evaluation criteria.\nFurthermore, we identify critical research gaps and propose actionable future\ndirections, including multi-agent collaboration frameworks, self-evolving code\ngeneration systems, and integration of formal verification with LLM-based\nmethods. This survey serves as a foundational resource for researchers and\npractitioners seeking to understand, evaluate, and advance LLM-empowered\nsoftware engineering systems.", "AI": {"tldr": "\u8be5\u8bba\u6587\u9996\u6b21\u5bf9LLM\u8d4b\u80fd\u7684\u8f6f\u4ef6\u5de5\u7a0b\u8fdb\u884c\u5168\u9762\u5206\u6790\uff0c\u63d0\u51fa\u4e86\u4e00\u4e2a\u5305\u542b\u89e3\u51b3\u65b9\u6848\u548c\u57fa\u51c6\u6d4b\u8bd5\u7684\u53cc\u7ef4\u5ea6\u5206\u7c7b\u6cd5\uff0c\u5206\u6790\u4e86150\u591a\u7bc7\u8bba\u6587\uff0c\u63ed\u793a\u4e86\u4ece\u7b80\u5355\u63d0\u793a\u5de5\u7a0b\u5230\u590d\u6742\u667a\u80fd\u4f53\u7cfb\u7edf\u7684\u6f14\u8fdb\u8fc7\u7a0b\u3002", "motivation": "LLM\u5728\u8f6f\u4ef6\u5de5\u7a0b\u4e2d\u7684\u5e94\u7528\u5f15\u53d1\u4e86\u4ece\u4f20\u7edf\u89c4\u5219\u7cfb\u7edf\u5230\u667a\u80fd\u81ea\u4e3b\u7cfb\u7edf\u7684\u8303\u5f0f\u8f6c\u53d8\uff0c\u4f46\u9886\u57df\u7f3a\u4e4f\u5bf9\u57fa\u51c6\u6d4b\u8bd5\u4e0e\u89e3\u51b3\u65b9\u6848\u4e4b\u95f4\u76f8\u4e92\u5173\u8054\u7684\u5168\u9762\u7406\u89e3\uff0c\u963b\u788d\u4e86\u7cfb\u7edf\u6027\u8fdb\u5c55\u548c\u8bc4\u4f30\u3002", "method": "\u5206\u6790\u4e86150\u591a\u7bc7\u6700\u65b0\u8bba\u6587\uff0c\u6784\u5efa\u4e86\u4e00\u4e2a\u5168\u9762\u7684\u5206\u7c7b\u6cd5\uff0c\u6db5\u76d6\u4e24\u4e2a\u4e3b\u8981\u7ef4\u5ea6\uff1a\u89e3\u51b3\u65b9\u6848\uff08\u57fa\u4e8e\u63d0\u793a\u3001\u5fae\u8c03\u548c\u667a\u80fd\u4f53\u7684\u8303\u5f0f\uff09\u548c\u57fa\u51c6\u6d4b\u8bd5\uff08\u4ee3\u7801\u751f\u6210\u3001\u7ffb\u8bd1\u3001\u4fee\u590d\u7b49\u4efb\u52a1\uff09\u3002", "result": "\u63ed\u793a\u4e86\u8be5\u9886\u57df\u4ece\u7b80\u5355\u63d0\u793a\u5de5\u7a0b\u6f14\u8fdb\u5230\u5305\u542b\u89c4\u5212\u5206\u89e3\u3001\u63a8\u7406\u81ea\u4f18\u5316\u3001\u8bb0\u5fc6\u673a\u5236\u548c\u5de5\u5177\u589e\u5f3a\u7684\u590d\u6742\u667a\u80fd\u4f53\u7cfb\u7edf\uff0c\u63d0\u51fa\u4e86\u8fde\u63a550\u591a\u4e2a\u57fa\u51c6\u6d4b\u8bd5\u4e0e\u5bf9\u5e94\u89e3\u51b3\u65b9\u6848\u7b56\u7565\u7684\u7edf\u4e00\u6846\u67b6\u3002", "conclusion": "\u8be5\u8c03\u67e5\u4e3a\u7814\u7a76\u4eba\u5458\u548c\u5b9e\u8df5\u8005\u63d0\u4f9b\u4e86\u7406\u89e3\u3001\u8bc4\u4f30\u548c\u63a8\u8fdbLLM\u8d4b\u80fd\u8f6f\u4ef6\u5de5\u7a0b\u7cfb\u7edf\u7684\u57fa\u7840\u8d44\u6e90\uff0c\u8bc6\u522b\u4e86\u5173\u952e\u7814\u7a76\u7a7a\u767d\u5e76\u63d0\u51fa\u4e86\u53ef\u884c\u7684\u672a\u6765\u65b9\u5411\uff0c\u5305\u62ec\u591a\u667a\u80fd\u4f53\u534f\u4f5c\u6846\u67b6\u548c\u81ea\u8fdb\u5316\u4ee3\u7801\u751f\u6210\u7cfb\u7edf\u3002"}}
{"id": "2510.10131", "categories": ["cs.LO"], "pdf": "https://arxiv.org/pdf/2510.10131", "abs": "https://arxiv.org/abs/2510.10131", "authors": ["Jian Fang", "Yican Sun", "Yingfei Xiong"], "title": "Proof Strategy Extraction from LLMs for Enhancing Symbolic Provers", "comment": null, "summary": "One important approach to software verification is interactive theorem\nproving. However, writing formal proofs often requires substantial human\neffort, making proof automation highly important. Traditionally, proof\nautomation has relied on symbolic provers. Recently, large language models\n(LLMs) have demonstrated strong capabilities in theorem proving, complementing\nsymbolic provers. Nonetheless, prompting LLMs can be expensive and may pose\nsecurity risks for confidential codebases. As a result, purely symbolic\napproaches remain important even in the LLM era, as they are cost-effective,\nsecure, and complement the strengths of LLMs.\n  Motivated by these considerations, we ask a new research question: can we\nextract the internal strategies of LLMs to enhance the capabilities of symbolic\nprovers? As an initial attempt to answer this question, we propose Strat2Rocq,\nwhich extracts proof strategies from LLMs and formalizes them as lemmas in\nRocq. These lemmas are accessible to symbolic provers such as CoqHammer. With\nthe addition of these LLM-extracted lemmas, CoqHammer is able to prove more\ntheorems. The knowledge extraction process involves analyzing the proof\ntrajectories of LLMs on a training set of proved theorems. For each theorem, we\nprompt the LLM to generate a natural language proof, then ask it to summarize\nthis proof into formalized lemmas with proofs. We also employ a standard\nagentic approach to mitigate errors during formalization. Our evaluation\ndemonstrates that, on open-source Rocq projects for software verification,\nStrat2Rocq enhances the success rate of CoqHammer by 13.41%.", "AI": {"tldr": "Strat2Rocq\u4eceLLMs\u4e2d\u63d0\u53d6\u8bc1\u660e\u7b56\u7565\u5e76\u5f62\u5f0f\u5316\u4e3aRocq\u4e2d\u7684\u5f15\u7406\uff0c\u589e\u5f3a\u7b26\u53f7\u8bc1\u660e\u5668CoqHammer\u7684\u80fd\u529b\uff0c\u4f7f\u5176\u5728\u8f6f\u4ef6\u9a8c\u8bc1\u4e2d\u7684\u6210\u529f\u7387\u63d0\u534713.41%\u3002", "motivation": "\u4ea4\u4e92\u5f0f\u5b9a\u7406\u8bc1\u660e\u9700\u8981\u5927\u91cf\u4eba\u5de5\u52aa\u529b\uff0c\u4f20\u7edf\u7b26\u53f7\u8bc1\u660e\u5668\u4e0eLLMs\u4e92\u8865\u3002\u4f46LLMs\u63d0\u793a\u6210\u672c\u9ad8\u4e14\u6709\u5b89\u5168\u98ce\u9669\uff0c\u56e0\u6b64\u9700\u8981\u5229\u7528LLMs\u7684\u7b56\u7565\u6765\u589e\u5f3a\u7b26\u53f7\u8bc1\u660e\u5668\u3002", "method": "\u5206\u6790LLMs\u5728\u8bad\u7ec3\u96c6\u4e0a\u7684\u8bc1\u660e\u8f68\u8ff9\uff0c\u8ba9LLM\u751f\u6210\u81ea\u7136\u8bed\u8a00\u8bc1\u660e\u5e76\u603b\u7ed3\u4e3a\u5f62\u5f0f\u5316\u5f15\u7406\uff0c\u91c7\u7528\u6807\u51c6\u4ee3\u7406\u65b9\u6cd5\u51cf\u5c11\u5f62\u5f0f\u5316\u8fc7\u7a0b\u4e2d\u7684\u9519\u8bef\u3002", "result": "\u5728\u5f00\u6e90Rocq\u9879\u76ee\u7684\u8f6f\u4ef6\u9a8c\u8bc1\u4e2d\uff0cStrat2Rocq\u5c06CoqHammer\u7684\u6210\u529f\u7387\u63d0\u9ad8\u4e8613.41%\u3002", "conclusion": "\u4eceLLMs\u4e2d\u63d0\u53d6\u7b56\u7565\u53ef\u4ee5\u6709\u6548\u5730\u589e\u5f3a\u7b26\u53f7\u8bc1\u660e\u5668\u7684\u80fd\u529b\uff0c\u4e3a\u8f6f\u4ef6\u9a8c\u8bc1\u63d0\u4f9b\u4e86\u4e00\u79cd\u6210\u672c\u6548\u76ca\u9ad8\u4e14\u5b89\u5168\u7684\u65b9\u6cd5\u3002"}}
{"id": "2510.09932", "categories": ["cs.PL", "cs.AR"], "pdf": "https://arxiv.org/pdf/2510.09932", "abs": "https://arxiv.org/abs/2510.09932", "authors": ["Devansh Jain", "Akash Pardeshi", "Marco Frigo", "Krut Patel", "Kaustubh Khulbe", "Jai Arora", "Charith Mendis"], "title": "ACT: Automatically Generating Compiler Backends from Tensor Accelerator ISA Descriptions", "comment": null, "summary": "Tensor compilers play a key role in enabling high-performance implementations\nof deep learning workloads. These compilers rely on existing CPU and GPU code\ngeneration backends to generate device-specific code. Recently, many tensor\naccelerators (neural processing units) have been proposed to further accelerate\nthese workloads. Compared to commodity hardware, however, most of the proposed\ntensor accelerators do not have compiler backends with code generation support.\nMoreover, the accelerator designs are subject to fast iteration cycles, making\nit difficult to manually develop compiler backends similar to commodity\nhardware platforms. Therefore, to increase adoption and enable faster software\ndevelopment cycles for novel tensor accelerator designs, we need to make the\ncompiler backend construction process more agile.\n  To address this gap, we introduce ACT, a compiler backend generator that\nautomatically generates compiler backends for tensor accelerators, given just\nthe instruction set architecture (ISA) descriptions. We first formally specify\nthe compiler backend generation problem that introduces a novel specification\nfor describing tensor accelerator ISAs. Next, we design ACT such that it\nsupports user-programmable memories and complex parameterized instructions that\nare prevalent in tensor accelerators. ACT uses a novel parameterized equality\nsaturation-based instruction selection phase and a constraint programming-based\nmemory allocation phase. We prove that compiler backends generated by ACT are\nsound and complete. Finally, we generate compiler backends for three\naccelerator platforms from industry and academia, and show that they match or\noutperform code written using hand-optimized kernel libraries while maintaining\nlow compilation overheads.", "AI": {"tldr": "ACT\u662f\u4e00\u4e2a\u7f16\u8bd1\u5668\u540e\u7aef\u751f\u6210\u5668\uff0c\u80fd\u591f\u6839\u636e\u5f20\u91cf\u52a0\u901f\u5668\u7684\u6307\u4ee4\u96c6\u67b6\u6784\u63cf\u8ff0\u81ea\u52a8\u751f\u6210\u7f16\u8bd1\u5668\u540e\u7aef\uff0c\u89e3\u51b3\u4e86\u65b0\u786c\u4ef6\u7f3a\u4e4f\u7f16\u8bd1\u5668\u652f\u6301\u7684\u95ee\u9898\u3002", "motivation": "\u73b0\u6709\u7684\u5f20\u91cf\u52a0\u901f\u5668\u7f3a\u4e4f\u7f16\u8bd1\u5668\u540e\u7aef\u652f\u6301\uff0c\u4e14\u786c\u4ef6\u8bbe\u8ba1\u8fed\u4ee3\u5feb\u901f\uff0c\u624b\u52a8\u5f00\u53d1\u7f16\u8bd1\u5668\u540e\u7aef\u6210\u672c\u9ad8\u3001\u5468\u671f\u957f\uff0c\u963b\u788d\u4e86\u65b0\u786c\u4ef6\u7684\u91c7\u7528\u548c\u8f6f\u4ef6\u5f00\u53d1\u3002", "method": "ACT\u901a\u8fc7\u5f62\u5f0f\u5316\u89c4\u8303\u63cf\u8ff0\u5f20\u91cf\u52a0\u901f\u5668ISA\uff0c\u91c7\u7528\u53c2\u6570\u5316\u7b49\u5f0f\u9971\u548c\u7684\u6307\u4ee4\u9009\u62e9\u65b9\u6cd5\u548c\u57fa\u4e8e\u7ea6\u675f\u89c4\u5212\u7684\u5185\u5b58\u5206\u914d\u7b56\u7565\uff0c\u81ea\u52a8\u751f\u6210\u7f16\u8bd1\u5668\u540e\u7aef\u3002", "result": "\u4e3a\u4e09\u4e2a\u5de5\u4e1a\u548c\u5b66\u672f\u754c\u7684\u52a0\u901f\u5668\u5e73\u53f0\u751f\u6210\u4e86\u7f16\u8bd1\u5668\u540e\u7aef\uff0c\u6027\u80fd\u8fbe\u5230\u6216\u8d85\u8fc7\u624b\u52a8\u4f18\u5316\u7684\u5185\u6838\u5e93\uff0c\u540c\u65f6\u4fdd\u6301\u4f4e\u7f16\u8bd1\u5f00\u9500\u3002", "conclusion": "ACT\u80fd\u591f\u81ea\u52a8\u751f\u6210\u6b63\u786e\u4e14\u5b8c\u6574\u7684\u7f16\u8bd1\u5668\u540e\u7aef\uff0c\u663e\u8457\u964d\u4f4e\u4e86\u65b0\u5f20\u91cf\u52a0\u901f\u5668\u7684\u8f6f\u4ef6\u652f\u6301\u6210\u672c\uff0c\u52a0\u901f\u4e86\u786c\u4ef6\u521b\u65b0\u548c\u91c7\u7528\u3002"}}
{"id": "2510.09724", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.09724", "abs": "https://arxiv.org/abs/2510.09724", "authors": ["Qiaosheng Chen", "Yang Liu", "Lei Li", "Kai Chen", "Qipeng Guo", "Gong Cheng", "Fei Yuan"], "title": "InteractScience: Programmatic and Visually-Grounded Evaluation of Interactive Scientific Demonstration Code Generation", "comment": "27 pages, 17 figures", "summary": "Large Language Models (LLMs) are increasingly capable of generating complete\napplications from natural language instructions, creating new opportunities in\nscience and education. In these domains, interactive scientific demonstrations\nare particularly valuable for explaining concepts, supporting new teaching\nmethods, and presenting research findings. Generating such demonstrations\nrequires models to combine accurate scientific knowledge with the ability to\nimplement interactive front-end code that behaves correctly and responds to\nuser actions. This capability goes beyond the scope of existing benchmarks,\nwhich typically evaluate either knowledge question answering without grounding\nin code or static web code generation without scientific interactivity. To\nevaluate this integrated ability, we design a hybrid framework that combines\nprogrammatic functional testing to rigorously verify interaction logic with\nvisually-grounded qualitative testing to assess rendered outputs against\nreference snapshots. Building on this framework, we present InteractScience, a\nbenchmark consisting of a substantial set of carefully designed questions\nacross five scientific domains, each paired with unit tests, reference\nsnapshots, and checklists. We evaluate 30 leading open- and closed-source LLMs\nand report results that highlight ongoing weaknesses in integrating domain\nknowledge with interactive front-end coding. Our work positions InteractScience\nas the first benchmark to automatically measure this combined capability with\nrealistic interactive operations, providing a foundation for advancing reliable\nand educationally useful scientific demonstration code generation. All code and\ndata are publicly available at https://github.com/open-compass/InteractScience.", "AI": {"tldr": "InteractScience\u662f\u4e00\u4e2a\u8bc4\u4f30\u5927\u8bed\u8a00\u6a21\u578b\u5728\u79d1\u5b66\u9886\u57df\u751f\u6210\u4ea4\u4e92\u5f0f\u6f14\u793a\u4ee3\u7801\u80fd\u529b\u7684\u57fa\u51c6\u6d4b\u8bd5\uff0c\u7ed3\u5408\u4e86\u7a0b\u5e8f\u5316\u529f\u80fd\u6d4b\u8bd5\u548c\u89c6\u89c9\u5b9a\u6027\u6d4b\u8bd5\u6765\u9a8c\u8bc1\u4ea4\u4e92\u903b\u8f91\u548c\u6e32\u67d3\u8f93\u51fa\u3002", "motivation": "\u73b0\u6709\u57fa\u51c6\u6d4b\u8bd5\u8981\u4e48\u8bc4\u4f30\u77e5\u8bc6\u95ee\u7b54\u800c\u4e0d\u6d89\u53ca\u4ee3\u7801\uff0c\u8981\u4e48\u8bc4\u4f30\u9759\u6001\u7f51\u9875\u4ee3\u7801\u751f\u6210\u800c\u4e0d\u6d89\u53ca\u79d1\u5b66\u4ea4\u4e92\u6027\u3002\u9700\u8981\u8bc4\u4f30\u6a21\u578b\u5c06\u51c6\u786e\u79d1\u5b66\u77e5\u8bc6\u4e0e\u4ea4\u4e92\u5f0f\u524d\u7aef\u4ee3\u7801\u5b9e\u73b0\u76f8\u7ed3\u5408\u7684\u80fd\u529b\u3002", "method": "\u8bbe\u8ba1\u4e86\u4e00\u4e2a\u6df7\u5408\u6846\u67b6\uff0c\u7ed3\u5408\u7a0b\u5e8f\u5316\u529f\u80fd\u6d4b\u8bd5\u6765\u4e25\u683c\u9a8c\u8bc1\u4ea4\u4e92\u903b\u8f91\uff0c\u4ee5\u53ca\u57fa\u4e8e\u89c6\u89c9\u7684\u5b9a\u6027\u6d4b\u8bd5\u6765\u8bc4\u4f30\u6e32\u67d3\u8f93\u51fa\u4e0e\u53c2\u8003\u5feb\u7167\u7684\u5bf9\u6bd4\u3002\u6784\u5efa\u4e86InteractScience\u57fa\u51c6\uff0c\u5305\u542b\u4e94\u4e2a\u79d1\u5b66\u9886\u57df\u7684\u7cbe\u5fc3\u8bbe\u8ba1\u95ee\u9898\uff0c\u6bcf\u4e2a\u95ee\u9898\u90fd\u914d\u6709\u5355\u5143\u6d4b\u8bd5\u3001\u53c2\u8003\u5feb\u7167\u548c\u68c0\u67e5\u6e05\u5355\u3002", "result": "\u8bc4\u4f30\u4e8630\u4e2a\u9886\u5148\u7684\u5f00\u6e90\u548c\u95ed\u6e90LLM\uff0c\u7ed3\u679c\u663e\u793a\u5728\u5c06\u9886\u57df\u77e5\u8bc6\u4e0e\u4ea4\u4e92\u5f0f\u524d\u7aef\u7f16\u7801\u6574\u5408\u65b9\u9762\u4ecd\u5b58\u5728\u6301\u7eed\u5f31\u70b9\u3002", "conclusion": "InteractScience\u662f\u9996\u4e2a\u80fd\u591f\u81ea\u52a8\u6d4b\u91cf\u8fd9\u79cd\u7ed3\u5408\u80fd\u529b\u5e76\u5177\u6709\u73b0\u5b9e\u4ea4\u4e92\u64cd\u4f5c\u7684\u57fa\u51c6\u6d4b\u8bd5\uff0c\u4e3a\u63a8\u8fdb\u53ef\u9760\u4e14\u6559\u80b2\u6709\u7528\u7684\u79d1\u5b66\u6f14\u793a\u4ee3\u7801\u751f\u6210\u5960\u5b9a\u4e86\u57fa\u7840\u3002"}}
{"id": "2510.10189", "categories": ["cs.LO", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.10189", "abs": "https://arxiv.org/abs/2510.10189", "authors": ["David Wang", "Mohammad Abdulaziz"], "title": "Formally Verified Certification of Unsolvability of Temporal Planning Problems", "comment": null, "summary": "We present an approach to unsolvability certification of temporal planning.\nOur approach is based on encoding the planning problem into a network of timed\nautomata, and then using an efficient model checker on the network followed by\na certificate checker to certify the output of the model checker. Our approach\nprioritises trustworthiness of the certification: we formally verify our\nimplementation of the encoding to timed automata using the theorem prover\nIsabelle/HOL and we use an existing certificate checker (also formally verified\nin Isabelle/HOL) to certify the model checking result.", "AI": {"tldr": "\u63d0\u51fa\u4e00\u79cd\u57fa\u4e8e\u65f6\u95f4\u81ea\u52a8\u673a\u7f51\u7edc\u7f16\u7801\u548c\u6a21\u578b\u68c0\u67e5\u7684\u65f6\u95f4\u89c4\u5212\u4e0d\u53ef\u89e3\u6027\u8ba4\u8bc1\u65b9\u6cd5\uff0c\u5f3a\u8c03\u901a\u8fc7Isabelle/HOL\u5f62\u5f0f\u5316\u9a8c\u8bc1\u786e\u4fdd\u8ba4\u8bc1\u53ef\u4fe1\u5ea6", "motivation": "\u9700\u8981\u786e\u4fdd\u65f6\u95f4\u89c4\u5212\u4e0d\u53ef\u89e3\u6027\u8ba4\u8bc1\u7684\u53ef\u4fe1\u5ea6\uff0c\u4f20\u7edf\u65b9\u6cd5\u7f3a\u4e4f\u5f62\u5f0f\u5316\u9a8c\u8bc1\u4fdd\u8bc1", "method": "\u5c06\u89c4\u5212\u95ee\u9898\u7f16\u7801\u4e3a\u65f6\u95f4\u81ea\u52a8\u673a\u7f51\u7edc\uff0c\u4f7f\u7528\u9ad8\u6548\u6a21\u578b\u68c0\u67e5\u5668\u9a8c\u8bc1\uff0c\u518d\u7528\u5f62\u5f0f\u5316\u9a8c\u8bc1\u7684\u8bc1\u4e66\u68c0\u67e5\u5668\u8ba4\u8bc1\u7ed3\u679c", "result": "\u5f00\u53d1\u4e86\u7ecf\u8fc7Isabelle/HOL\u5f62\u5f0f\u5316\u9a8c\u8bc1\u7684\u65f6\u95f4\u81ea\u52a8\u673a\u7f16\u7801\u5b9e\u73b0\u548c\u8bc1\u4e66\u68c0\u67e5\u6d41\u7a0b", "conclusion": "\u8be5\u65b9\u6cd5\u901a\u8fc7\u5f62\u5f0f\u5316\u9a8c\u8bc1\u786e\u4fdd\u4e86\u65f6\u95f4\u89c4\u5212\u4e0d\u53ef\u89e3\u6027\u8ba4\u8bc1\u7684\u53ef\u4fe1\u5ea6"}}
{"id": "2510.10015", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2510.10015", "abs": "https://arxiv.org/abs/2510.10015", "authors": ["Jinhua Wu", "Yuting Wang", "Liukun Yu", "Linglong Meng"], "title": "End-to-end Compositional Verification of Program Safety through Verified and Verifying Compilation", "comment": null, "summary": "Program safety (i.e., absence of undefined behaviors) is critical for correct\noperation of computer systems. It is usually verified at the source level\n(e.g., by separation logics) and preserved to the target by verified compilers\n(e.g., CompCert), thereby achieving end-to-end verification of safety. However,\nmodern safe programming languages like Rust pose new problems in achieving\nend-to-end safety. Because not all functionalities can be implemented in the\nsafe language, mixing safe and unsafe modules is needed. Therefore, verified\ncompilation must preserve a modular notion of safety which can be composed at\nthe target level. Furthermore, certain classes of errors (e.g., memory errors)\nare automatically excluded by verifying compilation (e.g., borrow checking) for\nmodules written in safe languages. As a result, verified compilation needs to\ncooperate with verifying compilation to ensure end-to-end safety.\n  To address the above problems, we propose a modular and generic definition of\nsafety called open safety based on program semantics described as open labeled\ntransition systems (LTS). Open safety is composable at the boundary of modules\nand can be modularly preserved by verified compositional compilation. Those\nproperties enable separate verification of safety for heterogeneous modules and\ncomposition of the safety results at the target level. Open safety can be\ngeneralized to partial safety (i.e., only a certain class of errors can occur).\nBy this we formalized the correctness of verifying compilation as derivation of\ntotal safety from partial safety. We demonstrate how our framework can combine\nverified and verifying compilation by developing a verified compiler for an\nownership language (called Owlang) inspired by Rust. We evaluate our approach\non the compositional safety verification using a hash map implemented by Owlang\nand C.", "AI": {"tldr": "\u63d0\u51fa\u57fa\u4e8e\u5f00\u653e\u6807\u8bb0\u8f6c\u79fb\u7cfb\u7edf\u7684\u5f00\u653e\u5b89\u5168\u6982\u5ff5\uff0c\u652f\u6301\u6a21\u5757\u5316\u5b89\u5168\u9a8c\u8bc1\u548c\u7ec4\u5408\u7f16\u8bd1\uff0c\u89e3\u51b3Rust\u7b49\u5b89\u5168\u8bed\u8a00\u4e2d\u6df7\u5408\u5b89\u5168/\u4e0d\u5b89\u5168\u6a21\u5757\u7684\u7aef\u5230\u7aef\u5b89\u5168\u9a8c\u8bc1\u95ee\u9898\u3002", "motivation": "\u73b0\u4ee3\u5b89\u5168\u7f16\u7a0b\u8bed\u8a00\u5982Rust\u9700\u8981\u6df7\u5408\u5b89\u5168\u548c\u4e0d\u5b89\u5168\u6a21\u5757\uff0c\u4f20\u7edf\u7aef\u5230\u7aef\u5b89\u5168\u9a8c\u8bc1\u65b9\u6cd5\u65e0\u6cd5\u5904\u7406\u6a21\u5757\u5316\u573a\u666f\uff0c\u9700\u8981\u65b0\u7684\u6a21\u5757\u5316\u5b89\u5168\u5b9a\u4e49\u548c\u9a8c\u8bc1\u6846\u67b6\u3002", "method": "\u57fa\u4e8e\u5f00\u653e\u6807\u8bb0\u8f6c\u79fb\u7cfb\u7edf\u5b9a\u4e49\u5f00\u653e\u5b89\u5168\u6982\u5ff5\uff0c\u652f\u6301\u6a21\u5757\u8fb9\u754c\u7ec4\u5408\u548c\u6a21\u5757\u5316\u4fdd\u6301\uff0c\u901a\u8fc7\u9a8c\u8bc1\u7ec4\u5408\u7f16\u8bd1\u5b9e\u73b0\u5f02\u6784\u6a21\u5757\u7684\u5206\u79bb\u9a8c\u8bc1\u548c\u76ee\u6807\u7ea7\u5b89\u5168\u7ed3\u679c\u7ec4\u5408\u3002", "result": "\u5f00\u53d1\u4e86\u6240\u6709\u6743\u8bed\u8a00Oolang\u7684\u9a8c\u8bc1\u7f16\u8bd1\u5668\uff0c\u901a\u8fc7\u54c8\u5e0c\u8868\u6848\u4f8b\u5c55\u793a\u4e86\u7ec4\u5408\u5b89\u5168\u9a8c\u8bc1\u7684\u6709\u6548\u6027\uff0c\u652f\u6301\u9a8c\u8bc1\u7f16\u8bd1\u548c\u9a8c\u8bc1\u7f16\u8bd1\u7684\u7ed3\u5408\u3002", "conclusion": "\u5f00\u653e\u5b89\u5168\u6846\u67b6\u4e3a\u6df7\u5408\u5b89\u5168/\u4e0d\u5b89\u5168\u6a21\u5757\u7684\u7cfb\u7edf\u63d0\u4f9b\u4e86\u6a21\u5757\u5316\u7aef\u5230\u7aef\u5b89\u5168\u9a8c\u8bc1\u7684\u7406\u8bba\u57fa\u7840\u548c\u5b9e\u8df5\u65b9\u6cd5\u3002"}}
{"id": "2510.09907", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.09907", "abs": "https://arxiv.org/abs/2510.09907", "authors": ["Muhammad Maaz", "Liam DeVoe", "Zac Hatfield-Dodds", "Nicholas Carlini"], "title": "Agentic Property-Based Testing: Finding Bugs Across the Python Ecosystem", "comment": "4 pages (main), NeurIPS 2025, The 4th Deep Learning for Code Workshop", "summary": "Property-based testing (PBT) is a lightweight formal method, typically\nimplemented as a randomized testing framework. Users specify the input domain\nfor their test using combinators supplied by the PBT framework, and the\nexpected properties or invariants as a unit-test function. The framework then\nsearches for a counterexample, e.g. by generating inputs and calling the test\nfunction. In this work, we demonstrate an LLM-based agent which analyzes Python\nmodules, infers function-specific and cross-function properties from code and\ndocumentation, synthesizes and executes PBTs, reflects on outputs of these\ntests to confirm true bugs, and finally outputs actionable bug reports for the\ndeveloper. We perform an extensive evaluation of our agent across 100 popular\nPython packages. Of the bug reports generated by the agent, we found after\nmanual review that 56\\% were valid bugs and 32\\% were valid bugs that we would\nreport to maintainers. We then developed a ranking rubric to surface\nhigh-priority valid bugs to developers, and found that of the 21 top-scoring\nbugs, 86\\% were valid and 81\\% we would report. The bugs span diverse failure\nmodes from serialization failures to numerical precision errors to flawed cache\nimplementations. We reported 5 bugs, 4 with patches, including to NumPy and\ncloud computing SDKs, with 3 patches merged successfully. Our results suggest\nthat LLMs with PBT provides a rigorous and scalable method for autonomously\ntesting software. Our code and artifacts are available at:\nhttps://github.com/mmaaz-git/agentic-pbt.", "AI": {"tldr": "\u5f00\u53d1\u4e86\u4e00\u4e2a\u57fa\u4e8eLLM\u7684\u4ee3\u7406\uff0c\u80fd\u591f\u81ea\u52a8\u5206\u6790Python\u4ee3\u7801\u3001\u63a8\u65ad\u5c5e\u6027\u3001\u751f\u6210\u548c\u6267\u884c\u57fa\u4e8e\u5c5e\u6027\u7684\u6d4b\u8bd5\uff0c\u5e76\u8f93\u51fa\u53ef\u64cd\u4f5c\u7684bug\u62a5\u544a\u3002\u5728100\u4e2a\u6d41\u884cPython\u5305\u4e0a\u7684\u8bc4\u4f30\u663e\u793a\uff0c56%\u7684bug\u62a5\u544a\u662f\u6709\u6548\u7684\uff0c32%\u503c\u5f97\u5411\u7ef4\u62a4\u8005\u62a5\u544a\u3002", "motivation": "\u57fa\u4e8e\u5c5e\u6027\u7684\u6d4b\u8bd5(PBT)\u662f\u4e00\u79cd\u8f7b\u91cf\u7ea7\u5f62\u5f0f\u5316\u65b9\u6cd5\uff0c\u4f46\u9700\u8981\u7528\u6237\u624b\u52a8\u6307\u5b9a\u8f93\u5165\u57df\u548c\u5c5e\u6027\u3002\u672c\u7814\u7a76\u65e8\u5728\u5229\u7528LLM\u81ea\u52a8\u5206\u6790\u4ee3\u7801\u3001\u63a8\u65ad\u5c5e\u6027\u5e76\u6267\u884cPBT\uff0c\u5b9e\u73b0\u81ea\u52a8\u5316\u8f6f\u4ef6\u6d4b\u8bd5\u3002", "method": "\u5f00\u53d1LLM\u4ee3\u7406\u5206\u6790Python\u6a21\u5757\uff0c\u4ece\u4ee3\u7801\u548c\u6587\u6863\u4e2d\u63a8\u65ad\u51fd\u6570\u7279\u5b9a\u548c\u8de8\u51fd\u6570\u5c5e\u6027\uff0c\u5408\u6210\u5e76\u6267\u884c\u57fa\u4e8e\u5c5e\u6027\u7684\u6d4b\u8bd5\uff0c\u901a\u8fc7\u6d4b\u8bd5\u8f93\u51fa\u786e\u8ba4\u771f\u5b9ebug\uff0c\u6700\u7ec8\u8f93\u51fa\u53ef\u64cd\u4f5c\u7684bug\u62a5\u544a\u3002", "result": "\u5728100\u4e2a\u6d41\u884cPython\u5305\u4e0a\u8bc4\u4f30\uff0c56%\u7684bug\u62a5\u544a\u6709\u6548\uff0c32%\u503c\u5f97\u62a5\u544a\u7ed9\u7ef4\u62a4\u8005\u3002\u4f7f\u7528\u6392\u540d\u6807\u51c6\u540e\uff0c21\u4e2a\u9ad8\u5206bug\u4e2d86%\u6709\u6548\uff0c81%\u503c\u5f97\u62a5\u544a\u3002\u62a5\u544a\u4e865\u4e2abug\uff08\u5176\u4e2d4\u4e2a\u5e26\u8865\u4e01\uff09\uff0c3\u4e2a\u8865\u4e01\u6210\u529f\u5408\u5e76\u3002", "conclusion": "LLM\u4e0ePBT\u7ed3\u5408\u63d0\u4f9b\u4e86\u4e00\u79cd\u4e25\u8c28\u4e14\u53ef\u6269\u5c55\u7684\u81ea\u4e3b\u8f6f\u4ef6\u6d4b\u8bd5\u65b9\u6cd5\uff0c\u80fd\u591f\u53d1\u73b0\u4ece\u5e8f\u5217\u5316\u5931\u8d25\u5230\u6570\u503c\u7cbe\u5ea6\u9519\u8bef\u7b49\u591a\u79cd\u7c7b\u578b\u7684bug\u3002"}}
{"id": "2510.11080", "categories": ["cs.LO"], "pdf": "https://arxiv.org/pdf/2510.11080", "abs": "https://arxiv.org/abs/2510.11080", "authors": ["Stefan Gebhart", "Lutz Schr\u00f6der", "Paul Wild"], "title": "Non-Expansive Fuzzy Coalgebraic Logic", "comment": null, "summary": "Fuzzy logic extends the classical truth values \"true\" and \"false\" with\nadditional truth degrees in between, typically real numbers in the unit\ninterval. More specifically, fuzzy modal logics in this sense are given by a\nchoice of fuzzy modalities and a fuzzy propositional base. It has been noted\nthat fuzzy modal logics over the Zadeh base, which interprets disjunction as\nmaximum, are often computationally tractable but on the other hand add little\nin the way of expressivity to their classical counterparts. Contrastingly,\nfuzzy modal logics over the more expressive Lukasiewicz base have attractive\nlogical properties but are often computationally less tractable or even\nundecidable. In the basic case of the modal logic of fuzzy relations, sometimes\ntermed fuzzy ALC, it has recently been shown that an intermediate non-expansive\npropositional base, known from characteristic logics for behavioural distances\nof quantitative systems, strikes a balance between these poles: It provides\nincreased expressiveness over the Zadeh base while avoiding the computational\nproblems of the Lukasiewicz base, in fact allowing for reasoning in PSpace.\nModal logics, in particular fuzzy modal logics, generally vary widely in terms\nof syntax and semantics, involving, for instance, probabilistic, preferential,\nor weighted structures. Coalgebraic modal logic provides a unifying framework\nfor wide ranges of semantically different modal logics, both two-valued and\nfuzzy. In the present work, we focus on non-expansive coalgebraic fuzzy modal\nlogics, providing a criterion for decidability in PSpace. Using this criterion,\nwe recover the mentioned complexity result for non-expansive fuzzy ALC and\nmoreover obtain new PSpace upper bounds for various quantitative modal logics\nfor probabilistic and metric transition systems.", "AI": {"tldr": "\u672c\u6587\u7814\u7a76\u4e86\u975e\u6269\u5f20\u6027coalgebraic\u6a21\u7cca\u6a21\u6001\u903b\u8f91\uff0c\u63d0\u51fa\u4e86\u4e00\u4e2aPSpace\u53ef\u5224\u5b9a\u6027\u6807\u51c6\uff0c\u5e76\u5e94\u7528\u4e8e\u6982\u7387\u548c\u5ea6\u91cf\u8f6c\u6362\u7cfb\u7edf\u7684\u5b9a\u91cf\u6a21\u6001\u903b\u8f91\u3002", "motivation": "\u6a21\u7cca\u6a21\u6001\u903b\u8f91\u5728Zadeh\u57fa\u4e0b\u8ba1\u7b97\u6613\u5904\u7406\u4f46\u8868\u8fbe\u80fd\u529b\u6709\u9650\uff0c\u800c\u5728Lukasiewicz\u57fa\u4e0b\u8868\u8fbe\u80fd\u529b\u5f3a\u4f46\u8ba1\u7b97\u590d\u6742\u3002\u672c\u6587\u65e8\u5728\u5bfb\u627e\u5728\u8868\u8fbe\u80fd\u529b\u548c\u8ba1\u7b97\u590d\u6742\u6027\u4e4b\u95f4\u53d6\u5f97\u5e73\u8861\u7684\u4e2d\u95f4\u65b9\u6848\u3002", "method": "\u4f7f\u7528\u975e\u6269\u5f20\u6027\u547d\u9898\u57fa\u7684coalgebraic\u6a21\u7cca\u6a21\u6001\u903b\u8f91\u6846\u67b6\uff0c\u63d0\u4f9b\u4e86\u4e00\u4e2aPSpace\u53ef\u5224\u5b9a\u6027\u6807\u51c6\u3002", "result": "\u6062\u590d\u4e86\u975e\u6269\u5f20\u6027\u6a21\u7ccaALC\u7684PSpace\u590d\u6742\u5ea6\u7ed3\u679c\uff0c\u5e76\u4e3a\u6982\u7387\u548c\u5ea6\u91cf\u8f6c\u6362\u7cfb\u7edf\u7684\u5404\u79cd\u5b9a\u91cf\u6a21\u6001\u903b\u8f91\u83b7\u5f97\u4e86\u65b0\u7684PSpace\u4e0a\u754c\u3002", "conclusion": "\u975e\u6269\u5f20\u6027coalgebraic\u6a21\u7cca\u6a21\u6001\u903b\u8f91\u5728\u8868\u8fbe\u80fd\u529b\u548c\u8ba1\u7b97\u590d\u6742\u6027\u4e4b\u95f4\u63d0\u4f9b\u4e86\u826f\u597d\u7684\u5e73\u8861\uff0c\u4e3a\u591a\u79cd\u5b9a\u91cf\u6a21\u6001\u903b\u8f91\u63d0\u4f9b\u4e86PSpace\u53ef\u5224\u5b9a\u6027\u4fdd\u8bc1\u3002"}}
{"id": "2510.10209", "categories": ["cs.PL", "cs.LG", "cs.PF"], "pdf": "https://arxiv.org/pdf/2510.10209", "abs": "https://arxiv.org/abs/2510.10209", "authors": ["Massinissa Merouani", "Afif Boudaoud", "Riyadh Baghdadi"], "title": "LOOPerSet: A Large-Scale Dataset for Data-Driven Polyhedral Compiler Optimization", "comment": null, "summary": "The advancement of machine learning for compiler optimization, particularly\nwithin the polyhedral model, is constrained by the scarcity of large-scale,\npublic performance datasets. This data bottleneck forces researchers to\nundertake costly data generation campaigns, slowing down innovation and\nhindering reproducible research learned code optimization. To address this gap,\nwe introduce LOOPerSet, a new public dataset containing 28 million labeled data\npoints derived from 220,000 unique, synthetically generated polyhedral\nprograms. Each data point maps a program and a complex sequence of\nsemantics-preserving transformations (such as fusion, skewing, tiling, and\nparallelism)to a ground truth performance measurement (execution time). The\nscale and diversity of LOOPerSet make it a valuable resource for training and\nevaluating learned cost models, benchmarking new model architectures, and\nexploring the frontiers of automated polyhedral scheduling. The dataset is\nreleased under a permissive license to foster reproducible research and lower\nthe barrier to entry for data-driven compiler optimization.", "AI": {"tldr": "LOOPerSet\u662f\u4e00\u4e2a\u5305\u542b2800\u4e07\u4e2a\u6807\u8bb0\u6570\u636e\u70b9\u7684\u5927\u89c4\u6a21\u516c\u5171\u6570\u636e\u96c6\uff0c\u7528\u4e8e\u89e3\u51b3\u673a\u5668\u5b66\u4e60\u5728\u7f16\u8bd1\u5668\u4f18\u5316\u4e2d\u6570\u636e\u7a00\u7f3a\u7684\u95ee\u9898\u3002", "motivation": "\u673a\u5668\u5b66\u4e60\u5728\u7f16\u8bd1\u5668\u4f18\u5316\uff08\u7279\u522b\u662f\u591a\u9762\u4f53\u6a21\u578b\uff09\u4e2d\u7684\u53d1\u5c55\u53d7\u5230\u5927\u89c4\u6a21\u516c\u5171\u6027\u80fd\u6570\u636e\u96c6\u7a00\u7f3a\u7684\u9650\u5236\uff0c\u8fd9\u5bfc\u81f4\u7814\u7a76\u4eba\u5458\u9700\u8981\u8fdb\u884c\u6602\u8d35\u7684\u6570\u636e\u751f\u6210\u6d3b\u52a8\uff0c\u51cf\u7f13\u4e86\u521b\u65b0\u901f\u5ea6\u5e76\u963b\u788d\u4e86\u53ef\u91cd\u73b0\u7684\u7814\u7a76\u3002", "method": "\u901a\u8fc7220,000\u4e2a\u72ec\u7279\u7684\u5408\u6210\u751f\u6210\u7684\u591a\u9762\u4f53\u7a0b\u5e8f\uff0c\u521b\u5efa\u4e86\u5305\u542b2800\u4e07\u4e2a\u6807\u8bb0\u6570\u636e\u70b9\u7684LOOPerSet\u6570\u636e\u96c6\u3002\u6bcf\u4e2a\u6570\u636e\u70b9\u5c06\u7a0b\u5e8f\u548c\u590d\u6742\u7684\u8bed\u4e49\u4fdd\u6301\u8f6c\u6362\u5e8f\u5217\u6620\u5c04\u5230\u771f\u5b9e\u7684\u6027\u80fd\u6d4b\u91cf\u503c\u3002", "result": "LOOPerSet\u6570\u636e\u96c6\u5177\u6709\u89c4\u6a21\u5927\u548c\u591a\u6837\u6027\u9ad8\u7684\u7279\u70b9\uff0c\u4e3a\u8bad\u7ec3\u548c\u8bc4\u4f30\u5b66\u4e60\u6210\u672c\u6a21\u578b\u3001\u57fa\u51c6\u6d4b\u8bd5\u65b0\u6a21\u578b\u67b6\u6784\u4ee5\u53ca\u63a2\u7d22\u81ea\u52a8\u5316\u591a\u9762\u4f53\u8c03\u5ea6\u524d\u6cbf\u63d0\u4f9b\u4e86\u5b9d\u8d35\u8d44\u6e90\u3002", "conclusion": "\u8be5\u6570\u636e\u96c6\u5728\u5bbd\u677e\u8bb8\u53ef\u4e0b\u53d1\u5e03\uff0c\u65e8\u5728\u4fc3\u8fdb\u53ef\u91cd\u73b0\u7814\u7a76\u5e76\u964d\u4f4e\u6570\u636e\u9a71\u52a8\u7f16\u8bd1\u5668\u4f18\u5316\u7684\u5165\u95e8\u95e8\u69db\u3002"}}
{"id": "2510.09938", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.09938", "abs": "https://arxiv.org/abs/2510.09938", "authors": ["Youshuai Tan", "Zishuo Ding", "Jinfu Chen", "Weiyi Shang"], "title": "OFP-Repair: Repairing Floating-point Errors via Original-Precision Arithmetic", "comment": null, "summary": "Errors in floating-point programs can lead to severe consequences,\nparticularly in critical domains such as military, aerospace, and financial\nsystems, making their repair a crucial research problem. In practice, some\nerrors can be fixed using original-precision arithmetic, while others require\nhigh-precision computation. Developers often avoid addressing the latter due to\nexcessive computational resources required. However, they sometimes struggle to\ndistinguish between these two types of errors, and existing repair tools fail\nto assist in this differentiation. Most current repair tools rely on\nhigh-precision implementations, which are time-consuming to develop and demand\nspecialized expertise. Although a few tools do not require high-precision\nprograms, they can only fix a limited subset of errors or produce suboptimal\nresults.\n  To address these challenges, we propose a novel method, named OFP-Repair.On\nACESO's dataset, our patches achieve improvements of three, seven, three, and\neight orders of magnitude across four accuracy metrics. In real-world cases,\nour method successfully detects all five original-precision-repairable errors\nand fixes three, whereas ACESO only repairs one. Notably, these results are\nbased on verified data and do not fully capture the potential of OFP-Repair. To\nfurther validate our method, we deploy it on a decade-old open bug report from\nGNU Scientific Library (GSL), successfully repairing five out of 15 bugs. The\ndevelopers have expressed interest in our method and are considering\nintegrating our tool into their development workflow. We are currently working\non applying our patches to GSL. The results are highly encouraging,\ndemonstrating the practical applicability of our technique.", "AI": {"tldr": "OFP-Repair\u662f\u4e00\u79cd\u65b0\u7684\u6d6e\u70b9\u7a0b\u5e8f\u9519\u8bef\u4fee\u590d\u65b9\u6cd5\uff0c\u80fd\u591f\u533a\u5206\u5e76\u4fee\u590d\u539f\u59cb\u7cbe\u5ea6\u548c\u9ad8\u7cbe\u5ea6\u8ba1\u7b97\u9519\u8bef\uff0c\u5728\u591a\u4e2a\u6570\u636e\u96c6\u4e0a\u8868\u73b0\u4f18\u4e8e\u73b0\u6709\u5de5\u5177\u3002", "motivation": "\u6d6e\u70b9\u7a0b\u5e8f\u9519\u8bef\u5728\u5173\u952e\u9886\u57df\u53ef\u80fd\u5bfc\u81f4\u4e25\u91cd\u540e\u679c\uff0c\u73b0\u6709\u4fee\u590d\u5de5\u5177\u8981\u4e48\u9700\u8981\u9ad8\u7cbe\u5ea6\u5b9e\u73b0\uff08\u5f00\u53d1\u8017\u65f6\u4e14\u9700\u8981\u4e13\u4e1a\u77e5\u8bc6\uff09\uff0c\u8981\u4e48\u53ea\u80fd\u4fee\u590d\u6709\u9650\u9519\u8bef\u6216\u4ea7\u751f\u6b21\u4f18\u7ed3\u679c\u3002", "method": "\u63d0\u51faOFP-Repair\u65b9\u6cd5\uff0c\u80fd\u591f\u533a\u5206\u539f\u59cb\u7cbe\u5ea6\u53ef\u4fee\u590d\u548c\u9ad8\u7cbe\u5ea6\u8ba1\u7b97\u9700\u6c42\u7684\u9519\u8bef\uff0c\u65e0\u9700\u4f9d\u8d56\u9ad8\u7cbe\u5ea6\u5b9e\u73b0\u3002", "result": "\u5728ACESO\u6570\u636e\u96c6\u4e0a\uff0c\u4fee\u590d\u8865\u4e01\u5728\u56db\u4e2a\u7cbe\u5ea6\u6307\u6807\u4e0a\u5206\u522b\u63d0\u5347\u4e863\u30017\u30013\u548c8\u4e2a\u6570\u91cf\u7ea7\uff1b\u5728\u771f\u5b9e\u6848\u4f8b\u4e2d\u6210\u529f\u68c0\u6d4b\u5e76\u4fee\u590d\u4e86\u66f4\u591a\u9519\u8bef\uff1b\u5728GSL\u5e93\u4e2d\u4fee\u590d\u4e8615\u4e2abug\u4e2d\u76845\u4e2a\u3002", "conclusion": "OFP-Repair\u65b9\u6cd5\u5177\u6709\u5b9e\u9645\u5e94\u7528\u4ef7\u503c\uff0c\u5f00\u53d1\u4eba\u5458\u5df2\u8868\u793a\u5174\u8da3\u5e76\u8003\u8651\u5c06\u5176\u96c6\u6210\u5230\u5f00\u53d1\u5de5\u4f5c\u6d41\u4e2d\u3002"}}
{"id": "2510.11199", "categories": ["cs.LO", "cs.PL"], "pdf": "https://arxiv.org/pdf/2510.11199", "abs": "https://arxiv.org/abs/2510.11199", "authors": ["Kaustuv Chaudhuri", "Daniele Nantes-Sobrinho"], "title": "Proceedings Twentieth International Workshop on Logical Frameworks and Meta-Languages: Theory and Practice", "comment": null, "summary": "These are the contributed papers presented at the 20th International Workshop\non Logical Frameworks and Meta-Languages: Theory and Practice (LFMTP 2025), at\nBirmingham, UK on 19 July as a satellite event of the FSCD conference. The\nprogram committee for this edition of LFMTP was chaired by Kaustuv Chaudhuri\nand Daniele Nantes-Sobrinho. More information about LFMTP can be found on\nhttps://lfmtp.org.", "AI": {"tldr": "\u8fd9\u662fLFMTP 2025\u7814\u8ba8\u4f1a\u7684\u8bba\u6587\u96c6\uff0c\u5305\u542b\u5728FSCD\u4f1a\u8bae\u536b\u661f\u6d3b\u52a8\u4e2d\u5c55\u793a\u7684\u8bba\u6587", "motivation": "\u6536\u96c6\u548c\u5c55\u793a\u903b\u8f91\u6846\u67b6\u4e0e\u5143\u8bed\u8a00\u9886\u57df\u7684\u6700\u65b0\u7814\u7a76\u6210\u679c\uff0c\u4fc3\u8fdb\u8be5\u9886\u57df\u7684\u5b66\u672f\u4ea4\u6d41", "method": "\u901a\u8fc7\u56fd\u9645\u7814\u8ba8\u4f1a\u5f62\u5f0f\uff0c\u9080\u8bf7\u7814\u7a76\u4eba\u5458\u63d0\u4ea4\u8bba\u6587\uff0c\u7ecf\u8fc7\u540c\u884c\u8bc4\u5ba1\u540e\u6536\u5f55", "result": "\u6210\u529f\u4e3e\u529e\u4e86\u7b2c20\u5c4aLFMTP\u7814\u8ba8\u4f1a\uff0c\u6c47\u96c6\u4e86\u8be5\u9886\u57df\u7684\u6700\u65b0\u7814\u7a76\u8fdb\u5c55", "conclusion": "LFMTP\u7ee7\u7eed\u4f5c\u4e3a\u903b\u8f91\u6846\u67b6\u548c\u5143\u8bed\u8a00\u9886\u57df\u7684\u91cd\u8981\u5b66\u672f\u4ea4\u6d41\u5e73\u53f0"}}
{"id": "2510.10216", "categories": ["cs.PL", "cs.AI", "cs.SE"], "pdf": "https://arxiv.org/pdf/2510.10216", "abs": "https://arxiv.org/abs/2510.10216", "authors": ["Zhechong Huang", "Zhao Zhang", "Ruyi Ji", "Tingxuan Xia", "Qihao Zhu", "Qinxiang Cao", "Zeyu Sun", "Yingfei Xiong"], "title": "Learning to Guarantee Type Correctness in Code Generation through Type-Guided Program Synthesis", "comment": null, "summary": "Language models have shown remarkable proficiency in code generation;\nnevertheless, ensuring type correctness remains a challenge. Although\ntraditional methods, such as constrained decoding, alleviate this problem by\nexternally rejecting untypable code, the model itself does not effectively\nlearn type reasoning internally, which ultimately limits its overall\nperformance. This paper introduces TyFlow, a novel system that internalizes\ntype reasoning within code generation to guide the model to learn the type\nsystem. The core of our approach is a novel type-guided program synthesis\nsystem that maintains an isomorphism between type derivation trees and\nsynthesis derivation trees, enabling a new code representation based on\nsynthesis decision sequences rather than traditional text-based token\nsequences. By offloading the complexity of type system learning to the\nrepresentation itself, models can redirect their computational resources toward\nhigher-level program semantics. Our evaluation shows that TyFlow not only\neliminates type errors but also significantly improves functional correctness,\nhighlighting the importance of aligning LMs with type systems internally.", "AI": {"tldr": "TyFlow\u662f\u4e00\u4e2a\u5c06\u7c7b\u578b\u63a8\u7406\u5185\u90e8\u5316\u5230\u4ee3\u7801\u751f\u6210\u4e2d\u7684\u65b0\u7cfb\u7edf\uff0c\u901a\u8fc7\u7c7b\u578b\u5f15\u5bfc\u7684\u7a0b\u5e8f\u5408\u6210\u6765\u6307\u5bfc\u6a21\u578b\u5b66\u4e60\u7c7b\u578b\u7cfb\u7edf\uff0c\u663e\u8457\u63d0\u9ad8\u4e86\u4ee3\u7801\u7684\u529f\u80fd\u6b63\u786e\u6027\u3002", "motivation": "\u8bed\u8a00\u6a21\u578b\u5728\u4ee3\u7801\u751f\u6210\u65b9\u9762\u8868\u73b0\u51fa\u8272\uff0c\u4f46\u786e\u4fdd\u7c7b\u578b\u6b63\u786e\u6027\u4ecd\u7136\u662f\u4e00\u4e2a\u6311\u6218\u3002\u4f20\u7edf\u65b9\u6cd5\u5982\u7ea6\u675f\u89e3\u7801\u53ea\u80fd\u5916\u90e8\u62d2\u7edd\u4e0d\u53ef\u7c7b\u578b\u5316\u7684\u4ee3\u7801\uff0c\u4f46\u6a21\u578b\u672c\u8eab\u6ca1\u6709\u6709\u6548\u5b66\u4e60\u7c7b\u578b\u63a8\u7406\uff0c\u8fd9\u9650\u5236\u4e86\u6574\u4f53\u6027\u80fd\u3002", "method": "TyFlow\u91c7\u7528\u7c7b\u578b\u5f15\u5bfc\u7684\u7a0b\u5e8f\u5408\u6210\u7cfb\u7edf\uff0c\u5728\u7c7b\u578b\u63a8\u5bfc\u6811\u548c\u5408\u6210\u63a8\u5bfc\u6811\u4e4b\u95f4\u4fdd\u6301\u540c\u6784\u5173\u7cfb\uff0c\u4f7f\u7528\u57fa\u4e8e\u5408\u6210\u51b3\u7b56\u5e8f\u5217\u7684\u65b0\u4ee3\u7801\u8868\u793a\u800c\u975e\u4f20\u7edf\u7684\u57fa\u4e8e\u6587\u672c\u7684\u6807\u8bb0\u5e8f\u5217\u3002", "result": "\u8bc4\u4f30\u663e\u793aTyFlow\u4e0d\u4ec5\u6d88\u9664\u4e86\u7c7b\u578b\u9519\u8bef\uff0c\u8fd8\u663e\u8457\u63d0\u9ad8\u4e86\u529f\u80fd\u6b63\u786e\u6027\uff0c\u8868\u660e\u5c06\u8bed\u8a00\u6a21\u578b\u4e0e\u7c7b\u578b\u7cfb\u7edf\u5185\u90e8\u5bf9\u9f50\u7684\u91cd\u8981\u6027\u3002", "conclusion": "\u901a\u8fc7\u5c06\u7c7b\u578b\u7cfb\u7edf\u5b66\u4e60\u7684\u590d\u6742\u6027\u5378\u8f7d\u5230\u8868\u793a\u672c\u8eab\uff0c\u6a21\u578b\u53ef\u4ee5\u5c06\u8ba1\u7b97\u8d44\u6e90\u91cd\u65b0\u5bfc\u5411\u66f4\u9ad8\u7ea7\u7684\u7a0b\u5e8f\u8bed\u4e49\uff0c\u4ece\u800c\u5728\u4ee3\u7801\u751f\u6210\u4e2d\u5b9e\u73b0\u66f4\u597d\u7684\u7c7b\u578b\u6b63\u786e\u6027\u548c\u529f\u80fd\u6b63\u786e\u6027\u3002"}}
{"id": "2510.09968", "categories": ["cs.SE", "cs.AI", "cs.CL", "cs.HC", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.09968", "abs": "https://arxiv.org/abs/2510.09968", "authors": ["Stefan Pasch"], "title": "Operationalizing AI: Empirical Evidence on MLOps Practices, User Satisfaction, and Organizational Context", "comment": null, "summary": "Organizational efforts to utilize and operationalize artificial intelligence\n(AI) are often accompanied by substantial challenges, including scalability,\nmaintenance, and coordination across teams. In response, the concept of Machine\nLearning Operations (MLOps) has emerged as a set of best practices that\nintegrate software engineering principles with the unique demands of managing\nthe ML lifecycle. Yet, empirical evidence on whether and how these practices\nsupport users in developing and operationalizing AI applications remains\nlimited. To address this gap, this study analyzes over 8,000 user reviews of AI\ndevelopment platforms from G2.com. Using zero-shot classification, we measure\nreview sentiment toward nine established MLOps practices, including continuous\nintegration and delivery (CI/CD), workflow orchestration, reproducibility,\nversioning, collaboration, and monitoring. Seven of the nine practices show a\nsignificant positive relationship with user satisfaction, suggesting that\neffective MLOps implementation contributes tangible value to AI development.\nHowever, organizational context also matters: reviewers from small firms\ndiscuss certain MLOps practices less frequently, suggesting that organizational\ncontext influences the prevalence and salience of MLOps, though firm size does\nnot moderate the MLOps-satisfaction link. This indicates that once applied,\nMLOps practices are perceived as universally beneficial across organizational\nsettings.", "AI": {"tldr": "\u8be5\u7814\u7a76\u5206\u6790\u4e868000\u591a\u6761AI\u5f00\u53d1\u5e73\u53f0\u7684\u7528\u6237\u8bc4\u8bba\uff0c\u53d1\u73b07\u79cdMLOps\u5b9e\u8df5\u4e0e\u7528\u6237\u6ee1\u610f\u5ea6\u663e\u8457\u6b63\u76f8\u5173\uff0c\u8868\u660e\u6709\u6548\u7684MLOps\u5b9e\u65bd\u4e3aAI\u5f00\u53d1\u5e26\u6765\u5b9e\u9645\u4ef7\u503c\u3002\u7ec4\u7ec7\u80cc\u666f\u5f71\u54cdMLOps\u5b9e\u8df5\u7684\u8ba8\u8bba\u9891\u7387\uff0c\u4f46\u4e0d\u5f71\u54cdMLOps\u4e0e\u6ee1\u610f\u5ea6\u7684\u5173\u7cfb\u3002", "motivation": "\u5c3d\u7ba1MLOps\u4f5c\u4e3a\u6574\u5408\u8f6f\u4ef6\u5de5\u7a0b\u539f\u5219\u4e0eML\u751f\u547d\u5468\u671f\u7ba1\u7406\u7684\u6700\u4f73\u5b9e\u8df5\u5df2\u7ecf\u51fa\u73b0\uff0c\u4f46\u5173\u4e8e\u8fd9\u4e9b\u5b9e\u8df5\u662f\u5426\u4ee5\u53ca\u5982\u4f55\u652f\u6301\u7528\u6237\u5f00\u53d1\u548c\u8fd0\u8425AI\u5e94\u7528\u7684\u5b9e\u8bc1\u8bc1\u636e\u4ecd\u7136\u6709\u9650\u3002", "method": "\u7814\u7a76\u5206\u6790\u4e86G2.com\u4e0a8000\u591a\u6761AI\u5f00\u53d1\u5e73\u53f0\u7684\u7528\u6237\u8bc4\u8bba\uff0c\u4f7f\u7528\u96f6\u6837\u672c\u5206\u7c7b\u65b9\u6cd5\u6d4b\u91cf\u8bc4\u8bba\u5bf99\u79cd\u5df2\u786e\u7acb\u7684MLOps\u5b9e\u8df5\u7684\u60c5\u611f\u503e\u5411\u3002", "result": "9\u79cdMLOps\u5b9e\u8df5\u4e2d\u76847\u79cd\u4e0e\u7528\u6237\u6ee1\u610f\u5ea6\u5448\u73b0\u663e\u8457\u6b63\u76f8\u5173\u5173\u7cfb\uff0c\u8868\u660e\u6709\u6548\u7684MLOps\u5b9e\u65bd\u4e3aAI\u5f00\u53d1\u5e26\u6765\u5b9e\u9645\u4ef7\u503c\u3002\u5c0f\u578b\u4f01\u4e1a\u7684\u8bc4\u8bba\u8005\u8f83\u5c11\u8ba8\u8bba\u67d0\u4e9bMLOps\u5b9e\u8df5\uff0c\u4f46\u4f01\u4e1a\u89c4\u6a21\u4e0d\u8c03\u8282MLOps\u4e0e\u6ee1\u610f\u5ea6\u4e4b\u95f4\u7684\u8054\u7cfb\u3002", "conclusion": "\u4e00\u65e6\u5e94\u7528\uff0cMLOps\u5b9e\u8df5\u5728\u4e0d\u540c\u7ec4\u7ec7\u73af\u5883\u4e2d\u90fd\u88ab\u8ba4\u4e3a\u662f\u666e\u904d\u6709\u76ca\u7684\u3002\u7ec4\u7ec7\u80cc\u666f\u5f71\u54cdMLOps\u5b9e\u8df5\u7684\u8ba8\u8bba\u9891\u7387\uff0c\u4f46\u4e0d\u5f71\u54cdMLOps\u4e0e\u6ee1\u610f\u5ea6\u7684\u5173\u7cfb\u3002"}}
{"id": "2510.11293", "categories": ["cs.LO", "math.LO"], "pdf": "https://arxiv.org/pdf/2510.11293", "abs": "https://arxiv.org/abs/2510.11293", "authors": ["Bahareh Afshari", "Johannes Kloibhofer"], "title": "Cut-elimination for the alternation-free modal mu-calculus", "comment": null, "summary": "We present a syntactic cut-elimination procedure for the alternation-free\nfragment of the modal mu-calculus. Cut reduction is carried out within a cyclic\nproof system, where proofs are finitely branching but may be non-wellfounded.\nThe structure of such proofs is exploited to directly transform a cyclic proof\nwith cuts into a cut-free one, without detouring through other logics or\nrelying on intermediate machinery for regularisation. Novel ingredients include\nthe use of multicuts and results from the theory of well-quasi-orders, the\nlater used in the termination argument.", "AI": {"tldr": "\u63d0\u51fa\u4e86\u6a21\u6001\u03bc\u6f14\u7b97\u65e0\u4ea4\u66ff\u7247\u6bb5\u7684\u8bed\u6cd5\u5207\u5272\u6d88\u9664\u7a0b\u5e8f\uff0c\u5728\u5faa\u73af\u8bc1\u660e\u7cfb\u7edf\u4e2d\u8fdb\u884c\u5207\u5272\u7ea6\u7b80\uff0c\u5229\u7528\u975e\u826f\u57fa\u8bc1\u660e\u7ed3\u6784\u76f4\u63a5\u5c06\u6709\u5207\u5272\u7684\u5faa\u73af\u8bc1\u660e\u8f6c\u6362\u4e3a\u65e0\u5207\u5272\u8bc1\u660e", "motivation": "\u4e3a\u6a21\u6001\u03bc\u6f14\u7b97\u7684\u65e0\u4ea4\u66ff\u7247\u6bb5\u5f00\u53d1\u76f4\u63a5\u7684\u5207\u5272\u6d88\u9664\u65b9\u6cd5\uff0c\u907f\u514d\u901a\u8fc7\u5176\u4ed6\u903b\u8f91\u6216\u4f9d\u8d56\u6b63\u5219\u5316\u4e2d\u95f4\u673a\u5236", "method": "\u5728\u5faa\u73af\u8bc1\u660e\u7cfb\u7edf\u4e2d\u4f7f\u7528\u591a\u5207\u5272\u548c\u826f\u62df\u5e8f\u7406\u8bba\uff0c\u5229\u7528\u975e\u826f\u57fa\u4f46\u6709\u9650\u5206\u652f\u7684\u8bc1\u660e\u7ed3\u6784\u8fdb\u884c\u76f4\u63a5\u8f6c\u6362", "result": "\u6210\u529f\u5b9e\u73b0\u4e86\u4ece\u6709\u5207\u5272\u5faa\u73af\u8bc1\u660e\u5230\u65e0\u5207\u5272\u8bc1\u660e\u7684\u76f4\u63a5\u8f6c\u6362", "conclusion": "\u8be5\u65b9\u6cd5\u4e3a\u6a21\u6001\u03bc\u6f14\u7b97\u65e0\u4ea4\u66ff\u7247\u6bb5\u63d0\u4f9b\u4e86\u65b0\u9896\u7684\u8bed\u6cd5\u5207\u5272\u6d88\u9664\u7a0b\u5e8f"}}
{"id": "2510.10219", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2510.10219", "abs": "https://arxiv.org/abs/2510.10219", "authors": ["Ruihao Li", "Lizy K. John", "Neeraja J. Yadwadkar"], "title": "Old is Gold: Optimizing Single-threaded Applications with Exgen-Malloc", "comment": null, "summary": "Memory allocators hide beneath nearly every application stack, yet their\nperformance footprint extends far beyond their code size. Even small\ninefficiencies in the allocators ripple through caches and the rest of the\nmemory hierarchy, collectively imposing what operators often call a \"datacenter\ntax\". At hyperscale, even a 1% improvement in allocator efficiency can unlock\nmillions of dollars in savings and measurable reductions in datacenter energy\nconsumption. Modern memory allocators are designed to optimize allocation speed\nand memory fragmentation in multi-threaded environments, relying on complex\nmetadata and control logic to achieve high performance. However, the overhead\nintroduced by this complexity prompts a reevaluation of allocator design.\nNotably, such overhead can be avoided in single-threaded scenarios, which\ncontinue to be widely used across diverse application domains.\n  In this paper, we introduce Exgen-Malloc, a memory allocator purpose-built\nfor single-threaded applications. By specializing for single-threaded\nexecution, Exgen-Malloc eliminates unnecessary metadata, simplifies the control\nflow, thereby reducing overhead and improving allocation efficiency. Its core\ndesign features include a centralized heap, a single free-block list, and a\nbalanced strategy for memory commitment and relocation. Additionally,\nExgen-Malloc incorporates design principles in modern multi-threaded\nallocators, which do not exist in legacy single-threaded allocators such as\ndlmalloc. We evaluate Exgen-Malloc on two Intel Xeon platforms. Across both\nsystems, Exgen-Malloc achieves a speedup of 1.17x, 1.10x, and 1.93x over\ndlmalloc on SPEC CPU2017, redis-benchmark, and mimalloc-bench, respectively. In\naddition to performance, Exgen-Malloc achieves 6.2%, 0.1%, and 25.2% memory\nsavings over mimalloc on SPEC CPU2017, redis-benchmark, and mimalloc-bench,\nrespectively.", "AI": {"tldr": "Exgen-Malloc\u662f\u4e00\u4e2a\u4e13\u4e3a\u5355\u7ebf\u7a0b\u5e94\u7528\u8bbe\u8ba1\u7684\u5185\u5b58\u5206\u914d\u5668\uff0c\u901a\u8fc7\u6d88\u9664\u591a\u7ebf\u7a0b\u73af\u5883\u4e0b\u7684\u590d\u6742\u5143\u6570\u636e\u548c\u7b80\u5316\u63a7\u5236\u6d41\uff0c\u663e\u8457\u63d0\u5347\u4e86\u5206\u914d\u6548\u7387\u548c\u5185\u5b58\u5229\u7528\u7387\u3002", "motivation": "\u73b0\u4ee3\u5185\u5b58\u5206\u914d\u5668\u4e3a\u591a\u7ebf\u7a0b\u73af\u5883\u4f18\u5316\uff0c\u4f46\u5728\u5355\u7ebf\u7a0b\u573a\u666f\u4e0b\u4f1a\u5f15\u5165\u4e0d\u5fc5\u8981\u7684\u5f00\u9500\u3002\u5728\u8d85\u5927\u89c4\u6a21\u6570\u636e\u4e2d\u5fc3\uff0c\u5373\u4f7f1%\u7684\u6548\u7387\u63d0\u5347\u4e5f\u80fd\u5e26\u6765\u6570\u767e\u4e07\u7f8e\u5143\u7684\u8282\u7701\u548c\u80fd\u8017\u964d\u4f4e\u3002", "method": "\u91c7\u7528\u96c6\u4e2d\u5f0f\u5806\u3001\u5355\u4e00\u7a7a\u95f2\u5757\u5217\u8868\u3001\u5e73\u8861\u7684\u5185\u5b58\u63d0\u4ea4\u548c\u91cd\u5b9a\u4f4d\u7b56\u7565\uff0c\u5e76\u501f\u9274\u73b0\u4ee3\u591a\u7ebf\u7a0b\u5206\u914d\u5668\u7684\u8bbe\u8ba1\u539f\u5219\uff0c\u540c\u65f6\u6d88\u9664\u4e0d\u5fc5\u8981\u7684\u5143\u6570\u636e\u548c\u7b80\u5316\u63a7\u5236\u6d41\u3002", "result": "\u5728\u4e24\u4e2aIntel Xeon\u5e73\u53f0\u4e0a\u6d4b\u8bd5\uff0c\u76f8\u6bd4dlmalloc\u5728SPEC CPU2017\u3001redis-benchmark\u548cmimalloc-bench\u4e0a\u5206\u522b\u83b7\u5f971.17x\u30011.10x\u548c1.93x\u7684\u901f\u5ea6\u63d0\u5347\uff1b\u76f8\u6bd4mimalloc\u5206\u522b\u8282\u77016.2%\u30010.1%\u548c25.2%\u7684\u5185\u5b58\u3002", "conclusion": "\u4e13\u4e3a\u5355\u7ebf\u7a0b\u5e94\u7528\u5b9a\u5236\u7684\u5185\u5b58\u5206\u914d\u5668\u80fd\u591f\u663e\u8457\u63d0\u5347\u6027\u80fd\u548c\u5185\u5b58\u6548\u7387\uff0c\u8bc1\u660e\u4e86\u5728\u7279\u5b9a\u573a\u666f\u4e0b\u7b80\u5316\u8bbe\u8ba1\u7684\u91cd\u8981\u6027\u3002"}}
{"id": "2510.10010", "categories": ["cs.SE", "cs.AI", "68N01, 68T05, 68T07", "D.2.5; D.2.7; I.2.2; I.2.6"], "pdf": "https://arxiv.org/pdf/2510.10010", "abs": "https://arxiv.org/abs/2510.10010", "authors": ["Matheus J. T. Vargas"], "title": "SLEAN: Simple Lightweight Ensemble Analysis Network for Multi-Provider LLM Coordination: Design, Implementation, and Vibe Coding Bug Investigation Case Study", "comment": "14 pages, 4 figures, 6 tables, link to code repo", "summary": "We present SLEAN (Simple Lightweight Ensemble Analysis Network), a\ndeterministic framework for coordinating multiple LLM providers through\ntext-based prompt orchestration. Unlike complex multi-agent systems requiring\nspecialized infrastructure, SLEAN operates as a simple prompt bridge between\nLLMs using .txt templates, requiring no deep technical knowledge for\ndeployment. The three-phase protocol formed by independent analysis,\ncross-critique, and arbitration, filters harmful AI-generated code suggestions\nbefore production deployment, addressing how AI-assisted debugging increasingly\nproduces modifications that introduce unnecessary complexity, break existing\nfunctionality, or address problems. Evaluating 15 software bugs, we analyzed 69\nAI-generated fix propositions. SLEAN's filtering accepted 22 fixes (31.9%, 95%\nCI 20.9-42.9%) while rejecting 47 that would have been harmful if applied\nverbatim. The arbitration process reduced code change surface by 83-90%\nrelative to raw AI outputs, enforcing minimal causal edits over scope-expanding\nmodifications. Minimal Type 2 inputs proved more efficient than detailed Type 1\ninputs, requiring 2.85 versus 3.56 propositions per accepted fix (35.1% versus\n28.1% acceptance, about a 20% efficiency gain). Agreement between AI systems\nshowed weak correlation with fix quality: high convergence (at least 80%)\noccurred in 4 of 15 cases and improved acceptance by only 2.4% points;\narbitration appeared only at exactly 10% convergence in 2 of 15 cases, although\nlow convergence alone did not necessitate arbitration. The file-driven,\nprovider-agnostic architecture enables deployment without specialized coding\nexpertise, making it applicable to security auditing, code review, document\nverification, and other domains requiring reliable multi-provider synthesis\nwith end-to-end auditability.", "AI": {"tldr": "SLEAN\u662f\u4e00\u4e2a\u7b80\u5355\u7684\u8f7b\u91cf\u7ea7\u96c6\u6210\u5206\u6790\u6846\u67b6\uff0c\u901a\u8fc7\u6587\u672c\u63d0\u793a\u7f16\u6392\u534f\u8c03\u591a\u4e2aLLM\u63d0\u4f9b\u5546\uff0c\u91c7\u7528\u4e09\u9636\u6bb5\u534f\u8bae\u8fc7\u6ee4\u6709\u5bb3\u7684AI\u751f\u6210\u4ee3\u7801\u5efa\u8bae\uff0c\u51cf\u5c1183-90%\u7684\u4ee3\u7801\u53d8\u66f4\u8868\u9762\uff0c\u5b9e\u73b0\u6700\u5c0f\u56e0\u679c\u7f16\u8f91\u3002", "motivation": "\u89e3\u51b3AI\u8f85\u52a9\u8c03\u8bd5\u4e2d\u4ea7\u751f\u7684\u4e0d\u5fc5\u8981\u590d\u6742\u6027\u3001\u7834\u574f\u73b0\u6709\u529f\u80fd\u6216\u9519\u8bef\u89e3\u51b3\u95ee\u9898\u7684\u4fee\u6539\uff0c\u63d0\u4f9b\u53ef\u9760\u7684\u591a\u63d0\u4f9b\u5546\u5408\u6210\u548c\u7aef\u5230\u7aef\u53ef\u5ba1\u8ba1\u6027\u3002", "method": "\u4f7f\u7528\u57fa\u4e8e.txt\u6a21\u677f\u7684\u7b80\u5355\u63d0\u793a\u6865\u63a5LLM\uff0c\u91c7\u7528\u72ec\u7acb\u5206\u6790\u3001\u4ea4\u53c9\u6279\u8bc4\u548c\u4ef2\u88c1\u7684\u4e09\u9636\u6bb5\u534f\u8bae\uff0c\u65e0\u9700\u4e13\u4e1a\u6280\u672f\u77e5\u8bc6\u5373\u53ef\u90e8\u7f72\u3002", "result": "\u572815\u4e2a\u8f6f\u4ef6bug\u8bc4\u4f30\u4e2d\uff0c\u4ece69\u4e2aAI\u751f\u6210\u7684\u4fee\u590d\u5efa\u8bae\u4e2d\u63a5\u53d7\u4e8622\u4e2a\u4fee\u590d\uff0831.9%\uff09\uff0c\u62d2\u7edd\u4e8647\u4e2a\u6709\u5bb3\u5efa\u8bae\uff0c\u4ef2\u88c1\u8fc7\u7a0b\u5c06\u4ee3\u7801\u53d8\u66f4\u8868\u9762\u51cf\u5c11\u4e8683-90%\u3002", "conclusion": "SLEAN\u7684\u6587\u4ef6\u9a71\u52a8\u3001\u63d0\u4f9b\u5546\u65e0\u5173\u67b6\u6784\u4f7f\u5176\u9002\u7528\u4e8e\u5b89\u5168\u5ba1\u8ba1\u3001\u4ee3\u7801\u5ba1\u67e5\u3001\u6587\u6863\u9a8c\u8bc1\u7b49\u9886\u57df\uff0c\u65e0\u9700\u4e13\u95e8\u7f16\u7801\u4e13\u4e1a\u77e5\u8bc6\u5373\u53ef\u90e8\u7f72\u3002"}}
{"id": "2510.11320", "categories": ["cs.LO"], "pdf": "https://arxiv.org/pdf/2510.11320", "abs": "https://arxiv.org/abs/2510.11320", "authors": ["Kazuki Watanabe", "Mayuko Kori", "Taro Sekiyama", "Satoshi Kura", "Hiroshi Unno"], "title": "A Denotational Product Construction for Temporal Verification of Effectful Higher-Order Programs", "comment": "Preprint", "summary": "We propose a categorical framework for linear-time temporal verification of\neffectful higher-order programs, including probabilistic higher-order programs.\nOur framework provides a generic denotational reduction -- namely, a\ndenotational product construction -- from linear-time safety verification of\neffectful higher-order programs to computation of weakest pre-conditions of\nproduct programs. This reduction enables us to apply existing algorithms for\nsuch well-studied computations of weakest pre-conditions, some of which are\navailable as off-the-shelf solvers. We show the correctness of our denotational\nproduct construction by proving a preservation theorem under strong monad\nmorphisms and an existence of suitable liftings along a fibration. We\ninstantiate our framework with both probabilistic and angelic nondeterministic\nhigher-order programs, and implement an automated solver for the probabilistic\ncase based on the existing solver developed by Kura and Unno. To the best of\nour knowledge, this is the first automated verifier for linear-time temporal\nverification of probabilistic higher-order programs with recursion.", "AI": {"tldr": "\u63d0\u51fa\u4e86\u4e00\u4e2a\u8303\u7574\u6846\u67b6\uff0c\u7528\u4e8e\u5bf9\u5e26\u6709\u526f\u6548\u5e94\u7684\u9ad8\u9636\u7a0b\u5e8f\u8fdb\u884c\u7ebf\u6027\u65f6\u5e8f\u9a8c\u8bc1\uff0c\u5305\u62ec\u6982\u7387\u6027\u9ad8\u9636\u7a0b\u5e8f\u3002\u8be5\u6846\u67b6\u901a\u8fc7\u8303\u7574\u5316\u4e58\u79ef\u6784\u9020\uff0c\u5c06\u7ebf\u6027\u65f6\u5e8f\u5b89\u5168\u9a8c\u8bc1\u8f6c\u5316\u4e3a\u4e58\u79ef\u7a0b\u5e8f\u7684\u6700\u5f31\u524d\u7f6e\u6761\u4ef6\u8ba1\u7b97\u3002", "motivation": "\u73b0\u6709\u65b9\u6cd5\u96be\u4ee5\u81ea\u52a8\u5316\u9a8c\u8bc1\u5e26\u6709\u526f\u6548\u5e94\uff08\u5982\u6982\u7387\u6027\uff09\u7684\u9ad8\u9636\u7a0b\u5e8f\u7684\u7ebf\u6027\u65f6\u5e8f\u6027\u8d28\uff0c\u9700\u8981\u5f00\u53d1\u901a\u7528\u6846\u67b6\u6765\u7edf\u4e00\u5904\u7406\u8fd9\u7c7b\u95ee\u9898\u3002", "method": "\u4f7f\u7528\u8303\u7574\u5316\u4e58\u79ef\u6784\u9020\uff08denotational product construction\uff09\uff0c\u5c06\u6548\u5e94\u9ad8\u9636\u7a0b\u5e8f\u7684\u7ebf\u6027\u65f6\u5e8f\u9a8c\u8bc1\u8f6c\u5316\u4e3a\u4e58\u79ef\u7a0b\u5e8f\u7684\u6700\u5f31\u524d\u7f6e\u6761\u4ef6\u8ba1\u7b97\uff0c\u5e76\u5229\u7528\u73b0\u6709\u6c42\u89e3\u5668\u3002", "result": "\u5b9e\u73b0\u4e86\u6982\u7387\u6027\u548c\u5929\u4f7f\u975e\u786e\u5b9a\u6027\u9ad8\u9636\u7a0b\u5e8f\u7684\u5b9e\u4f8b\u5316\uff0c\u5e76\u57fa\u4e8eKura\u548cUnno\u7684\u6c42\u89e3\u5668\u5f00\u53d1\u4e86\u6982\u7387\u60c5\u51b5\u7684\u81ea\u52a8\u5316\u9a8c\u8bc1\u5668\u3002", "conclusion": "\u8fd9\u662f\u9996\u4e2a\u652f\u6301\u9012\u5f52\u6982\u7387\u9ad8\u9636\u7a0b\u5e8f\u7ebf\u6027\u65f6\u5e8f\u9a8c\u8bc1\u7684\u81ea\u52a8\u5316\u9a8c\u8bc1\u5668\uff0c\u901a\u8fc7\u8303\u7574\u6846\u67b6\u5b9e\u73b0\u4e86\u901a\u7528\u4e14\u53ef\u6269\u5c55\u7684\u9a8c\u8bc1\u65b9\u6cd5\u3002"}}
{"id": "2510.10410", "categories": ["cs.PL", "cs.SE"], "pdf": "https://arxiv.org/pdf/2510.10410", "abs": "https://arxiv.org/abs/2510.10410", "authors": ["Hui Xu"], "title": "A Trace-based Approach for Code Safety Analysis", "comment": null, "summary": "Rust is a memory-safe programming language that disallows undefined behavior.\nIts safety guarantees have been extensively examined by the community through\nempirical studies, which has led to its remarkable success. However, unsafe\ncode remains a critical concern in Rust. By reviewing the safety design of Rust\nand analyzing real-world Rust projects, this paper establishes a systematic\nframework for understanding unsafe code and undefined behavior, and summarizes\nthe soundness criteria for Rust code. It further derives actionable guidance\nfor achieving sound encapsulation.", "AI": {"tldr": "\u672c\u6587\u7cfb\u7edf\u5206\u6790\u4e86Rust\u8bed\u8a00\u4e2d\u7684\u4e0d\u5b89\u5168\u4ee3\u7801\u548c\u672a\u5b9a\u4e49\u884c\u4e3a\u95ee\u9898\uff0c\u5efa\u7acb\u4e86\u7406\u89e3\u6846\u67b6\u5e76\u603b\u7ed3\u4e86Rust\u4ee3\u7801\u7684\u6b63\u786e\u6027\u6807\u51c6\uff0c\u4e3a\u5b89\u5168\u5c01\u88c5\u63d0\u4f9b\u4e86\u5b9e\u8df5\u6307\u5bfc\u3002", "motivation": "Rust\u4f5c\u4e3a\u5185\u5b58\u5b89\u5168\u7f16\u7a0b\u8bed\u8a00\u867d\u7136\u7981\u6b62\u672a\u5b9a\u4e49\u884c\u4e3a\uff0c\u4f46\u4e0d\u5b89\u5168\u4ee3\u7801\u4ecd\u7136\u662f\u5173\u952e\u95ee\u9898\u3002\u901a\u8fc7\u5ba1\u67e5Rust\u7684\u5b89\u5168\u8bbe\u8ba1\u548c\u5206\u6790\u5b9e\u9645\u9879\u76ee\uff0c\u9700\u8981\u5efa\u7acb\u7cfb\u7edf\u6846\u67b6\u6765\u7406\u89e3\u4e0d\u5b89\u5168\u4ee3\u7801\u548c\u672a\u5b9a\u4e49\u884c\u4e3a\u3002", "method": "\u56de\u987eRust\u7684\u5b89\u5168\u8bbe\u8ba1\uff0c\u5206\u6790\u771f\u5b9e\u4e16\u754c\u7684Rust\u9879\u76ee\uff0c\u5efa\u7acb\u7cfb\u7edf\u5316\u7684\u6846\u67b6\u6765\u7406\u89e3\u4e0d\u5b89\u5168\u4ee3\u7801\u548c\u672a\u5b9a\u4e49\u884c\u4e3a\uff0c\u603b\u7ed3Rust\u4ee3\u7801\u7684\u6b63\u786e\u6027\u6807\u51c6\u3002", "result": "\u5efa\u7acb\u4e86\u7406\u89e3\u4e0d\u5b89\u5168\u4ee3\u7801\u548c\u672a\u5b9a\u4e49\u884c\u4e3a\u7684\u7cfb\u7edf\u6846\u67b6\uff0c\u603b\u7ed3\u4e86Rust\u4ee3\u7801\u7684\u6b63\u786e\u6027\u6807\u51c6\uff0c\u5e76\u63a8\u5bfc\u51fa\u5b9e\u73b0\u5b89\u5168\u5c01\u88c5\u7684\u53ef\u64cd\u4f5c\u6307\u5bfc\u3002", "conclusion": "\u8be5\u7814\u7a76\u4e3aRust\u8bed\u8a00\u4e2d\u7684\u4e0d\u5b89\u5168\u4ee3\u7801\u95ee\u9898\u63d0\u4f9b\u4e86\u7cfb\u7edf\u6027\u5206\u6790\u6846\u67b6\u548c\u5b9e\u8df5\u6307\u5bfc\uff0c\u6709\u52a9\u4e8e\u63d0\u9ad8Rust\u4ee3\u7801\u7684\u5b89\u5168\u6027\u548c\u53ef\u9760\u6027\u3002"}}
{"id": "2510.10066", "categories": ["cs.SE", "cs.AI", "cs.PL"], "pdf": "https://arxiv.org/pdf/2510.10066", "abs": "https://arxiv.org/abs/2510.10066", "authors": ["Shan Jiang", "Chenguang Zhu", "Sarfraz Khurshid"], "title": "OBsmith: Testing JavaScript Obfuscator using LLM-powered sketching", "comment": null, "summary": "JavaScript obfuscators are widely deployed to protect intellectual property\nand resist reverse engineering, yet their correctness has been largely\noverlooked compared to performance and resilience. Existing evaluations\ntypically measure resistance to deobfuscation, leaving the critical question of\nwhether obfuscators preserve program semantics unanswered. Incorrect\ntransformations can silently alter functionality, compromise reliability, and\nerode security-undermining the very purpose of obfuscation. To address this\ngap, we present OBsmith, a novel framework to systematically test JavaScript\nobfuscators using large language models (LLMs). OBsmith leverages LLMs to\ngenerate program sketches abstract templates capturing diverse language\nconstructs, idioms, and corner cases-which are instantiated into executable\nprograms and subjected to obfuscation under different configurations. Besides\nLLM-powered sketching, OBsmith also employs a second source: automatic\nextraction of sketches from real programs. This extraction path enables more\nfocused testing of project specific features and lets developers inject domain\nknowledge into the resulting test cases. OBsmith uncovers 11 previously unknown\ncorrectness bugs. Under an equal program budget, five general purpose\nstate-of-the-art JavaScript fuzzers (FuzzJIT, Jsfunfuzz, Superion, DIE,\nFuzzilli) failed to detect these issues, highlighting OBsmith's complementary\nfocus on obfuscation induced misbehavior. An ablation shows that all components\nexcept our generic MRs contribute to at least one bug class; the negative MR\nresult suggests the need for obfuscator-specific metamorphic relations. Our\nresults also seed discussion on how to balance obfuscation presets and\nperformance cost. We envision OBsmith as an important step towards automated\ntesting and quality assurance of obfuscators and other semantic-preserving\ntoolchains.", "AI": {"tldr": "OBsmith\u662f\u4e00\u4e2a\u57fa\u4e8e\u5927\u8bed\u8a00\u6a21\u578b\u7684JavaScript\u6df7\u6dc6\u5668\u6d4b\u8bd5\u6846\u67b6\uff0c\u901a\u8fc7\u751f\u6210\u7a0b\u5e8f\u6a21\u677f\u548c\u4ece\u771f\u5b9e\u7a0b\u5e8f\u4e2d\u63d0\u53d6\u6a21\u677f\u6765\u7cfb\u7edf\u6027\u5730\u6d4b\u8bd5\u6df7\u6dc6\u5668\u7684\u8bed\u4e49\u4fdd\u6301\u80fd\u529b\uff0c\u53d1\u73b0\u4e8611\u4e2a\u672a\u77e5\u7684\u6b63\u786e\u6027bug\u3002", "motivation": "\u73b0\u6709\u7684\u6df7\u6dc6\u5668\u8bc4\u4f30\u4e3b\u8981\u5173\u6ce8\u6297\u53cd\u6df7\u6dc6\u80fd\u529b\uff0c\u800c\u5ffd\u7565\u4e86\u8bed\u4e49\u4fdd\u6301\u8fd9\u4e00\u5173\u952e\u95ee\u9898\u3002\u4e0d\u6b63\u786e\u7684\u8f6c\u6362\u53ef\u80fd\u65e0\u58f0\u5730\u6539\u53d8\u529f\u80fd\u3001\u635f\u5bb3\u53ef\u9760\u6027\u548c\u5b89\u5168\u6027\uff0c\u8fdd\u80cc\u4e86\u6df7\u6dc6\u7684\u6839\u672c\u76ee\u7684\u3002", "method": "OBsmith\u5229\u7528LLM\u751f\u6210\u7a0b\u5e8f\u6a21\u677f\uff08\u6355\u6349\u4e0d\u540c\u8bed\u8a00\u7ed3\u6784\u3001\u4e60\u8bed\u548c\u8fb9\u754c\u60c5\u51b5\uff09\uff0c\u5e76\u5c06\u8fd9\u4e9b\u6a21\u677f\u5b9e\u4f8b\u5316\u4e3a\u53ef\u6267\u884c\u7a0b\u5e8f\uff0c\u5728\u4e0d\u540c\u914d\u7f6e\u4e0b\u8fdb\u884c\u6df7\u6dc6\u6d4b\u8bd5\u3002\u540c\u65f6\u4ece\u771f\u5b9e\u7a0b\u5e8f\u4e2d\u81ea\u52a8\u63d0\u53d6\u6a21\u677f\uff0c\u5b9e\u73b0\u66f4\u6709\u9488\u5bf9\u6027\u7684\u6d4b\u8bd5\u3002", "result": "\u53d1\u73b0\u4e8611\u4e2a\u4e4b\u524d\u672a\u77e5\u7684\u6b63\u786e\u6027bug\u3002\u5728\u76f8\u540c\u7a0b\u5e8f\u9884\u7b97\u4e0b\uff0c\u4e94\u4e2a\u6700\u5148\u8fdb\u7684JavaScript\u6a21\u7cca\u6d4b\u8bd5\u5de5\u5177\u90fd\u65e0\u6cd5\u68c0\u6d4b\u5230\u8fd9\u4e9b\u95ee\u9898\u3002\u6d88\u878d\u5b9e\u9a8c\u8868\u660e\u9664\u901a\u7528MR\u5916\u7684\u6240\u6709\u7ec4\u4ef6\u90fd\u81f3\u5c11\u8d21\u732e\u4e86\u4e00\u4e2abug\u7c7b\u3002", "conclusion": "OBsmith\u662f\u671d\u7740\u81ea\u52a8\u5316\u6d4b\u8bd5\u548c\u6df7\u6dc6\u5668\u7b49\u8bed\u4e49\u4fdd\u6301\u5de5\u5177\u94fe\u8d28\u91cf\u4fdd\u8bc1\u7684\u91cd\u8981\u4e00\u6b65\uff0c\u7ed3\u679c\u8fd8\u5f15\u53d1\u4e86\u5173\u4e8e\u5982\u4f55\u5e73\u8861\u6df7\u6dc6\u9884\u8bbe\u548c\u6027\u80fd\u6210\u672c\u7684\u8ba8\u8bba\u3002"}}
{"id": "2510.11419", "categories": ["cs.LO"], "pdf": "https://arxiv.org/pdf/2510.11419", "abs": "https://arxiv.org/abs/2510.11419", "authors": ["Paul Brunet"], "title": "Representations", "comment": null, "summary": "The formal analysis of automated systems is an important and growing\nindustry. This activity routinely requires new verification frameworks to be\ndeveloped to tackle new programming features, or new considerations (bugs of\ninterest). Often, one particular property can prove frustrating to establish:\ncompleteness of the logic with respect to the semantics. In this paper, we try\nand make such developments easier, with a particular attention on completeness.\nTowards that aim, we propose a formal (meta-)model of software analysis systems\n(SAS), the eponymous Representations. This model requires few assumptions on\nthe SAS being modeled, and as such is able to capture a large class of such\nsystems. We then show how our approach can be fruitful, both to understand how\nexisting completeness proofs can be structured, and to leverage this structure\nto build new systems and prove their completeness.", "AI": {"tldr": "\u63d0\u51fa\u4e00\u4e2a\u540d\u4e3aRepresentations\u7684\u8f6f\u4ef6\u5206\u6790\u7cfb\u7edf\u5143\u6a21\u578b\uff0c\u65e8\u5728\u7b80\u5316\u9a8c\u8bc1\u6846\u67b6\u7684\u5f00\u53d1\uff0c\u7279\u522b\u5173\u6ce8\u903b\u8f91\u5b8c\u5907\u6027\u8bc1\u660e\u3002", "motivation": "\u81ea\u52a8\u5316\u7cfb\u7edf\u7684\u5f62\u5f0f\u5206\u6790\u9700\u8981\u4e0d\u65ad\u5f00\u53d1\u65b0\u7684\u9a8c\u8bc1\u6846\u67b6\u6765\u5904\u7406\u65b0\u7f16\u7a0b\u7279\u6027\u6216\u9519\u8bef\u7c7b\u578b\uff0c\u5176\u4e2d\u903b\u8f91\u5b8c\u5907\u6027\u8bc1\u660e\u5f80\u5f80\u7279\u522b\u56f0\u96be\u3002", "method": "\u6784\u5efa\u4e00\u4e2a\u901a\u7528\u7684\u8f6f\u4ef6\u5206\u6790\u7cfb\u7edf\uff08SAS\uff09\u5143\u6a21\u578b\uff0c\u8be5\u6a21\u578b\u5bf9\u5efa\u6a21\u7684SAS\u8981\u6c42\u8f83\u5c11\u5047\u8bbe\uff0c\u80fd\u591f\u6355\u83b7\u5e7f\u6cdb\u7684\u7cfb\u7edf\u7c7b\u522b\u3002", "result": "\u8be5\u6a21\u578b\u6709\u52a9\u4e8e\u7406\u89e3\u73b0\u6709\u5b8c\u5907\u6027\u8bc1\u660e\u7684\u7ed3\u6784\uff0c\u5e76\u80fd\u5229\u7528\u8fd9\u79cd\u7ed3\u6784\u6784\u5efa\u65b0\u7cfb\u7edf\u5e76\u8bc1\u660e\u5176\u5b8c\u5907\u6027\u3002", "conclusion": "\u63d0\u51fa\u7684Representations\u6a21\u578b\u4e3a\u8f6f\u4ef6\u5206\u6790\u7cfb\u7edf\u7684\u5f00\u53d1\u548c\u5b8c\u5907\u6027\u8bc1\u660e\u63d0\u4f9b\u4e86\u5b9e\u7528\u7684\u7406\u8bba\u57fa\u7840\u548c\u65b9\u6cd5\u6307\u5bfc\u3002"}}
{"id": "2510.10517", "categories": ["cs.PL", "cs.AI", "cs.SE"], "pdf": "https://arxiv.org/pdf/2510.10517", "abs": "https://arxiv.org/abs/2510.10517", "authors": ["Su-Hyeon Kim", "Joonghyuk Hahn", "Sooyoung Cha", "Yo-Sub Han"], "title": "ECO: Enhanced Code Optimization via Performance-Aware Prompting for Code-LLMs", "comment": null, "summary": "Code runtime optimization-the task of rewriting a given code to a faster\none-remains challenging, as it requires reasoning about performance trade-offs\ninvolving algorithmic and structural choices. Recent approaches employ\ncode-LLMs with slow-fast code pairs provided as optimization guidance, but such\npair-based methods obscure the causal factors of performance gains and often\nlead to superficial pattern imitation rather than genuine performance\nreasoning. We introduce ECO, a performance-aware prompting framework for code\noptimization. ECO first distills runtime optimization instructions (ROIs) from\nreference slow-fast code pairs; Each ROI describes root causes of inefficiency\nand the rationales that drive performance improvements. For a given input code,\nECO in parallel employs (i) a symbolic advisor to produce a bottleneck\ndiagnosis tailored to the code, and (ii) an ROI retriever to return related\nROIs. These two outputs are then composed into a performance-aware prompt,\nproviding actionable guidance for code-LLMs. ECO's prompts are model-agnostic,\nrequire no fine-tuning, and can be easily prepended to any code-LLM prompt. Our\nempirical studies highlight that ECO prompting significantly improves\ncode-LLMs' ability to generate efficient code, achieving speedups of up to\n7.81x while minimizing correctness loss.", "AI": {"tldr": "ECO\u662f\u4e00\u4e2a\u6027\u80fd\u611f\u77e5\u7684\u4ee3\u7801\u4f18\u5316\u63d0\u793a\u6846\u67b6\uff0c\u901a\u8fc7\u5206\u6790\u6027\u80fd\u74f6\u9888\u548c\u4f18\u5316\u539f\u7406\u6765\u6307\u5bfc\u4ee3\u7801LLM\u751f\u6210\u66f4\u9ad8\u6548\u7684\u4ee3\u7801\uff0c\u65e0\u9700\u5fae\u8c03\u5373\u53ef\u5b9e\u73b0\u9ad8\u8fbe7.81\u500d\u7684\u52a0\u901f\u3002", "motivation": "\u73b0\u6709\u57fa\u4e8e\u6162-\u5feb\u4ee3\u7801\u5bf9\u7684\u4f18\u5316\u65b9\u6cd5\u5f80\u5f80\u53ea\u662f\u8868\u9762\u6a21\u5f0f\u6a21\u4eff\uff0c\u65e0\u6cd5\u63ed\u793a\u6027\u80fd\u63d0\u5347\u7684\u6839\u672c\u539f\u56e0\uff0c\u9700\u8981\u66f4\u6df1\u5165\u7684\u6027\u80fd\u63a8\u7406\u65b9\u6cd5\u3002", "method": "ECO\u6846\u67b6\u4ece\u53c2\u8003\u4ee3\u7801\u5bf9\u4e2d\u63d0\u53d6\u8fd0\u884c\u65f6\u4f18\u5316\u6307\u4ee4(ROI)\uff0c\u540c\u65f6\u4f7f\u7528\u7b26\u53f7\u987e\u95ee\u8fdb\u884c\u74f6\u9888\u8bca\u65ad\u548cROI\u68c0\u7d22\u5668\u83b7\u53d6\u76f8\u5173\u4f18\u5316\u539f\u7406\uff0c\u5c06\u8fd9\u4e9b\u4fe1\u606f\u7ec4\u5408\u6210\u6027\u80fd\u611f\u77e5\u63d0\u793a\u6765\u6307\u5bfc\u4ee3\u7801LLM\u3002", "result": "ECO\u663e\u8457\u63d0\u5347\u4e86\u4ee3\u7801LLM\u751f\u6210\u9ad8\u6548\u4ee3\u7801\u7684\u80fd\u529b\uff0c\u5b9e\u73b0\u4e86\u9ad8\u8fbe7.81\u500d\u7684\u52a0\u901f\uff0c\u540c\u65f6\u6700\u5c0f\u5316\u4e86\u6b63\u786e\u6027\u635f\u5931\u3002", "conclusion": "ECO\u63d0\u4f9b\u4e86\u4e00\u4e2a\u6a21\u578b\u65e0\u5173\u3001\u65e0\u9700\u5fae\u8c03\u7684\u4ee3\u7801\u4f18\u5316\u63d0\u793a\u6846\u67b6\uff0c\u80fd\u591f\u6709\u6548\u6307\u5bfc\u4ee3\u7801LLM\u8fdb\u884c\u6027\u80fd\u63a8\u7406\u548c\u4f18\u5316\u3002"}}
{"id": "2510.10081", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.10081", "abs": "https://arxiv.org/abs/2510.10081", "authors": ["Youshuai Tan", "Zhanwei Zhang", "Zishuo Ding", "Lianyu Zheng", "Jinfu Chen", "Weiyi Shang"], "title": "A Mathematics-Guided Approach to Floating-Point Error Detection", "comment": null, "summary": "Floating-point program errors can lead to severe consequences, particularly\nin critical domains such as military applications. Only a small subset of\ninputs may induce substantial floating-point errors, prompting researchers to\ndevelop methods for identifying these error-inducing inputs. Although existing\napproaches have achieved some success, they still suffer from two major\nlimitations: (1) High computational cost: The evaluation of error magnitude for\ncandidate inputs relies on high-precision programs, which are prohibitively\ntime-consuming. (2) Limited long-range convergence capability: Current methods\nexhibit inefficiency in search, making the process akin to finding a needle in\na haystack.\n  To address these two limitations, we propose a novel method, named MGDE, to\ndetect error-inducing inputs based on mathematical guidance. By employing the\nNewton-Raphson method, which exhibits quadratic convergence properties, we\nachieve highly effective and efficient results. Since the goal of identifying\nerror-inducing inputs is to uncover the underlying bugs, we use the number of\nbugs detected in floating-point programs as the primary evaluation metric in\nour experiments. As FPCC represents the most effective state-of-the-art\napproach to date, we use it as the baseline for comparison. The dataset of FPCC\nconsists of 88 single-input floating-point programs. FPCC is able to detect 48\nbugs across 29 programs, whereas our method successfully identifies 89 bugs\nacross 44 programs. Moreover, FPCC takes 6.4096 times as long as our proposed\nmethod. We also deploy our method to multi-input programs, identifying a total\nof nine bugs with an average detection time of 0.6443 seconds per program. In\ncontrast, FPCC fails to detect any bugs while requiring an average computation\ntime of 100 seconds per program.", "AI": {"tldr": "\u63d0\u51fa\u4e86\u4e00\u79cd\u57fa\u4e8e\u6570\u5b66\u6307\u5bfc\u7684MGDE\u65b9\u6cd5\uff0c\u7528\u4e8e\u9ad8\u6548\u68c0\u6d4b\u6d6e\u70b9\u7a0b\u5e8f\u4e2d\u7684\u9519\u8bef\u8bf1\u5bfc\u8f93\u5165\uff0c\u76f8\u6bd4\u73b0\u6709FPCC\u65b9\u6cd5\u5728\u68c0\u6d4b\u6548\u679c\u548c\u6548\u7387\u4e0a\u90fd\u6709\u663e\u8457\u63d0\u5347\u3002", "motivation": "\u6d6e\u70b9\u7a0b\u5e8f\u9519\u8bef\u5728\u5173\u952e\u9886\u57df\u53ef\u80fd\u9020\u6210\u4e25\u91cd\u540e\u679c\uff0c\u73b0\u6709\u65b9\u6cd5\u5b58\u5728\u8ba1\u7b97\u6210\u672c\u9ad8\u548c\u957f\u8ddd\u79bb\u6536\u655b\u80fd\u529b\u6709\u9650\u7684\u95ee\u9898\u3002", "method": "\u91c7\u7528\u5177\u6709\u4e8c\u6b21\u6536\u655b\u7279\u6027\u7684\u725b\u987f-\u62c9\u5f17\u68ee\u65b9\u6cd5\uff0c\u901a\u8fc7\u6570\u5b66\u6307\u5bfc\u6765\u8bc6\u522b\u9519\u8bef\u8bf1\u5bfc\u8f93\u5165\u3002", "result": "\u572888\u4e2a\u5355\u8f93\u5165\u6d6e\u70b9\u7a0b\u5e8f\u4e2d\uff0cMGDE\u68c0\u6d4b\u523044\u4e2a\u7a0b\u5e8f\u4e2d\u768489\u4e2a\u9519\u8bef\uff0c\u800cFPCC\u4ec5\u68c0\u6d4b\u523029\u4e2a\u7a0b\u5e8f\u4e2d\u768448\u4e2a\u9519\u8bef\uff1bMGDE\u901f\u5ea6\u6bd4FPCC\u5feb6.4\u500d\u3002\u5728\u591a\u8f93\u5165\u7a0b\u5e8f\u4e2d\uff0cMGDE\u68c0\u6d4b\u52309\u4e2a\u9519\u8bef\uff0c\u5e73\u5747\u8017\u65f60.6443\u79d2\uff0c\u800cFPCC\u672a\u80fd\u68c0\u6d4b\u5230\u4efb\u4f55\u9519\u8bef\u4e14\u8017\u65f6\u66f4\u957f\u3002", "conclusion": "MGDE\u65b9\u6cd5\u5728\u6d6e\u70b9\u7a0b\u5e8f\u9519\u8bef\u68c0\u6d4b\u65b9\u9762\u6bd4\u73b0\u6709\u6700\u5148\u8fdb\u65b9\u6cd5\u66f4\u6709\u6548\u548c\u9ad8\u6548\uff0c\u7279\u522b\u662f\u5728\u591a\u8f93\u5165\u7a0b\u5e8f\u4e2d\u8868\u73b0\u7a81\u51fa\u3002"}}
{"id": "2510.11617", "categories": ["cs.LO", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.11617", "abs": "https://arxiv.org/abs/2510.11617", "authors": ["Fran\u00e7ois Schwarzentruber"], "title": "Lecture Notes on Verifying Graph Neural Networks", "comment": null, "summary": "In these lecture notes, we first recall the connection between graph neural\nnetworks, Weisfeiler-Lehman tests and logics such as first-order logic and\ngraded modal logic. We then present a modal logic in which counting modalities\nappear in linear inequalities in order to solve verification tasks on graph\nneural networks. We describe an algorithm for the satisfiability problem of\nthat logic. It is inspired from the tableau method of vanilla modal logic,\nextended with reasoning in quantifier-free fragment Boolean algebra with\nPresburger arithmetic.", "AI": {"tldr": "\u672c\u6587\u63a2\u8ba8\u4e86\u56fe\u795e\u7ecf\u7f51\u7edc\u4e0eWeisfeiler-Lehman\u6d4b\u8bd5\u3001\u4e00\u9636\u903b\u8f91\u548c\u5206\u7ea7\u6a21\u6001\u903b\u8f91\u4e4b\u95f4\u7684\u8054\u7cfb\uff0c\u5e76\u63d0\u51fa\u4e86\u4e00\u79cd\u5305\u542b\u7ebf\u6027\u4e0d\u7b49\u5f0f\u4e2d\u8ba1\u6570\u6a21\u6001\u7684\u6a21\u6001\u903b\u8f91\u6765\u89e3\u51b3\u56fe\u795e\u7ecf\u7f51\u7edc\u7684\u9a8c\u8bc1\u4efb\u52a1\u3002", "motivation": "\u5efa\u7acb\u56fe\u795e\u7ecf\u7f51\u7edc\u4e0e\u5f62\u5f0f\u903b\u8f91\u4e4b\u95f4\u7684\u7406\u8bba\u8054\u7cfb\uff0c\u5e76\u5f00\u53d1\u80fd\u591f\u9a8c\u8bc1\u56fe\u795e\u7ecf\u7f51\u7edc\u5c5e\u6027\u7684\u903b\u8f91\u6846\u67b6\u3002", "method": "\u63d0\u51fa\u4e86\u4e00\u79cd\u5305\u542b\u8ba1\u6570\u6a21\u6001\u7684\u6a21\u6001\u903b\u8f91\uff0c\u5176\u8ba1\u6570\u6a21\u6001\u51fa\u73b0\u5728\u7ebf\u6027\u4e0d\u7b49\u5f0f\u4e2d\u3002\u8bbe\u8ba1\u4e86\u4e00\u79cd\u57fa\u4e8e\u7ecf\u5178\u6a21\u6001\u903b\u8f91\u8868\u65b9\u6cd5\u5e76\u6269\u5c55\u4e86\u5e26Presburger\u7b97\u672f\u7684\u5e03\u5c14\u4ee3\u6570\u65e0\u91cf\u5316\u7247\u6bb5\u63a8\u7406\u7684\u6ee1\u8db3\u6027\u7b97\u6cd5\u3002", "result": "\u5f00\u53d1\u4e86\u4e00\u79cd\u65b0\u7684\u6a21\u6001\u903b\u8f91\u5f62\u5f0f\u5316\u65b9\u6cd5\uff0c\u80fd\u591f\u8868\u8fbe\u56fe\u795e\u7ecf\u7f51\u7edc\u7684\u9a8c\u8bc1\u5c5e\u6027\uff0c\u5e76\u63d0\u4f9b\u4e86\u76f8\u5e94\u7684\u6ee1\u8db3\u6027\u5224\u5b9a\u7b97\u6cd5\u3002", "conclusion": "\u901a\u8fc7\u5c06\u56fe\u795e\u7ecf\u7f51\u7edc\u4e0e\u5f62\u5f0f\u903b\u8f91\u8fde\u63a5\uff0c\u63d0\u51fa\u4e86\u4e00\u79cd\u6709\u6548\u7684\u9a8c\u8bc1\u6846\u67b6\uff0c\u4e3a\u56fe\u795e\u7ecf\u7f51\u7edc\u7684\u5f62\u5f0f\u5316\u9a8c\u8bc1\u63d0\u4f9b\u4e86\u7406\u8bba\u57fa\u7840\u548c\u5b9e\u7528\u5de5\u5177\u3002"}}
{"id": "2510.10531", "categories": ["cs.PL", "cs.DC", "cs.LO", "cs.SY", "eess.SY"], "pdf": "https://arxiv.org/pdf/2510.10531", "abs": "https://arxiv.org/abs/2510.10531", "authors": ["Guillaume Ambal", "George Hodgkins", "Mark Madler", "Gregory Chockler", "Brijesh Dongol", "Joseph Izraelevitz", "Azalea Raad", "Viktor Vafeiadis"], "title": "A Verified High-Performance Composable Object Library for Remote Direct Memory Access (Extended Version)", "comment": null, "summary": "Remote Direct Memory Access (RDMA) is a memory technology that allows remote\ndevices to directly write to and read from each other's memory, bypassing\ncomponents such as the CPU and operating system. This enables low-latency\nhigh-throughput networking, as required for many modern data centres, HPC\napplications and AI/ML workloads. However, baseline RDMA comprises a highly\npermissive weak memory model that is difficult to use in practice and has only\nrecently been formalised. In this paper, we introduce the Library of Composable\nObjects (LOCO), a formally verified library for building multi-node objects on\nRDMA, filling the gap between shared memory and distributed system programming.\nLOCO objects are well-encapsulated and take advantage of the strong locality\nand the weak consistency characteristics of RDMA. They have performance\ncomparable to custom RDMA systems (e.g. distributed maps), but with a far\nsimpler programming model amenable to formal proofs of correctness. To support\nverification, we develop a novel modular declarative verification framework,\ncalled Mowgli, that is flexible enough to model multinode objects and is\nindependent of a memory consistency model. We instantiate Mowgli with the RDMA\nmemory model, and use it to verify correctness of LOCO libraries.", "AI": {"tldr": "LOCO\u662f\u4e00\u4e2a\u7ecf\u8fc7\u5f62\u5f0f\u5316\u9a8c\u8bc1\u7684RDMA\u591a\u8282\u70b9\u5bf9\u8c61\u5e93\uff0c\u586b\u8865\u4e86\u5171\u4eab\u5185\u5b58\u548c\u5206\u5e03\u5f0f\u7cfb\u7edf\u7f16\u7a0b\u4e4b\u95f4\u7684\u7a7a\u767d\u3002\u5b83\u63d0\u4f9b\u4e86\u6027\u80fd\u63a5\u8fd1\u5b9a\u5236RDMA\u7cfb\u7edf\u4f46\u7f16\u7a0b\u6a21\u578b\u66f4\u7b80\u5355\u7684\u5bf9\u8c61\uff0c\u5e76\u5f00\u53d1\u4e86Mowgli\u9a8c\u8bc1\u6846\u67b6\u6765\u786e\u4fdd\u6b63\u786e\u6027\u3002", "motivation": "RDMA\u867d\u7136\u80fd\u5b9e\u73b0\u4f4e\u5ef6\u8fdf\u9ad8\u541e\u5410\u91cf\u7684\u7f51\u7edc\u901a\u4fe1\uff0c\u4f46\u5176\u5f31\u5185\u5b58\u6a21\u578b\u96be\u4ee5\u5728\u5b9e\u9645\u4e2d\u4f7f\u7528\uff0c\u4e14\u6700\u8fd1\u624d\u88ab\u5f62\u5f0f\u5316\u3002\u9700\u8981\u4e00\u79cd\u65e2\u80fd\u5229\u7528RDMA\u6027\u80fd\u4f18\u52bf\u53c8\u6613\u4e8e\u7f16\u7a0b\u548c\u9a8c\u8bc1\u7684\u89e3\u51b3\u65b9\u6848\u3002", "method": "\u5f00\u53d1\u4e86LOCO\u5e93\uff0c\u6784\u5efa\u5c01\u88c5\u826f\u597d\u7684\u591a\u8282\u70b9\u5bf9\u8c61\uff0c\u5229\u7528RDMA\u7684\u5f3a\u5c40\u90e8\u6027\u548c\u5f31\u4e00\u81f4\u6027\u7279\u6027\u3002\u540c\u65f6\u521b\u5efa\u4e86Mowgli\u6a21\u5757\u5316\u58f0\u660e\u5f0f\u9a8c\u8bc1\u6846\u67b6\uff0c\u8be5\u6846\u67b6\u7075\u6d3b\u4e14\u72ec\u7acb\u4e8e\u5185\u5b58\u4e00\u81f4\u6027\u6a21\u578b\u3002", "result": "LOCO\u5bf9\u8c61\u6027\u80fd\u4e0e\u5b9a\u5236RDMA\u7cfb\u7edf\u76f8\u5f53\uff08\u5982\u5206\u5e03\u5f0f\u6620\u5c04\uff09\uff0c\u4f46\u7f16\u7a0b\u6a21\u578b\u66f4\u7b80\u5355\uff0c\u9002\u5408\u5f62\u5f0f\u5316\u6b63\u786e\u6027\u8bc1\u660e\u3002Mowgli\u6846\u67b6\u6210\u529f\u5b9e\u4f8b\u5316RDMA\u5185\u5b58\u6a21\u578b\u5e76\u9a8c\u8bc1\u4e86LOCO\u5e93\u7684\u6b63\u786e\u6027\u3002", "conclusion": "LOCO\u63d0\u4f9b\u4e86\u4e00\u4e2a\u5b9e\u7528\u7684RDMA\u7f16\u7a0b\u62bd\u8c61\uff0c\u901a\u8fc7\u5f62\u5f0f\u5316\u9a8c\u8bc1\u786e\u4fdd\u4e86\u7cfb\u7edf\u6b63\u786e\u6027\uff0c\u586b\u8865\u4e86\u5171\u4eab\u5185\u5b58\u548c\u5206\u5e03\u5f0f\u7cfb\u7edf\u7f16\u7a0b\u4e4b\u95f4\u7684\u91cd\u8981\u7a7a\u767d\u3002"}}
{"id": "2510.10119", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.10119", "abs": "https://arxiv.org/abs/2510.10119", "authors": ["Liutong Han", "Zhiyuan Tan", "Hongbin Zhang", "Pengcheng Wang", "Chu Kang", "Mingjie Xing", "Yanjun Wu"], "title": "IntrinTrans: LLM-based Intrinsic Code Translator for RISC-V Vector", "comment": "9 pages", "summary": "The use of intrinsic functions to exploit hardware-specific capabilities is\nan important approach for optimizing library performance. Many mainstream\nlibraries implement a large number of vectorized algorithms on Arm or x86 SIMD\nintrinsic functions. With the rapid expansion of the RISC-V hardware-software\necosystem, there is a growing demand for support of the RISC-V Vector (RVV)\nextension. Translating existing vectorized intrinsic code onto RVV intrinsics\nis a practical and effective approach. However, current cross-architecture\ntranslation largely relies on manual rewriting, which is time-consuming and\nerror-prone. Furthermore, while some rule-based methods can reduce the need for\nmanual intervention, their translation success rate is limited by incomplete\nrule coverage and syntactic constraints, and the performance suffers from\ninadequate utilization of RVV-specific features. We present IntrinTrans, a\nLLM-based multi-agent approach that utilizes compile-and-test feedback to\ntranslate intrinsic code across architectures automatically, and further\noptimizes the generated RVV intrinsics using register-usage information derived\nfrom liveness analysis. To evaluate the effectiveness of our approach, we\ncollected 34 vectorized algorithm cases from open-source libraries. Each case\nincludes an Arm Neon intrinsics implementation and a RVV intrinsics\nimplementation contributed by the open-source community, together with\ncorrectness and performance tests. Our experiments show that advanced LLMs\nproduce semantically correct RISC-V Vector intrinsics in most cases within a\nlimited number of iterations, and in some cases achieve up to 5.93x the\nperformance of the native implementation from the open-source community.", "AI": {"tldr": "IntrinTrans\u662f\u4e00\u4e2a\u57fa\u4e8eLLM\u7684\u591a\u667a\u80fd\u4f53\u65b9\u6cd5\uff0c\u5229\u7528\u7f16\u8bd1\u6d4b\u8bd5\u53cd\u9988\u81ea\u52a8\u8de8\u67b6\u6784\u7ffb\u8bd1SIMD\u5185\u8054\u51fd\u6570\u4ee3\u7801\uff0c\u5e76\u901a\u8fc7\u6d3b\u8dc3\u5ea6\u5206\u6790\u4f18\u5316RISC-V Vector\u5185\u8054\u51fd\u6570\u6027\u80fd\u3002", "motivation": "\u968f\u7740RISC-V\u751f\u6001\u7cfb\u7edf\u7684\u5feb\u901f\u53d1\u5c55\uff0c\u5bf9RISC-V Vector\u6269\u5c55\u652f\u6301\u7684\u9700\u6c42\u65e5\u76ca\u589e\u957f\u3002\u73b0\u6709\u8de8\u67b6\u6784\u7ffb\u8bd1\u4e3b\u8981\u4f9d\u8d56\u624b\u52a8\u91cd\u5199\uff0c\u8017\u65f6\u4e14\u6613\u9519\uff0c\u800c\u57fa\u4e8e\u89c4\u5219\u7684\u65b9\u6cd5\u7ffb\u8bd1\u6210\u529f\u7387\u548c\u6027\u80fd\u6709\u9650\u3002", "method": "\u4f7f\u7528\u57fa\u4e8eLLM\u7684\u591a\u667a\u80fd\u4f53\u65b9\u6cd5\uff0c\u7ed3\u5408\u7f16\u8bd1\u6d4b\u8bd5\u53cd\u9988\u8fdb\u884c\u81ea\u52a8\u7ffb\u8bd1\uff0c\u5e76\u901a\u8fc7\u6d3b\u8dc3\u5ea6\u5206\u6790\u83b7\u53d6\u5bc4\u5b58\u5668\u4f7f\u7528\u4fe1\u606f\u6765\u4f18\u5316\u751f\u6210\u7684RVV\u5185\u8054\u51fd\u6570\u3002", "result": "\u5b9e\u9a8c\u8868\u660e\uff0c\u9ad8\u7ea7LLM\u5728\u6709\u9650\u8fed\u4ee3\u6b21\u6570\u5185\u80fd\u5728\u5927\u591a\u6570\u60c5\u51b5\u4e0b\u751f\u6210\u8bed\u4e49\u6b63\u786e\u7684RISC-V Vector\u5185\u8054\u51fd\u6570\uff0c\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\u6027\u80fd\u8fbe\u5230\u5f00\u6e90\u793e\u533a\u539f\u751f\u5b9e\u73b0\u76845.93\u500d\u3002", "conclusion": "IntrinTrans\u63d0\u4f9b\u4e86\u4e00\u79cd\u81ea\u52a8\u5316\u7684\u8de8\u67b6\u6784\u5185\u8054\u51fd\u6570\u7ffb\u8bd1\u65b9\u6cd5\uff0c\u80fd\u591f\u751f\u6210\u9ad8\u6027\u80fd\u7684RISC-V Vector\u4ee3\u7801\uff0c\u663e\u8457\u4f18\u4e8e\u624b\u52a8\u7ffb\u8bd1\u548c\u57fa\u4e8e\u89c4\u5219\u7684\u65b9\u6cd5\u3002"}}
{"id": "2510.10148", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.10148", "abs": "https://arxiv.org/abs/2510.10148", "authors": ["Mengyao Zhao", "Kaixuan Li", "Lyuye Zhang", "Wenjing Dang", "Chenggong Ding", "Sen Chen", "Zheli Liu"], "title": "A Systematic Study on Generating Web Vulnerability Proof-of-Concepts Using Large Language Models", "comment": null, "summary": "Recent advances in Large Language Models (LLMs) have brought remarkable\nprogress in code understanding and reasoning, creating new opportunities and\nraising new concerns for software security. Among many downstream tasks,\ngenerating Proof-of-Concept (PoC) exploits plays a central role in\nvulnerability reproduction, comprehension, and mitigation. While previous\nresearch has focused primarily on zero-day exploitation, the growing\navailability of rich public information accompanying disclosed CVEs leads to a\nnatural question: can LLMs effectively use this information to automatically\ngenerate valid PoCs? In this paper, we present the first empirical study of\nLLM-based PoC generation for web application vulnerabilities, focusing on the\npractical feasibility of leveraging publicly disclosed information. We evaluate\nGPT-4o and DeepSeek-R1 on 100 real-world and reproducible CVEs across three\nstages of vulnerability disclosure: (1) newly disclosed vulnerabilities with\nonly descriptions, (2) 1-day vulnerabilities with patches, and (3) N-day\nvulnerabilities with full contextual code. Our results show that LLMs can\nautomatically generate working PoCs in 8%-34% of cases using only public data,\nwith DeepSeek-R1 consistently outperforming GPT-4o. Further analysis shows that\nsupplementing code context improves success rates by 17%-20%, with\nfunction-level providing 9%-13% improvement than file-level ones. Further\nintegrating adaptive reasoning strategies to prompt refinement significantly\nimproves success rates to 68%-72%. Our findings suggest that LLMs could reshape\nvulnerability exploitation dynamics. To date, 23 newly generated PoCs have been\naccepted by NVD and Exploit DB.", "AI": {"tldr": "LLMs\u80fd\u591f\u5229\u7528\u516c\u5f00CVE\u4fe1\u606f\u81ea\u52a8\u751f\u6210\u6709\u6548\u7684PoC\u6f0f\u6d1e\u5229\u7528\u4ee3\u7801\uff0c\u57288%-34%\u7684\u60c5\u51b5\u4e0b\u6210\u529f\uff0c\u901a\u8fc7\u4ee3\u7801\u4e0a\u4e0b\u6587\u548c\u81ea\u9002\u5e94\u63a8\u7406\u7b56\u7565\u53ef\u5c06\u6210\u529f\u7387\u63d0\u5347\u81f368%-72%\u3002", "motivation": "\u968f\u7740LLMs\u5728\u4ee3\u7801\u7406\u89e3\u65b9\u9762\u7684\u8fdb\u6b65\uff0c\u7814\u7a76\u5176\u662f\u5426\u80fd\u591f\u5229\u7528\u516c\u5f00\u7684CVE\u4fe1\u606f\u81ea\u52a8\u751f\u6210\u6709\u6548\u7684PoC\u6f0f\u6d1e\u5229\u7528\u4ee3\u7801\uff0c\u8fd9\u5bf9\u6f0f\u6d1e\u590d\u73b0\u3001\u7406\u89e3\u548c\u7f13\u89e3\u5177\u6709\u91cd\u8981\u610f\u4e49\u3002", "method": "\u8bc4\u4f30GPT-4o\u548cDeepSeek-R1\u5728100\u4e2a\u771f\u5b9e\u53ef\u590d\u73b0CVE\u4e0a\u7684\u8868\u73b0\uff0c\u6db5\u76d6\u4e09\u4e2a\u6f0f\u6d1e\u62ab\u9732\u9636\u6bb5\uff1a\u4ec5\u6709\u63cf\u8ff0\u7684\u65b0\u62ab\u9732\u6f0f\u6d1e\u3001\u6709\u8865\u4e01\u76841-day\u6f0f\u6d1e\u3001\u6709\u5b8c\u6574\u4ee3\u7801\u4e0a\u4e0b\u6587\u7684N-day\u6f0f\u6d1e\u3002", "result": "LLMs\u4ec5\u4f7f\u7528\u516c\u5f00\u6570\u636e\u5c31\u80fd\u57288%-34%\u7684\u60c5\u51b5\u4e0b\u751f\u6210\u6709\u6548\u7684PoC\uff0cDeepSeek-R1\u8868\u73b0\u4f18\u4e8eGPT-4o\u3002\u6dfb\u52a0\u4ee3\u7801\u4e0a\u4e0b\u6587\u53ef\u5c06\u6210\u529f\u7387\u63d0\u534717%-20%\uff0c\u51fd\u6570\u7ea7\u4e0a\u4e0b\u6587\u6bd4\u6587\u4ef6\u7ea7\u63d0\u53479%-13%\u3002\u7ed3\u5408\u81ea\u9002\u5e94\u63a8\u7406\u7b56\u7565\u540e\u6210\u529f\u7387\u53ef\u8fbe68%-72%\u3002", "conclusion": "LLMs\u80fd\u591f\u663e\u8457\u6539\u53d8\u6f0f\u6d1e\u5229\u7528\u7684\u52a8\u6001\uff0c\u5df2\u670923\u4e2a\u65b0\u751f\u6210\u7684PoC\u88abNVD\u548cExploit DB\u63a5\u53d7\uff0c\u8868\u660eLLM\u751f\u6210\u7684PoC\u5177\u6709\u5b9e\u9645\u4ef7\u503c\u3002"}}
{"id": "2510.11420", "categories": ["cs.PL", "quant-ph"], "pdf": "https://arxiv.org/pdf/2510.11420", "abs": "https://arxiv.org/abs/2510.11420", "authors": ["Mark Koch", "Agust\u00edn Borgna", "Seyon Sivarajah", "Alan Lawrence", "Alec Edgington", "Douglas Wilson", "Craig Roy", "Luca Mondada", "Lukas Heidemann", "Ross Duncan"], "title": "HUGR: A Quantum-Classical Intermediate Representation", "comment": "8 pages, extended abstract submitted to PlanQC25", "summary": "We introduce the Hierarchical Unified Graph Representation (HUGR): a novel\ngraph based intermediate representation for mixed quantum-classical programs.\nHUGR's design features high expressivity and extensibility to capture the\ncapabilities of near-term and forthcoming quantum computing devices, as well as\nnew and evolving abstractions from novel quantum programming paradigms. The\ngraph based structure is machine-friendly and supports powerful pattern\nmatching based compilation techniques. Inspired by MLIR, HUGR's extensibility\nfurther allows compilation tooling to reason about programs at multiple levels\nof abstraction, lowering smoothly between them. Safety guarantees in the\nstructure including strict, static typing and linear quantum types allow rapid\ndevelopment of compilation tooling without fear of program invalidation. A full\nspecification of HUGR and reference implementation are open-source and\navailable online.", "AI": {"tldr": "HUGR\u662f\u4e00\u79cd\u65b0\u9896\u7684\u57fa\u4e8e\u56fe\u7684\u4e2d\u95f4\u8868\u793a\uff0c\u7528\u4e8e\u6df7\u5408\u91cf\u5b50-\u7ecf\u5178\u7a0b\u5e8f\uff0c\u5177\u6709\u9ad8\u8868\u8fbe\u6027\u548c\u53ef\u6269\u5c55\u6027\uff0c\u652f\u6301\u6a21\u5f0f\u5339\u914d\u7f16\u8bd1\u6280\u672f\uff0c\u5e76\u63d0\u4f9b\u5b89\u5168\u4fdd\u8bc1\u3002", "motivation": "\u4e3a\u4e86\u6355\u6349\u8fd1\u671f\u548c\u672a\u6765\u91cf\u5b50\u8ba1\u7b97\u8bbe\u5907\u7684\u80fd\u529b\uff0c\u4ee5\u53ca\u65b0\u5174\u91cf\u5b50\u7f16\u7a0b\u8303\u5f0f\u4e2d\u7684\u62bd\u8c61\u6982\u5ff5\uff0c\u9700\u8981\u4e00\u4e2a\u8868\u8fbe\u529b\u5f3a\u4e14\u53ef\u6269\u5c55\u7684\u4e2d\u95f4\u8868\u793a\u3002", "method": "\u8bbe\u8ba1\u57fa\u4e8e\u56fe\u7684\u5c42\u6b21\u5316\u7edf\u4e00\u56fe\u8868\u793a(HUGR)\uff0c\u53d7MLIR\u542f\u53d1\uff0c\u652f\u6301\u591a\u62bd\u8c61\u5c42\u6b21\u63a8\u7406\u548c\u5e73\u6ed1\u964d\u7ea7\uff0c\u5305\u542b\u4e25\u683c\u9759\u6001\u7c7b\u578b\u548c\u7ebf\u6027\u91cf\u5b50\u7c7b\u578b\u7b49\u5b89\u5168\u4fdd\u8bc1\u3002", "result": "\u5f00\u53d1\u4e86\u5b8c\u6574\u7684HUGR\u89c4\u8303\u548c\u5f00\u6e90\u53c2\u8003\u5b9e\u73b0\uff0c\u652f\u6301\u673a\u5668\u53cb\u597d\u7684\u56fe\u7ed3\u6784\u548c\u5f3a\u5927\u7684\u7f16\u8bd1\u6280\u672f\u3002", "conclusion": "HUGR\u4e3a\u91cf\u5b50\u7a0b\u5e8f\u7f16\u8bd1\u63d0\u4f9b\u4e86\u5b89\u5168\u3001\u53ef\u6269\u5c55\u7684\u4e2d\u95f4\u8868\u793a\u6846\u67b6\uff0c\u6709\u52a9\u4e8e\u5feb\u901f\u5f00\u53d1\u7f16\u8bd1\u5de5\u5177\u94fe\u3002"}}
{"id": "2510.10179", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.10179", "abs": "https://arxiv.org/abs/2510.10179", "authors": ["Linghan Huang", "Peizhou Zhao", "Huaming Chen"], "title": "LLMs are All You Need? Improving Fuzz Testing for MOJO with Large Language Models", "comment": null, "summary": "The rapid development of large language models (LLMs) has revolutionized\nsoftware testing, particularly fuzz testing, by automating the generation of\ndiverse and effective test inputs. This advancement holds great promise for\nimproving software reliability. Meanwhile, the introduction of MOJO, a\nhigh-performance AI programming language blending Python's usability with the\nefficiency of C and C++, presents new opportunities to enhance AI model\nscalability and programmability. However, as a new language, MOJO lacks\ncomprehensive testing frameworks and a sufficient corpus for LLM-based testing,\nwhich exacerbates model hallucination. In this case, LLMs will generate\nsyntactically valid but semantically incorrect code, significantly reducing the\neffectiveness of fuzz testing. To address this challenge, we propose\nMOJOFuzzer, the first adaptive LLM-based fuzzing framework designed for\nzero-shot learning environments of emerging programming languages. MOJOFuzzer\nintegrates a mutil-phase framework that systematically eliminates low-quality\ngenerated inputs before execution, significantly improving test case validity.\nFurthermore, MOJOFuzzer dynamically adapts LLM prompts based on runtime\nfeedback for test case mutation, enabling an iterative learning process that\ncontinuously enhances fuzzing efficiency and bug detection performance. Our\nexperimental results demonstrate that MOJOFuzzer significantly enhances test\nvalidity, API coverage, and bug detection performance, outperforming\ntraditional fuzz testing and state-of-the-art LLM-based fuzzing approaches.\nUsing MOJOFuzzer, we have conducted a first large-scale fuzz testing evaluation\nof MOJO, uncorvering 13 previous unknown bugs. This study not only advances the\nfield of LLM-driven software testing but also establishes a foundational\nmethodology for leveraging LLMs in the testing of emerging programming\nlanguages.", "AI": {"tldr": "MOJOFuzzer\u662f\u9996\u4e2a\u9488\u5bf9\u65b0\u5174\u7f16\u7a0b\u8bed\u8a00\u7684\u96f6\u6837\u672c\u5b66\u4e60\u73af\u5883\u4e0b\u81ea\u9002\u5e94LLM\u6a21\u7cca\u6d4b\u8bd5\u6846\u67b6\uff0c\u901a\u8fc7\u591a\u9636\u6bb5\u8fc7\u6ee4\u548c\u52a8\u6001\u63d0\u793a\u8c03\u6574\uff0c\u663e\u8457\u63d0\u9ad8\u4e86\u6d4b\u8bd5\u7528\u4f8b\u7684\u6709\u6548\u6027\u548c\u9519\u8bef\u68c0\u6d4b\u6027\u80fd\u3002", "motivation": "MOJO\u4f5c\u4e3a\u65b0\u5174\u9ad8\u6027\u80fdAI\u7f16\u7a0b\u8bed\u8a00\u7f3a\u4e4f\u5b8c\u5584\u7684\u6d4b\u8bd5\u6846\u67b6\u548c\u8bed\u6599\u5e93\uff0c\u5bfc\u81f4LLM\u5728\u6a21\u7cca\u6d4b\u8bd5\u4e2d\u4ea7\u751f\u8bed\u6cd5\u6b63\u786e\u4f46\u8bed\u4e49\u9519\u8bef\u7684\u4ee3\u7801\uff0c\u964d\u4f4e\u4e86\u6d4b\u8bd5\u6548\u679c\u3002", "method": "\u63d0\u51fa\u591a\u9636\u6bb5\u6846\u67b6\u7cfb\u7edf\u6d88\u9664\u4f4e\u8d28\u91cf\u751f\u6210\u8f93\u5165\uff0c\u5e76\u57fa\u4e8e\u8fd0\u884c\u65f6\u53cd\u9988\u52a8\u6001\u8c03\u6574LLM\u63d0\u793a\u8fdb\u884c\u6d4b\u8bd5\u7528\u4f8b\u53d8\u5f02\uff0c\u5b9e\u73b0\u8fed\u4ee3\u5b66\u4e60\u8fc7\u7a0b\u3002", "result": "MOJOFuzzer\u663e\u8457\u63d0\u5347\u4e86\u6d4b\u8bd5\u6709\u6548\u6027\u3001API\u8986\u76d6\u7387\u548c\u9519\u8bef\u68c0\u6d4b\u6027\u80fd\uff0c\u5728MOJO\u8bed\u8a00\u4e2d\u53d1\u73b0\u4e8613\u4e2a\u5148\u524d\u672a\u77e5\u7684\u9519\u8bef\u3002", "conclusion": "\u8be5\u7814\u7a76\u4e0d\u4ec5\u63a8\u8fdb\u4e86LLM\u9a71\u52a8\u7684\u8f6f\u4ef6\u6d4b\u8bd5\u9886\u57df\uff0c\u8fd8\u4e3a\u5229\u7528LLM\u6d4b\u8bd5\u65b0\u5174\u7f16\u7a0b\u8bed\u8a00\u5efa\u7acb\u4e86\u57fa\u7840\u65b9\u6cd5\u8bba\u3002"}}
{"id": "2510.11573", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2510.11573", "abs": "https://arxiv.org/abs/2510.11573", "authors": ["Santiago Arranz-Olmos", "Gilles Barthe", "Lionel Blatter", "Xingyu Xie", "Zhiyuan Zhang"], "title": "(Dis)Proving Spectre Security with Speculation-Passing Style", "comment": null, "summary": "Constant-time (CT) verification tools are commonly used for detecting\npotential side-channel vulnerabilities in cryptographic libraries. Recently, a\nnew class of tools, called speculative constant-time (SCT) tools, has also been\nused for detecting potential Spectre vulnerabilities. In many cases, these SCT\ntools have emerged as liftings of CT tools. However, these liftings are seldom\ndefined precisely and are almost never analyzed formally. The goal of this\npaper is to address this gap, by developing formal foundations for these\nliftings, and to demonstrate that these foundations can yield practical\nbenefits.\n  Concretely, we introduce a program transformation, coined Speculation-Passing\nStyle (SPS), for reducing SCT verification to CT verification. Essentially, the\ntransformation instruments the program with a new input that corresponds to\nattacker-controlled predictions and modifies the program to follow them. This\napproach is sound and complete, in the sense that a program is SCT if and only\nif its SPS transform is CT. Thus, we can leverage existing CT verification\ntools to prove SCT; we illustrate this by combining SPS with three standard\nmethodologies for CT verification, namely reducing it to non-interference,\nassertion safety and dynamic taint analysis. We realize these combinations with\nthree existing tools, EasyCrypt, BINSEC, and ctgrind, and we evaluate them on\nKocher's benchmarks for Spectre-v1. Our results focus on Spectre-v1 in the\nstandard CT leakage model; however, we also discuss applications of our method\nto other variants of Spectre and other leakage models.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u79f0\u4e3a\u63a8\u6d4b\u4f20\u9012\u98ce\u683c(SPS)\u7684\u7a0b\u5e8f\u8f6c\u6362\u65b9\u6cd5\uff0c\u5c06\u63a8\u6d4b\u5e38\u6570\u65f6\u95f4(SCT)\u9a8c\u8bc1\u7b80\u5316\u4e3a\u5e38\u6570\u65f6\u95f4(CT)\u9a8c\u8bc1\uff0c\u4e3aSCT\u5de5\u5177\u63d0\u4f9b\u4e86\u5f62\u5f0f\u5316\u57fa\u7840\u3002", "motivation": "\u73b0\u6709\u7684\u63a8\u6d4b\u5e38\u6570\u65f6\u95f4(SCT)\u9a8c\u8bc1\u5de5\u5177\u901a\u5e38\u662f\u5e38\u6570\u65f6\u95f4(CT)\u9a8c\u8bc1\u5de5\u5177\u7684\u7b80\u5355\u6269\u5c55\uff0c\u4f46\u8fd9\u4e9b\u6269\u5c55\u7f3a\u4e4f\u7cbe\u786e\u7684\u5b9a\u4e49\u548c\u5f62\u5f0f\u5316\u5206\u6790\u3002\u672c\u6587\u65e8\u5728\u586b\u8865\u8fd9\u4e00\u7a7a\u767d\uff0c\u4e3a\u8fd9\u4e9b\u6269\u5c55\u5efa\u7acb\u5f62\u5f0f\u5316\u57fa\u7840\u3002", "method": "\u5f15\u5165\u63a8\u6d4b\u4f20\u9012\u98ce\u683c(SPS)\u7a0b\u5e8f\u8f6c\u6362\uff0c\u901a\u8fc7\u6dfb\u52a0\u653b\u51fb\u8005\u63a7\u5236\u7684\u9884\u6d4b\u8f93\u5165\u6765\u4fee\u6539\u7a0b\u5e8f\uff0c\u4f7f\u5176\u9075\u5faa\u8fd9\u4e9b\u9884\u6d4b\u3002\u8be5\u65b9\u6cd5\u5c06SCT\u9a8c\u8bc1\u95ee\u9898\u8f6c\u5316\u4e3aCT\u9a8c\u8bc1\u95ee\u9898\u3002", "result": "\u8bc1\u660e\u4e86\u7a0b\u5e8f\u662fSCT\u5f53\u4e14\u4ec5\u5f53\u5176SPS\u8f6c\u6362\u662fCT\uff0c\u4ece\u800c\u53ef\u4ee5\u5229\u7528\u73b0\u6709CT\u9a8c\u8bc1\u5de5\u5177\u8bc1\u660eSCT\u3002\u5728Spectre-v1\u57fa\u51c6\u6d4b\u8bd5\u4e2d\u4e0eEasyCrypt\u3001BINSEC\u548cctgrind\u7b49\u5de5\u5177\u7ed3\u5408\u9a8c\u8bc1\u4e86\u6709\u6548\u6027\u3002", "conclusion": "SPS\u8f6c\u6362\u63d0\u4f9b\u4e86\u4e00\u79cd\u5c06SCT\u9a8c\u8bc1\u7b80\u5316\u4e3aCT\u9a8c\u8bc1\u7684\u901a\u7528\u65b9\u6cd5\uff0c\u4e3a\u68c0\u6d4bSpectre\u6f0f\u6d1e\u63d0\u4f9b\u4e86\u5f62\u5f0f\u5316\u57fa\u7840\u548c\u5b9e\u7528\u5de5\u5177\u3002"}}
{"id": "2510.10290", "categories": ["cs.SE", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.10290", "abs": "https://arxiv.org/abs/2510.10290", "authors": ["Sayan Mandal", "Hua Jiang"], "title": "Grounded AI for Code Review: Resource-Efficient Large-Model Serving in Enterprise Pipelines", "comment": "Submitted to MLSys 2026", "summary": "Automated code review adoption lags in compliance-heavy settings, where\nstatic analyzers produce high-volume, low-rationale outputs, and naive LLM use\nrisks hallucination and incurring cost overhead. We present a production system\nfor grounded, PR-native review that pairs static-analysis findings with\nAST-guided context extraction and a single-GPU, on-demand serving stack\n(quantized open-weight model, multi-tier caching) to deliver concise\nexplanations and remediation guidance. Evaluated on safety-oriented C/C++\nstandards, the approach achieves sub-minute median first-feedback (offline p50\nbuild+LLM 59.8s) while maintaining competitive violation reduction and lower\nviolation rates versus larger proprietary models. The architecture is\ndecoupled: teams can adopt the grounding/prompting layer or the serving layer\nindependently. A small internal survey (n=8) provides directional signals of\nreduced triage effort and moderate perceived grounding, with participants\nreporting fewer human review iterations. We outline operational lessons and\nlimitations, emphasizing reproducibility, auditability, and pathways to broader\nstandards and assisted patching.", "AI": {"tldr": "\u63d0\u51fa\u4e86\u4e00\u4e2a\u57fa\u4e8e\u9759\u6001\u5206\u6790\u548cAST\u6307\u5bfc\u7684\u81ea\u52a8\u5316\u4ee3\u7801\u5ba1\u67e5\u7cfb\u7edf\uff0c\u4f7f\u7528\u91cf\u5316\u5f00\u6e90\u6a21\u578b\u5728\u5355GPU\u4e0a\u8fd0\u884c\uff0c\u4e3a\u5408\u89c4\u6027\u5f3a\u7684C/C++\u4ee3\u7801\u63d0\u4f9b\u5feb\u901f\u3001\u51c6\u786e\u7684\u5ba1\u67e5\u53cd\u9988\u3002", "motivation": "\u5728\u5408\u89c4\u6027\u8981\u6c42\u9ad8\u7684\u73af\u5883\u4e2d\uff0c\u4f20\u7edf\u9759\u6001\u5206\u6790\u5de5\u5177\u4ea7\u751f\u5927\u91cf\u4f4e\u89e3\u91ca\u6027\u8f93\u51fa\uff0c\u800c\u76f4\u63a5\u4f7f\u7528LLM\u5b58\u5728\u5e7b\u89c9\u98ce\u9669\u548c\u6210\u672c\u95ee\u9898\uff0c\u9700\u8981\u66f4\u53ef\u9760\u7684\u81ea\u52a8\u5316\u4ee3\u7801\u5ba1\u67e5\u65b9\u6848\u3002", "method": "\u7ed3\u5408\u9759\u6001\u5206\u6790\u7ed3\u679c\u4e0eAST\u6307\u5bfc\u7684\u4e0a\u4e0b\u6587\u63d0\u53d6\uff0c\u91c7\u7528\u91cf\u5316\u5f00\u6e90\u6a21\u578b\u548c\u5206\u5c42\u7f13\u5b58\u6280\u672f\uff0c\u6784\u5efa\u89e3\u8026\u7684\u7cfb\u7edf\u67b6\u6784\uff0c\u652f\u6301\u72ec\u7acb\u91c7\u7528\u4e0d\u540c\u7ec4\u4ef6\u3002", "result": "\u5728\u5b89\u5168\u5bfc\u5411\u7684C/C++\u6807\u51c6\u8bc4\u4f30\u4e2d\uff0c\u5b9e\u73b0\u4e2d\u4f4d\u657059.8\u79d2\u7684\u9996\u6b21\u53cd\u9988\u65f6\u95f4\uff0c\u8fdd\u89c4\u51cf\u5c11\u6548\u679c\u4e0e\u5927\u578b\u4e13\u6709\u6a21\u578b\u76f8\u5f53\u4f46\u8fdd\u89c4\u7387\u66f4\u4f4e\u3002\u5185\u90e8\u8c03\u67e5\u663e\u793a\u51cf\u5c11\u4e86\u4eba\u5de5\u5ba1\u67e5\u8fed\u4ee3\u6b21\u6570\u3002", "conclusion": "\u8be5\u7cfb\u7edf\u5728\u4fdd\u6301\u7ade\u4e89\u529b\u7684\u540c\u65f6\u964d\u4f4e\u4e86\u6210\u672c\uff0c\u5f3a\u8c03\u53ef\u91cd\u73b0\u6027\u3001\u53ef\u5ba1\u8ba1\u6027\u548c\u5411\u66f4\u5e7f\u6cdb\u6807\u51c6\u53ca\u8f85\u52a9\u4fee\u8865\u7684\u6269\u5c55\u8def\u5f84\u3002"}}
{"id": "2510.10320", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.10320", "abs": "https://arxiv.org/abs/2510.10320", "authors": ["Lorena Poenaru-Olaru", "Wouter van 't Hof", "Adrian Stando", "Arkadiusz P. Trawinski", "Eileen Kapel", "Jan S. Rellermeyer", "Luis Cruz", "Arie van Deursen"], "title": "Prepared for the Unknown: Adapting AIOps Capacity Forecasting Models to Data Changes", "comment": null, "summary": "Capacity management is critical for software organizations to allocate\nresources effectively and meet operational demands. An important step in\ncapacity management is predicting future resource needs often relies on\ndata-driven analytics and machine learning (ML) forecasting models, which\nrequire frequent retraining to stay relevant as data evolves. Continuously\nretraining the forecasting models can be expensive and difficult to scale,\nposing a challenge for engineering teams tasked with balancing accuracy and\nefficiency. Retraining only when the data changes appears to be a more\ncomputationally efficient alternative, but its impact on accuracy requires\nfurther investigation. In this work, we investigate the effects of retraining\ncapacity forecasting models for time series based on detected changes in the\ndata compared to periodic retraining. Our results show that drift-based\nretraining achieves comparable forecasting accuracy to periodic retraining in\nmost cases, making it a cost-effective strategy. However, in cases where data\nis changing rapidly, periodic retraining is still preferred to maximize the\nforecasting accuracy. These findings offer actionable insights for software\nteams to enhance forecasting systems, reducing retraining overhead while\nmaintaining robust performance.", "AI": {"tldr": "\u6bd4\u8f83\u57fa\u4e8e\u6570\u636e\u6f02\u79fb\u68c0\u6d4b\u7684\u91cd\u65b0\u8bad\u7ec3\u4e0e\u5b9a\u671f\u91cd\u65b0\u8bad\u7ec3\u5728\u5bb9\u91cf\u9884\u6d4b\u6a21\u578b\u4e2d\u7684\u6548\u679c\uff0c\u53d1\u73b0\u6f02\u79fb\u68c0\u6d4b\u65b9\u6cd5\u5728\u5927\u591a\u6570\u60c5\u51b5\u4e0b\u80fd\u8fbe\u5230\u76f8\u8fd1\u7684\u51c6\u786e\u6027\u4e14\u66f4\u7ecf\u6d4e\u9ad8\u6548\u3002", "motivation": "\u5bb9\u91cf\u7ba1\u7406\u4e2d\u9891\u7e41\u91cd\u65b0\u8bad\u7ec3\u9884\u6d4b\u6a21\u578b\u6210\u672c\u9ad8\u6602\u4e14\u96be\u4ee5\u6269\u5c55\uff0c\u9700\u8981\u627e\u5230\u5e73\u8861\u51c6\u786e\u6027\u548c\u6548\u7387\u7684\u89e3\u51b3\u65b9\u6848\u3002", "method": "\u7814\u7a76\u57fa\u4e8e\u65f6\u95f4\u5e8f\u5217\u6570\u636e\u53d8\u5316\u68c0\u6d4b\u7684\u91cd\u65b0\u8bad\u7ec3\u7b56\u7565\uff0c\u4e0e\u5b9a\u671f\u91cd\u65b0\u8bad\u7ec3\u8fdb\u884c\u5bf9\u6bd4\u5206\u6790\u3002", "result": "\u6f02\u79fb\u68c0\u6d4b\u91cd\u65b0\u8bad\u7ec3\u5728\u5927\u591a\u6570\u60c5\u51b5\u4e0b\u80fd\u8fbe\u5230\u4e0e\u5b9a\u671f\u91cd\u65b0\u8bad\u7ec3\u76f8\u5f53\u7684\u9884\u6d4b\u51c6\u786e\u6027\uff0c\u4f46\u5728\u6570\u636e\u5feb\u901f\u53d8\u5316\u65f6\u5b9a\u671f\u91cd\u65b0\u8bad\u7ec3\u4ecd\u66f4\u4f18\u3002", "conclusion": "\u57fa\u4e8e\u6570\u636e\u6f02\u79fb\u7684\u91cd\u65b0\u8bad\u7ec3\u662f\u6210\u672c\u6548\u76ca\u66f4\u9ad8\u7684\u7b56\u7565\uff0c\u80fd\u591f\u51cf\u5c11\u91cd\u65b0\u8bad\u7ec3\u5f00\u9500\u540c\u65f6\u4fdd\u6301\u7a33\u5065\u6027\u80fd\u3002"}}
{"id": "2510.10321", "categories": ["cs.SE", "cs.AI", "cs.CR"], "pdf": "https://arxiv.org/pdf/2510.10321", "abs": "https://arxiv.org/abs/2510.10321", "authors": ["Jugal Gajjar", "Kaustik Ranaware", "Kamalasankari Subramaniakuppusamy"], "title": "Bridging Semantics & Structure for Software Vulnerability Detection using Hybrid Network Models", "comment": "13 pages, 3 figures, 5 tables, 14 equations, accepted at the 14th\n  International Conference on Complex Networks and Their Applications (COMPLEX\n  NETWORKS 2025) and the conference proceedings will be published by Springer\n  in the Studies in Computational Intelligence series", "summary": "Software vulnerabilities remain a persistent risk, yet static and dynamic\nanalyses often overlook structural dependencies that shape insecure behaviors.\nViewing programs as heterogeneous graphs, we capture control- and data-flow\nrelations as complex interaction networks. Our hybrid framework combines these\ngraph representations with light-weight (<4B) local LLMs, uniting topological\nfeatures with semantic reasoning while avoiding the cost and privacy concerns\nof large cloud models. Evaluated on Java vulnerability detection (binary\nclassification), our method achieves 93.57% accuracy-an 8.36% gain over Graph\nAttention Network-based embeddings and 17.81% over pretrained LLM baselines\nsuch as Qwen2.5 Coder 3B. Beyond accuracy, the approach extracts salient\nsubgraphs and generates natural language explanations, improving\ninterpretability for developers. These results pave the way for scalable,\nexplainable, and locally deployable tools that can shift vulnerability analysis\nfrom purely syntactic checks to deeper structural and semantic insights,\nfacilitating broader adoption in real-world secure software development.", "AI": {"tldr": "\u63d0\u51fa\u4e86\u4e00\u79cd\u7ed3\u5408\u5f02\u6784\u56fe\u8868\u793a\u548c\u8f7b\u91cf\u7ea7\u672c\u5730LLM\u7684\u6df7\u5408\u6846\u67b6\uff0c\u7528\u4e8e\u8f6f\u4ef6\u6f0f\u6d1e\u68c0\u6d4b\uff0c\u5728Java\u6f0f\u6d1e\u68c0\u6d4b\u4e2d\u8fbe\u523093.57%\u7684\u51c6\u786e\u7387\uff0c\u6bd4\u73b0\u6709\u65b9\u6cd5\u63d0\u53478.36-17.81%\u3002", "motivation": "\u73b0\u6709\u9759\u6001\u548c\u52a8\u6001\u5206\u6790\u65b9\u6cd5\u5f80\u5f80\u5ffd\u7565\u5f71\u54cd\u4e0d\u5b89\u5168\u884c\u4e3a\u7684\u7ed3\u6784\u4f9d\u8d56\u5173\u7cfb\uff0c\u4e14\u5927\u578b\u4e91\u6a21\u578b\u5b58\u5728\u6210\u672c\u548c\u9690\u79c1\u95ee\u9898\u3002", "method": "\u5c06\u7a0b\u5e8f\u5efa\u6a21\u4e3a\u5f02\u6784\u56fe\uff0c\u6355\u83b7\u63a7\u5236\u548c\u6570\u636e\u6d41\u5173\u7cfb\uff0c\u7ed3\u5408\u8f7b\u91cf\u7ea7(<4B)\u672c\u5730LLM\uff0c\u7edf\u4e00\u62d3\u6251\u7279\u5f81\u4e0e\u8bed\u4e49\u63a8\u7406\u3002", "result": "\u5728Java\u6f0f\u6d1e\u68c0\u6d4b(\u4e8c\u5143\u5206\u7c7b)\u4e2d\u8fbe\u523093.57%\u51c6\u786e\u7387\uff0c\u6bd4\u57fa\u4e8e\u56fe\u6ce8\u610f\u529b\u7f51\u7edc\u7684\u5d4c\u5165\u65b9\u6cd5\u63d0\u53478.36%\uff0c\u6bd4\u9884\u8bad\u7ec3LLM\u57fa\u7ebf(Qwen2.5 Coder 3B)\u63d0\u534717.81%\u3002", "conclusion": "\u8be5\u65b9\u6cd5\u4e3a\u53ef\u6269\u5c55\u3001\u53ef\u89e3\u91ca\u4e14\u672c\u5730\u53ef\u90e8\u7f72\u7684\u6f0f\u6d1e\u5206\u6790\u5de5\u5177\u94fa\u5e73\u4e86\u9053\u8def\uff0c\u4f7f\u5206\u6790\u4ece\u7eaf\u8bed\u6cd5\u68c0\u67e5\u8f6c\u5411\u66f4\u6df1\u5c42\u6b21\u7684\u7ed3\u6784\u548c\u8bed\u4e49\u6d1e\u5bdf\u3002"}}
{"id": "2510.10460", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.10460", "abs": "https://arxiv.org/abs/2510.10460", "authors": ["Zongyi Lyu", "Songqiang Chen", "Zhenlan Ji", "Liwen Wang", "Shuai Wang", "Daoyuan Wu", "Wenxuan Wang", "Shing-Chi Cheung"], "title": "Testing and Enhancing Multi-Agent Systems for Robust Code Generation", "comment": "19pages, 5 figures", "summary": "Multi-agent systems (MASs) have emerged as a promising paradigm for automated\ncode generation, demonstrating impressive performance on established benchmarks\nby decomposing complex coding tasks across specialized agents with different\nroles. Despite their prosperous development and adoption, their robustness\nremains pressingly under-explored, raising critical concerns for real-world\ndeployment. This paper presents the first comprehensive study examining the\nrobustness of MASs for code generation through a fuzzing-based testing\napproach. By designing a fuzzing pipeline incorporating semantic-preserving\nmutation operators and a novel fitness function, we assess mainstream MASs\nacross multiple datasets and LLMs. Our findings reveal substantial robustness\nflaws of various popular MASs: they fail to solve 7.9%-83.3% of problems they\ninitially resolved successfully after applying the semantic-preserving\nmutations. Through comprehensive failure analysis, we identify a common yet\nlargely overlooked cause of the robustness issue: miscommunications between\nplanning and coding agents, where plans lack sufficient detail and coding\nagents misinterpret intricate logic, aligning with the challenges inherent in a\nmulti-stage information transformation process. Accordingly, we also propose a\nrepairing method that encompasses multi-prompt generation and introduces a new\nmonitor agent to address this issue. Evaluation shows that our repairing method\neffectively enhances the robustness of MASs by solving 40.0%-88.9% of\nidentified failures. Our work uncovers critical robustness flaws in MASs and\nprovides effective mitigation strategies, contributing essential insights for\ndeveloping more reliable MASs for code generation.", "AI": {"tldr": "\u672c\u6587\u9996\u6b21\u5bf9\u591a\u667a\u80fd\u4f53\u7cfb\u7edf\u5728\u4ee3\u7801\u751f\u6210\u4e2d\u7684\u9c81\u68d2\u6027\u8fdb\u884c\u4e86\u5168\u9762\u7814\u7a76\uff0c\u901a\u8fc7\u57fa\u4e8e\u6a21\u7cca\u6d4b\u8bd5\u7684\u65b9\u6cd5\u63ed\u793a\u4e86\u4e3b\u6d41MAS\u5b58\u5728\u7684\u4e25\u91cd\u9c81\u68d2\u6027\u7f3a\u9677\uff0c\u5e76\u63d0\u51fa\u4e86\u6709\u6548\u7684\u4fee\u590d\u65b9\u6cd5\u3002", "motivation": "\u5c3d\u7ba1\u591a\u667a\u80fd\u4f53\u7cfb\u7edf\u5728\u4ee3\u7801\u751f\u6210\u65b9\u9762\u8868\u73b0\u51fa\u8272\uff0c\u4f46\u5176\u9c81\u68d2\u6027\u5c1a\u672a\u5f97\u5230\u5145\u5206\u63a2\u7d22\uff0c\u8fd9\u5bf9\u5b9e\u9645\u90e8\u7f72\u6784\u6210\u4e86\u5173\u952e\u6311\u6218\u3002", "method": "\u8bbe\u8ba1\u4e86\u5305\u542b\u8bed\u4e49\u4fdd\u7559\u53d8\u5f02\u7b97\u5b50\u548c\u65b0\u578b\u9002\u5e94\u5ea6\u51fd\u6570\u7684\u6a21\u7cca\u6d4b\u8bd5\u7ba1\u9053\uff0c\u8bc4\u4f30\u4e3b\u6d41MAS\u5728\u4e0d\u540c\u6570\u636e\u96c6\u548cLLM\u4e0a\u7684\u8868\u73b0\uff0c\u5e76\u63d0\u51fa\u4e86\u5305\u542b\u591a\u63d0\u793a\u751f\u6210\u548c\u76d1\u63a7\u667a\u80fd\u4f53\u7684\u4fee\u590d\u65b9\u6cd5\u3002", "result": "\u7814\u7a76\u53d1\u73b0\u5404\u79cd\u6d41\u884cMAS\u5728\u5e94\u7528\u8bed\u4e49\u4fdd\u7559\u53d8\u5f02\u540e\uff0c\u65e0\u6cd5\u89e3\u51b37.9%-83.3%\u539f\u672c\u6210\u529f\u89e3\u51b3\u7684\u95ee\u9898\u3002\u4fee\u590d\u65b9\u6cd5\u80fd\u6709\u6548\u89e3\u51b340.0%-88.9%\u7684\u5df2\u8bc6\u522b\u6545\u969c\u3002", "conclusion": "\u8be5\u5de5\u4f5c\u63ed\u793a\u4e86MAS\u5728\u4ee3\u7801\u751f\u6210\u4e2d\u7684\u5173\u952e\u9c81\u68d2\u6027\u7f3a\u9677\uff0c\u63d0\u4f9b\u4e86\u6709\u6548\u7684\u7f13\u89e3\u7b56\u7565\uff0c\u4e3a\u5f00\u53d1\u66f4\u53ef\u9760\u7684\u4ee3\u7801\u751f\u6210MAS\u63d0\u4f9b\u4e86\u91cd\u8981\u89c1\u89e3\u3002"}}
{"id": "2510.10551", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.10551", "abs": "https://arxiv.org/abs/2510.10551", "authors": ["Baris Ardic", "Quentin Le Dilavrec", "Andy Zaidman"], "title": "How Students Use Generative AI for Software Testing: An Observational Study", "comment": "39 pages, 6 figures, journal submission", "summary": "The integration of generative AI tools like ChatGPT into software engineering\nworkflows opens up new opportunities to boost productivity in tasks such as\nunit test engineering. However, these AI-assisted workflows can also\nsignificantly alter the developer's role, raising concerns about control,\noutput quality, and learning, particularly for novice developers. This study\ninvestigates how novice software developers with foundational knowledge in\nsoftware testing interact with generative AI for engineering unit tests. Our\ngoal is to examine the strategies they use, how heavily they rely on generative\nAI, and the benefits and challenges they perceive when using generative\nAI-assisted approaches for test engineering. We conducted an observational\nstudy involving 12 undergraduate students who worked with generative AI for\nunit testing tasks. We identified four interaction strategies, defined by\nwhether the test idea or the test implementation originated from generative AI\nor the participant. Additionally, we singled out prompting styles that focused\non one-shot or iterative test generation, which often aligned with the broader\ninteraction strategy. Students reported benefits including time-saving, reduced\ncognitive load, and support for test ideation, but also noted drawbacks such as\ndiminished trust, test quality concerns, and lack of ownership. While strategy\nand prompting styles influenced workflow dynamics, they did not significantly\naffect test effectiveness or test code quality as measured by mutation score or\ntest smells.", "AI": {"tldr": "\u7814\u7a76\u65b0\u624b\u5f00\u53d1\u8005\u4f7f\u7528\u751f\u6210\u5f0fAI\u8fdb\u884c\u5355\u5143\u6d4b\u8bd5\u7684\u4ea4\u4e92\u7b56\u7565\u3001\u4f9d\u8d56\u7a0b\u5ea6\u548c\u611f\u77e5\u6536\u76ca\u6311\u6218\uff0c\u53d1\u73b0\u56db\u79cd\u4ea4\u4e92\u7b56\u7565\u548c\u4e24\u79cd\u63d0\u793a\u98ce\u683c\uff0cAI\u8f85\u52a9\u80fd\u8282\u7701\u65f6\u95f4\u4f46\u5b58\u5728\u4fe1\u4efb\u548c\u8d28\u91cf\u95ee\u9898\u3002", "motivation": "\u751f\u6210\u5f0fAI\u5de5\u5177\u5728\u8f6f\u4ef6\u5de5\u7a0b\u4e2d\u7684\u96c6\u6210\u5e26\u6765\u4e86\u751f\u4ea7\u529b\u63d0\u5347\u673a\u4f1a\uff0c\u4f46\u4e5f\u6539\u53d8\u4e86\u5f00\u53d1\u8005\u89d2\u8272\uff0c\u7279\u522b\u662f\u5bf9\u65b0\u624b\u5f00\u53d1\u8005\u53ef\u80fd\u5e26\u6765\u63a7\u5236\u3001\u8f93\u51fa\u8d28\u91cf\u548c\u5b66\u4e60\u65b9\u9762\u7684\u62c5\u5fe7\u3002", "method": "\u5bf912\u540d\u5177\u6709\u8f6f\u4ef6\u6d4b\u8bd5\u57fa\u7840\u77e5\u8bc6\u7684\u672c\u79d1\u751f\u8fdb\u884c\u89c2\u5bdf\u7814\u7a76\uff0c\u5206\u6790\u4ed6\u4eec\u4f7f\u7528\u751f\u6210\u5f0fAI\u8fdb\u884c\u5355\u5143\u6d4b\u8bd5\u4efb\u52a1\u7684\u4ea4\u4e92\u7b56\u7565\u548c\u63d0\u793a\u98ce\u683c\u3002", "result": "\u8bc6\u522b\u51fa\u56db\u79cd\u4ea4\u4e92\u7b56\u7565\uff08\u6d4b\u8bd5\u60f3\u6cd5\u548c\u5b9e\u65bd\u6765\u6e90\u4e0d\u540c\u7ec4\u5408\uff09\u548c\u4e24\u79cd\u63d0\u793a\u98ce\u683c\uff08\u4e00\u6b21\u6027\u6216\u8fed\u4ee3\u6d4b\u8bd5\u751f\u6210\uff09\u3002\u5b66\u751f\u62a5\u544a\u4e86\u8282\u7701\u65f6\u95f4\u3001\u51cf\u8f7b\u8ba4\u77e5\u8d1f\u62c5\u7b49\u597d\u5904\uff0c\u4f46\u4e5f\u5b58\u5728\u4fe1\u4efb\u5ea6\u964d\u4f4e\u3001\u6d4b\u8bd5\u8d28\u91cf\u95ee\u9898\u7b49\u7f3a\u70b9\u3002\u7b56\u7565\u548c\u63d0\u793a\u98ce\u683c\u5f71\u54cd\u5de5\u4f5c\u6d41\u7a0b\uff0c\u4f46\u4e0d\u663e\u8457\u5f71\u54cd\u6d4b\u8bd5\u6709\u6548\u6027\u6216\u4ee3\u7801\u8d28\u91cf\u3002", "conclusion": "\u751f\u6210\u5f0fAI\u8f85\u52a9\u5355\u5143\u6d4b\u8bd5\u5bf9\u65b0\u624b\u5f00\u53d1\u8005\u65e2\u6709\u76ca\u5904\u4e5f\u6709\u6311\u6218\uff0c\u9700\u8981\u5e73\u8861\u81ea\u52a8\u5316\u8f85\u52a9\u4e0e\u5b66\u4e60\u673a\u4f1a\uff0c\u7b56\u7565\u9009\u62e9\u5f71\u54cd\u5de5\u4f5c\u6d41\u7a0b\u4f46\u4e0d\u51b3\u5b9a\u6700\u7ec8\u6d4b\u8bd5\u8d28\u91cf\u3002"}}
{"id": "2510.10819", "categories": ["cs.SE", "cs.AI", "68N01, 68T05, 68T07, 68T50", "D.2.2; D.2.5; D.2.6; D.2.8; I.2.6; I.2.7; I.2.11"], "pdf": "https://arxiv.org/pdf/2510.10819", "abs": "https://arxiv.org/abs/2510.10819", "authors": ["Vivek Acharya"], "title": "Generative AI and the Transformation of Software Development Practices", "comment": "16 pages; 1 figure; preprint; v", "summary": "Generative AI is reshaping how software is designed, written, and maintained.\nAdvances in large language models (LLMs) are enabling new development styles -\nfrom chat-oriented programming and 'vibe coding' to agentic programming - that\ncan accelerate productivity and broaden access. This paper examines how\nAI-assisted techniques are changing software engineering practice, and the\nrelated issues of trust, accountability, and shifting skills. We survey\niterative chat-based development, multi-agent systems, dynamic prompt\norchestration, and integration via the Model Context Protocol (MCP). Using case\nstudies and industry data, we outline both the opportunities (faster cycles,\ndemocratized coding) and the challenges (model reliability and cost) of\napplying generative AI to coding. We describe new roles, skills, and best\npractices for using AI in a responsible and effective way.", "AI": {"tldr": "\u672c\u6587\u63a2\u8ba8\u751f\u6210\u5f0fAI\u5982\u4f55\u6539\u53d8\u8f6f\u4ef6\u5de5\u7a0b\u5b9e\u8df5\uff0c\u5305\u62ec\u804a\u5929\u7f16\u7a0b\u3001\u591a\u667a\u80fd\u4f53\u7cfb\u7edf\u7b49\u65b0\u6280\u672f\uff0c\u5206\u6790\u5176\u5e26\u6765\u7684\u673a\u9047\u4e0e\u6311\u6218\u3002", "motivation": "\u7814\u7a76\u751f\u6210\u5f0fAI\u548c\u5927\u578b\u8bed\u8a00\u6a21\u578b\u5982\u4f55\u91cd\u5851\u8f6f\u4ef6\u5f00\u53d1\u65b9\u5f0f\uff0c\u63a2\u7d22AI\u8f85\u52a9\u6280\u672f\u5bf9\u8f6f\u4ef6\u5de5\u7a0b\u5b9e\u8df5\u7684\u5f71\u54cd\u53ca\u76f8\u5173\u4fe1\u4efb\u3001\u8d23\u4efb\u548c\u6280\u80fd\u8f6c\u53d8\u95ee\u9898\u3002", "method": "\u901a\u8fc7\u6848\u4f8b\u7814\u7a76\u548c\u884c\u4e1a\u6570\u636e\uff0c\u8c03\u67e5\u8fed\u4ee3\u5f0f\u804a\u5929\u5f00\u53d1\u3001\u591a\u667a\u80fd\u4f53\u7cfb\u7edf\u3001\u52a8\u6001\u63d0\u793a\u7f16\u6392\u548c\u6a21\u578b\u4e0a\u4e0b\u6587\u534f\u8bae\u96c6\u6210\u7b49\u6280\u672f\u3002", "result": "\u751f\u6210\u5f0fAI\u5728\u7f16\u7801\u4e2d\u5e26\u6765\u4e86\u66f4\u5feb\u7684\u5f00\u53d1\u5468\u671f\u548c\u7f16\u7a0b\u6c11\u4e3b\u5316\u7b49\u673a\u4f1a\uff0c\u4f46\u4e5f\u9762\u4e34\u6a21\u578b\u53ef\u9760\u6027\u548c\u6210\u672c\u7b49\u6311\u6218\u3002", "conclusion": "\u9700\u8981\u4e3aAI\u5728\u8f6f\u4ef6\u5f00\u53d1\u4e2d\u7684\u8d1f\u8d23\u4efb\u548c\u6709\u6548\u4f7f\u7528\u5b9a\u4e49\u65b0\u7684\u89d2\u8272\u3001\u6280\u80fd\u548c\u6700\u4f73\u5b9e\u8df5\u3002"}}
{"id": "2510.10824", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.10824", "abs": "https://arxiv.org/abs/2510.10824", "authors": ["Mohanakrishnan Hariharan", "Satish Arvapalli", "Seshu Barma", "Evangeline Sheela"], "title": "Agentic RAG for Software Testing with Hybrid Vector-Graph and Multi-Agent Orchestration", "comment": null, "summary": "We present an approach to software testing automation using Agentic\nRetrieval-Augmented Generation (RAG) systems for Quality Engineering (QE)\nartifact creation. We combine autonomous AI agents with hybrid vector-graph\nknowledge systems to automate test plan, case, and QE metric generation. Our\napproach addresses traditional software testing limitations by leveraging LLMs\nsuch as Gemini and Mistral, multi-agent orchestration, and enhanced\ncontextualization. The system achieves remarkable accuracy improvements from\n65% to 94.8% while ensuring comprehensive document traceability throughout the\nquality engineering lifecycle. Experimental validation of enterprise Corporate\nSystems Engineering and SAP migration projects demonstrates an 85% reduction in\ntesting timeline, an 85% improvement in test suite efficiency, and projected\n35% cost savings, resulting in a 2-month acceleration of go-live.", "AI": {"tldr": "\u4f7f\u7528\u57fa\u4e8eAgentic RAG\u7cfb\u7edf\u7684\u8f6f\u4ef6\u6d4b\u8bd5\u81ea\u52a8\u5316\u65b9\u6cd5\uff0c\u901a\u8fc7\u81ea\u4e3bAI\u4ee3\u7406\u548c\u6df7\u5408\u5411\u91cf-\u56fe\u77e5\u8bc6\u7cfb\u7edf\u6765\u81ea\u52a8\u751f\u6210\u6d4b\u8bd5\u8ba1\u5212\u3001\u6d4b\u8bd5\u7528\u4f8b\u548c\u8d28\u91cf\u5de5\u7a0b\u6307\u6807\uff0c\u663e\u8457\u63d0\u5347\u6d4b\u8bd5\u51c6\u786e\u6027\u548c\u6548\u7387\u3002", "motivation": "\u89e3\u51b3\u4f20\u7edf\u8f6f\u4ef6\u6d4b\u8bd5\u7684\u5c40\u9650\u6027\uff0c\u901a\u8fc7\u7ed3\u5408\u5927\u578b\u8bed\u8a00\u6a21\u578b\u548c\u591a\u4ee3\u7406\u534f\u8c03\u6765\u6539\u8fdb\u8d28\u91cf\u5de5\u7a0b\u5de5\u4ef6\u7684\u521b\u5efa\u8fc7\u7a0b\u3002", "method": "\u7ed3\u5408\u81ea\u4e3bAI\u4ee3\u7406\u4e0e\u6df7\u5408\u5411\u91cf-\u56fe\u77e5\u8bc6\u7cfb\u7edf\uff0c\u5229\u7528Gemini\u548cMistral\u7b49LLM\u3001\u591a\u4ee3\u7406\u7f16\u6392\u548c\u589e\u5f3a\u7684\u60c5\u5883\u5316\u6280\u672f\u6765\u81ea\u52a8\u5316\u6d4b\u8bd5\u8ba1\u5212\u3001\u7528\u4f8b\u548cQE\u6307\u6807\u751f\u6210\u3002", "result": "\u51c6\u786e\u7387\u4ece65%\u63d0\u5347\u81f394.8%\uff0c\u4f01\u4e1a\u7ea7\u9a8c\u8bc1\u663e\u793a\u6d4b\u8bd5\u65f6\u95f4\u7ebf\u51cf\u5c1185%\uff0c\u6d4b\u8bd5\u5957\u4ef6\u6548\u7387\u63d0\u534785%\uff0c\u9884\u8ba1\u6210\u672c\u8282\u770135%\uff0c\u4e0a\u7ebf\u65f6\u95f4\u63d0\u524d2\u4e2a\u6708\u3002", "conclusion": "\u8be5\u65b9\u6cd5\u5728\u8f6f\u4ef6\u6d4b\u8bd5\u81ea\u52a8\u5316\u65b9\u9762\u53d6\u5f97\u4e86\u663e\u8457\u6210\u6548\uff0c\u901a\u8fc7AI\u9a71\u52a8\u7684\u8d28\u91cf\u5de5\u7a0b\u5b9e\u73b0\u4e86\u9ad8\u6548\u3001\u51c6\u786e\u4e14\u5177\u6709\u5168\u9762\u6587\u6863\u53ef\u8ffd\u6eaf\u6027\u7684\u6d4b\u8bd5\u6d41\u7a0b\u3002"}}
{"id": "2510.10840", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.10840", "abs": "https://arxiv.org/abs/2510.10840", "authors": ["Seshu Barma", "Mohanakrishnan Hariharan", "Satish Arvapalli"], "title": "Software Defect Prediction using Autoencoder Transformer Model", "comment": null, "summary": "An AI-ML-powered quality engineering approach uses AI-ML to enhance software\nquality assessments by predicting defects. Existing ML models struggle with\nnoisy data types, imbalances, pattern recognition, feature extraction, and\ngeneralization. To address these challenges, we develop a new model, Adaptive\nDifferential Evolution (ADE) based Quantum Variational Autoencoder-Transformer\n(QVAET) Model (ADE-QVAET). ADE combines with QVAET to obtain high-dimensional\nlatent features and maintain sequential dependencies, resulting in enhanced\ndefect prediction accuracy. ADE optimization enhances model convergence and\npredictive performance. ADE-QVAET integrates AI-ML techniques such as tuning\nhyperparameters for scalable and accurate software defect prediction,\nrepresenting an AI-ML-driven technology for quality engineering. During\ntraining with a 90% training percentage, ADE-QVAET achieves high accuracy,\nprecision, recall, and F1-score of 98.08%, 92.45%, 94.67%, and 98.12%,\nrespectively, when compared to the Differential Evolution (DE) ML model.", "AI": {"tldr": "\u63d0\u51faADE-QVAET\u6a21\u578b\uff0c\u7ed3\u5408\u81ea\u9002\u5e94\u5dee\u5206\u8fdb\u5316\u548c\u91cf\u5b50\u53d8\u5206\u81ea\u7f16\u7801\u5668-Transformer\uff0c\u7528\u4e8e\u8f6f\u4ef6\u7f3a\u9677\u9884\u6d4b\uff0c\u572890%\u8bad\u7ec3\u6570\u636e\u4e0b\u8fbe\u523098.08%\u51c6\u786e\u7387\u3002", "motivation": "\u73b0\u6709ML\u6a21\u578b\u5728\u5904\u7406\u566a\u58f0\u6570\u636e\u3001\u7c7b\u522b\u4e0d\u5e73\u8861\u3001\u6a21\u5f0f\u8bc6\u522b\u3001\u7279\u5f81\u63d0\u53d6\u548c\u6cdb\u5316\u65b9\u9762\u5b58\u5728\u56f0\u96be\uff0c\u9700\u8981\u5f00\u53d1\u66f4\u6709\u6548\u7684\u8f6f\u4ef6\u8d28\u91cf\u8bc4\u4f30\u65b9\u6cd5\u3002", "method": "\u5f00\u53d1ADE-QVAET\u6a21\u578b\uff0c\u7ed3\u5408\u81ea\u9002\u5e94\u5dee\u5206\u8fdb\u5316\u4f18\u5316\u548c\u91cf\u5b50\u53d8\u5206\u81ea\u7f16\u7801\u5668-Transformer\uff0c\u83b7\u53d6\u9ad8\u7ef4\u6f5c\u5728\u7279\u5f81\u5e76\u4fdd\u6301\u5e8f\u5217\u4f9d\u8d56\u5173\u7cfb\uff0c\u901a\u8fc7\u8d85\u53c2\u6570\u8c03\u4f18\u5b9e\u73b0\u53ef\u6269\u5c55\u7684\u7f3a\u9677\u9884\u6d4b\u3002", "result": "\u572890%\u8bad\u7ec3\u6bd4\u4f8b\u4e0b\uff0cADE-QVAET\u8fbe\u523098.08%\u51c6\u786e\u7387\u300192.45%\u7cbe\u786e\u7387\u300194.67%\u53ec\u56de\u7387\u548c98.12% F1\u5206\u6570\uff0c\u4f18\u4e8e\u5dee\u5206\u8fdb\u5316ML\u6a21\u578b\u3002", "conclusion": "ADE-QVAET\u901a\u8fc7AI-ML\u6280\u672f\u96c6\u6210\uff0c\u4e3a\u8d28\u91cf\u5de5\u7a0b\u63d0\u4f9b\u4e86\u6709\u6548\u7684\u8f6f\u4ef6\u7f3a\u9677\u9884\u6d4b\u89e3\u51b3\u65b9\u6848\uff0c\u663e\u8457\u63d0\u5347\u4e86\u9884\u6d4b\u6027\u80fd\u3002"}}
{"id": "2510.10887", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.10887", "abs": "https://arxiv.org/abs/2510.10887", "authors": ["Lakshana Iruni Assalaarachchi", "Zainab Masood", "Rashina Hoda", "John Grundy"], "title": "Generative AI for Software Project Management: Insights from a Review of Software Practitioner Literature", "comment": null, "summary": "Software practitioners are discussing GenAI transformations in software\nproject management openly and widely. To understand the state of affairs, we\nperformed a grey literature review using 47 publicly available practitioner\nsources including blogs, articles, and industry reports. We found that software\nproject managers primarily perceive GenAI as an \"assistant\", \"copilot\", or\n\"friend\" rather than as a \"PM replacement\", with support of GenAI in automating\nroutine tasks, predictive analytics, communication and collaboration, and in\nagile practices leading to project success. Practitioners emphasize responsible\nGenAI usage given concerns such as hallucinations, ethics and privacy, and lack\nof emotional intelligence and human judgment. We present upskilling\nrequirements for software project managers in the GenAI era mapped to the\nProject Management Institute's talent triangle. We share key recommendations\nfor both practitioners and researchers.", "AI": {"tldr": "\u8f6f\u4ef6\u9879\u76ee\u7ecf\u7406\u5c06GenAI\u89c6\u4e3a\u52a9\u624b\u800c\u975e\u66ff\u4ee3\u54c1\uff0c\u652f\u6301\u81ea\u52a8\u5316\u5e38\u89c4\u4efb\u52a1\u3001\u9884\u6d4b\u5206\u6790\u3001\u6c9f\u901a\u534f\u4f5c\u548c\u654f\u6377\u5b9e\u8df5\uff0c\u4f46\u9700\u8d1f\u8d23\u4efb\u4f7f\u7528\u4ee5\u5e94\u5bf9\u5e7b\u89c9\u3001\u4f26\u7406\u9690\u79c1\u7b49\u95ee\u9898\u3002", "motivation": "\u4e86\u89e3\u8f6f\u4ef6\u9879\u76ee\u7ba1\u7406\u4e2dGenAI\u8f6c\u578b\u7684\u73b0\u72b6\uff0c\u901a\u8fc7\u4ece\u4e1a\u8005\u516c\u5f00\u8ba8\u8bba\u6765\u638c\u63e1\u5b9e\u9645\u5e94\u7528\u60c5\u51b5\u3002", "method": "\u5bf947\u4e2a\u516c\u5f00\u4ece\u4e1a\u8005\u8d44\u6e90\uff08\u535a\u5ba2\u3001\u6587\u7ae0\u3001\u884c\u4e1a\u62a5\u544a\uff09\u8fdb\u884c\u7070\u8272\u6587\u732e\u7efc\u8ff0\u3002", "result": "\u8f6f\u4ef6\u9879\u76ee\u7ecf\u7406\u4e3b\u8981\u5c06GenAI\u89c6\u4e3a\"\u52a9\u624b\"\u3001\"\u526f\u9a7e\u9a76\"\u6216\"\u670b\u53cb\"\u800c\u975e\"PM\u66ff\u4ee3\u54c1\"\uff0c\u652f\u6301\u81ea\u52a8\u5316\u5e38\u89c4\u4efb\u52a1\u3001\u9884\u6d4b\u5206\u6790\u3001\u6c9f\u901a\u534f\u4f5c\u548c\u654f\u6377\u5b9e\u8df5\u3002\u4ece\u4e1a\u8005\u5f3a\u8c03\u8d1f\u8d23\u4efb\u4f7f\u7528GenAI\uff0c\u5173\u6ce8\u5e7b\u89c9\u3001\u4f26\u7406\u9690\u79c1\u3001\u7f3a\u4e4f\u60c5\u611f\u667a\u80fd\u548c\u4eba\u7c7b\u5224\u65ad\u7b49\u95ee\u9898\u3002", "conclusion": "\u63d0\u51fa\u4e86GenAI\u65f6\u4ee3\u8f6f\u4ef6\u9879\u76ee\u7ecf\u7406\u7684\u6280\u80fd\u63d0\u5347\u8981\u6c42\uff0c\u6620\u5c04\u5230\u9879\u76ee\u7ba1\u7406\u534f\u4f1a\u4eba\u624d\u4e09\u89d2\u6a21\u578b\uff0c\u5e76\u4e3a\u4ece\u4e1a\u8005\u548c\u7814\u7a76\u4eba\u5458\u63d0\u4f9b\u4e86\u5173\u952e\u5efa\u8bae\u3002"}}
{"id": "2510.10956", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.10956", "abs": "https://arxiv.org/abs/2510.10956", "authors": ["Zhiqiang Yuan", "Wenjun Mao", "Zhuo Chen", "Xiyue Shang", "Chong Wang", "Yiling Lou", "Xin Peng"], "title": "Project-Level C-to-Rust Translation via Synergistic Integration of Knowledge Graphs and Large Language Models", "comment": null, "summary": "Translating C code into safe Rust is an effective way to ensure its memory\nsafety. Compared to rule-based translation which produces Rust code that\nremains largely unsafe, LLM-based methods can generate more idiomatic and safer\nRust code because LLMs have been trained on vast amount of human-written\nidiomatic code. Although promising, existing LLM-based methods still struggle\nwith project-level C-to-Rust translation. They typically partition a C project\ninto smaller units (\\eg{} functions) based on call graphs and translate them\nbottom-up to resolve program dependencies. However, this bottom-up,\nunit-by-unit paradigm often fails to translate pointers due to the lack of a\nglobal perspective on their usage. To address this problem, we propose a novel\nC-Rust Pointer Knowledge Graph (KG) that enriches a code-dependency graph with\ntwo types of pointer semantics: (i) pointer-usage information which record\nglobal behaviors such as points-to flows and map lower-level struct usage to\nhigher-level units; and (ii) Rust-oriented annotations which encode ownership,\nmutability, nullability, and lifetime. Synthesizing the \\kg{} with LLMs, we\nfurther propose \\ourtool{}, which implements a project-level C-to-Rust\ntranslation technique. In \\ourtool{}, the \\kg{} provides LLMs with\ncomprehensive pointer semantics from a global perspective, thus guiding LLMs\ntowards generating safe and idiomatic Rust code from a given C project. Our\nexperiments show that \\ourtool{} reduces unsafe usages in translated Rust by\n99.9\\% compared to both rule-based translation and traditional LLM-based\nrewriting, while achieving an average 29.3\\% higher functional correctness than\nthose fuzzing-enhanced LLM methods.", "AI": {"tldr": "\u63d0\u51fa\u4e86\u4e00\u79cd\u57fa\u4e8e\u6307\u9488\u77e5\u8bc6\u56fe\u8c31\u7684C\u5230Rust\u9879\u76ee\u7ea7\u7ffb\u8bd1\u65b9\u6cd5\uff0c\u901a\u8fc7\u5168\u5c40\u6307\u9488\u8bed\u4e49\u4fe1\u606f\u663e\u8457\u63d0\u5347\u7ffb\u8bd1\u4ee3\u7801\u7684\u5b89\u5168\u6027\u548c\u6b63\u786e\u6027\u3002", "motivation": "\u73b0\u6709\u57fa\u4e8eLLM\u7684C\u5230Rust\u7ffb\u8bd1\u65b9\u6cd5\u5728\u9879\u76ee\u7ea7\u522b\u5b58\u5728\u56f0\u96be\uff0c\u7279\u522b\u662f\u5bf9\u6307\u9488\u7684\u5904\u7406\u7f3a\u4e4f\u5168\u5c40\u89c6\u89d2\uff0c\u5bfc\u81f4\u751f\u6210\u7684Rust\u4ee3\u7801\u4ecd\u7136\u4e0d\u591f\u5b89\u5168\u3002", "method": "\u6784\u5efaC-Rust\u6307\u9488\u77e5\u8bc6\u56fe\u8c31\uff0c\u5305\u542b\u6307\u9488\u4f7f\u7528\u4fe1\u606f\u548cRust\u5bfc\u5411\u7684\u6ce8\u89e3\uff0c\u7ed3\u5408LLM\u8fdb\u884c\u9879\u76ee\u7ea7\u7ffb\u8bd1\u3002", "result": "\u76f8\u6bd4\u57fa\u4e8e\u89c4\u5219\u7684\u7ffb\u8bd1\u548c\u4f20\u7edfLLM\u91cd\u5199\uff0c\u51cf\u5c11\u4e8699.9%\u7684\u4e0d\u5b89\u5168\u4f7f\u7528\uff0c\u529f\u80fd\u6b63\u786e\u6027\u6bd4\u6a21\u7cca\u6d4b\u8bd5\u589e\u5f3a\u7684LLM\u65b9\u6cd5\u5e73\u5747\u63d0\u9ad829.3%\u3002", "conclusion": "\u6307\u9488\u77e5\u8bc6\u56fe\u8c31\u80fd\u591f\u6709\u6548\u63d0\u5347LLM\u5728C\u5230Rust\u7ffb\u8bd1\u4e2d\u7684\u8868\u73b0\uff0c\u751f\u6210\u66f4\u5b89\u5168\u3001\u66f4\u7b26\u5408Rust\u4e60\u60ef\u7684\u4ee3\u7801\u3002"}}
{"id": "2510.11039", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.11039", "abs": "https://arxiv.org/abs/2510.11039", "authors": ["Yifeng Zhu", "Xianlin Zhao", "Xutian Li", "Yanzhen Zou", "Haizhuo Yuan", "Yue Wang", "Bing Xie"], "title": "RepoSummary: Feature-Oriented Summarization and Documentation Generation for Code Repositories", "comment": null, "summary": "Repository summarization is a crucial research question in development and\nmaintenance for software engineering. Existing repository summarization\ntechniques primarily focus on summarizing code according to the directory tree,\nwhich is insufficient for tracing high-level features to the methods that\ncollaboratively implement them. To address these limitations, we propose\nRepoSummary, a feature-oriented code repository summarization approach that\nsimultaneously generates repository documentation automatically. Furthermore,\nit establishes more accurate traceability links from functional features to the\ncorresponding code elements, enabling developers to rapidly locate relevant\nmethods and files during code comprehension and maintenance. Comprehensive\nexperiments against the state-of-the-art baseline (HGEN) demonstrate that\nRepoSummary achieves higher feature coverage and more accurate traceability. On\naverage, it increases the rate of completely covered features in manual\ndocumentation from 61.2% to 71.1%, improves file-level traceability recall from\n29.9% to 53.0%, and generates documentation that is more conceptually\nconsistent, easier to understand, and better formatted than that produced by\nexisting approaches.", "AI": {"tldr": "RepoSummary\u662f\u4e00\u79cd\u9762\u5411\u7279\u5f81\u7684\u4ee3\u7801\u4ed3\u5e93\u6458\u8981\u65b9\u6cd5\uff0c\u80fd\u81ea\u52a8\u751f\u6210\u4ed3\u5e93\u6587\u6863\u5e76\u5efa\u7acb\u4ece\u529f\u80fd\u7279\u5f81\u5230\u4ee3\u7801\u5143\u7d20\u7684\u51c6\u786e\u53ef\u8ffd\u6eaf\u94fe\u63a5\uff0c\u76f8\u6bd4\u73b0\u6709\u65b9\u6cd5\u5728\u7279\u5f81\u8986\u76d6\u7387\u548c\u53ef\u8ffd\u6eaf\u6027\u65b9\u9762\u8868\u73b0\u66f4\u4f18\u3002", "motivation": "\u73b0\u6709\u4ed3\u5e93\u6458\u8981\u6280\u672f\u4e3b\u8981\u57fa\u4e8e\u76ee\u5f55\u6811\u7ed3\u6784\u8fdb\u884c\u4ee3\u7801\u6458\u8981\uff0c\u65e0\u6cd5\u6709\u6548\u8ffd\u8e2a\u9ad8\u5c42\u6b21\u7279\u5f81\u5230\u534f\u4f5c\u5b9e\u73b0\u5b83\u4eec\u7684\u5bf9\u5e94\u65b9\u6cd5\uff0c\u8fd9\u9650\u5236\u4e86\u4ee3\u7801\u7406\u89e3\u548c\u7ef4\u62a4\u7684\u6548\u7387\u3002", "method": "\u63d0\u51faRepoSummary\u65b9\u6cd5\uff0c\u91c7\u7528\u9762\u5411\u7279\u5f81\u7684\u65b9\u6cd5\u8fdb\u884c\u4ee3\u7801\u4ed3\u5e93\u6458\u8981\uff0c\u540c\u65f6\u81ea\u52a8\u751f\u6210\u4ed3\u5e93\u6587\u6863\uff0c\u5e76\u5efa\u7acb\u4ece\u529f\u80fd\u7279\u5f81\u5230\u76f8\u5e94\u4ee3\u7801\u5143\u7d20\u7684\u51c6\u786e\u53ef\u8ffd\u6eaf\u94fe\u63a5\u3002", "result": "\u76f8\u6bd4\u6700\u5148\u8fdb\u7684\u57fa\u7ebf\u65b9\u6cd5HGEN\uff0cRepoSummary\u5728\u7279\u5f81\u8986\u76d6\u7387\u548c\u53ef\u8ffd\u6eaf\u6027\u65b9\u9762\u663e\u8457\u63d0\u5347\uff1a\u5b8c\u5168\u8986\u76d6\u7279\u5f81\u7684\u6bd4\u4f8b\u4ece61.2%\u63d0\u9ad8\u523071.1%\uff0c\u6587\u4ef6\u7ea7\u53ef\u8ffd\u6eaf\u53ec\u56de\u7387\u4ece29.9%\u63d0\u5347\u523053.0%\uff0c\u751f\u6210\u7684\u6587\u6863\u5728\u6982\u5ff5\u4e00\u81f4\u6027\u3001\u53ef\u7406\u89e3\u6027\u548c\u683c\u5f0f\u65b9\u9762\u4e5f\u66f4\u4f18\u3002", "conclusion": "RepoSummary\u901a\u8fc7\u7279\u5f81\u5bfc\u5411\u7684\u65b9\u6cd5\u6709\u6548\u89e3\u51b3\u4e86\u73b0\u6709\u4ed3\u5e93\u6458\u8981\u6280\u672f\u7684\u5c40\u9650\u6027\uff0c\u4e3a\u5f00\u53d1\u8005\u5728\u4ee3\u7801\u7406\u89e3\u548c\u7ef4\u62a4\u8fc7\u7a0b\u4e2d\u5feb\u901f\u5b9a\u4f4d\u76f8\u5173\u65b9\u6cd5\u548c\u6587\u4ef6\u63d0\u4f9b\u4e86\u6709\u529b\u652f\u6301\u3002"}}
{"id": "2510.11059", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.11059", "abs": "https://arxiv.org/abs/2510.11059", "authors": ["Jian Wang", "Xiaofei Xie", "Qiang Hu", "Shangqing Liu", "Jiongchi Yu", "Jiaolong Klong", "Yi Li"], "title": "Defects4C: Benchmarking Large Language Model Repair Capability with C/C++ Bugs", "comment": "ASE-2025 main research paper", "summary": "Automated Program Repair (APR) plays a critical role in enhancing the quality\nand reliability of software systems. While substantial progress has been made\nin Java-based APR, largely facilitated by benchmarks like Defects4J, there\nremains a significant gap in research on C/C++ program repair, despite the\nwidespread use of C/C++ and the prevalence of associated vulnerabilities. This\ngap is primarily due to the lack of high-quality, open-source benchmarks\ntailored for C/C++.\n  To address this issue, we introduce Defects4C, a comprehensive and executable\nbenchmark specifically designed for C/C++ program repair. Our dataset is\nconstructed from real-world C/C++ repositories and includes a large collection\nof bug-relevant commits (9M in total), 248 high-quality buggy functions, and\n102 vulnerable functions, all paired with test cases for reproduction. These\nresources enable rigorous evaluation of repair techniques and support the\nretraining of learning-based approaches for enhanced performance.\n  Using Defects4C, we conduct a comprehensive empirical study evaluating the\neffectiveness of 24 state-of-the-art large language models (LLMs) in repairing\nC/C++ faults. Our findings offer valuable insights into the strengths and\nlimitations of current LLM-based APR techniques in this domain, highlighting\nboth the need for more robust methods and the critical role of Defects4C in\nadvancing future research", "AI": {"tldr": "\u63d0\u51fa\u4e86Defects4C\u57fa\u51c6\u6570\u636e\u96c6\uff0c\u7528\u4e8eC/C++\u7a0b\u5e8f\u4fee\u590d\u7814\u7a76\uff0c\u5e76\u8bc4\u4f30\u4e8624\u4e2a\u5927\u578b\u8bed\u8a00\u6a21\u578b\u5728\u4fee\u590dC/C++\u9519\u8bef\u65b9\u9762\u7684\u6548\u679c\u3002", "motivation": "\u5f53\u524dJava\u7a0b\u5e8f\u4fee\u590d\u7814\u7a76\u5df2\u6709Defects4J\u7b49\u57fa\u51c6\uff0c\u4f46C/C++\u7a0b\u5e8f\u4fee\u590d\u7814\u7a76\u5b58\u5728\u660e\u663e\u5dee\u8ddd\uff0c\u7f3a\u4e4f\u9ad8\u8d28\u91cf\u7684\u5f00\u6e90\u57fa\u51c6\u6570\u636e\u96c6\u3002", "method": "\u6784\u5efa\u4e86Defects4C\u57fa\u51c6\u6570\u636e\u96c6\uff0c\u5305\u542b\u771f\u5b9eC/C++\u4ed3\u5e93\u4e2d\u7684900\u4e07\u4e2abug\u76f8\u5173\u63d0\u4ea4\u3001248\u4e2a\u9ad8\u8d28\u91cfbug\u51fd\u6570\u548c102\u4e2a\u6f0f\u6d1e\u51fd\u6570\uff0c\u5e76\u914d\u6709\u6d4b\u8bd5\u7528\u4f8b\u3002\u4f7f\u7528\u8be5\u6570\u636e\u96c6\u8bc4\u4f30\u4e8624\u4e2a\u6700\u5148\u8fdb\u7684\u5927\u578b\u8bed\u8a00\u6a21\u578b\u3002", "result": "\u7814\u7a76\u63ed\u793a\u4e86\u5f53\u524d\u57fa\u4e8eLLM\u7684C/C++\u7a0b\u5e8f\u4fee\u590d\u6280\u672f\u7684\u4f18\u52bf\u548c\u5c40\u9650\u6027\uff0c\u5f3a\u8c03\u4e86\u9700\u8981\u66f4\u9c81\u68d2\u7684\u65b9\u6cd5\u3002", "conclusion": "Defects4C\u5728\u63a8\u52a8\u672a\u6765C/C++\u7a0b\u5e8f\u4fee\u590d\u7814\u7a76\u4e2d\u53d1\u6325\u7740\u5173\u952e\u4f5c\u7528\uff0c\u586b\u8865\u4e86\u8be5\u9886\u57df\u57fa\u51c6\u6570\u636e\u96c6\u7684\u7a7a\u767d\u3002"}}
{"id": "2510.11076", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.11076", "abs": "https://arxiv.org/abs/2510.11076", "authors": ["Lingyue Fu", "Haowei Yuan", "Datong Chen", "Xinyi Dai", "Qingyao Li", "Weinan Zhang", "Weiwen Liu", "Yong Yu"], "title": "DebugTA: An LLM-Based Agent for Simplifying Debugging and Teaching in Programming Education", "comment": null, "summary": "In programming education, Debugging and Teaching (DT) task is a common\nscenario where students receive assistance in correcting their erroneous code.\nThe task involves multiple inputs, including erroneous code, error messages,\nreference solutions, and the question description, with the goal of generating\nmodification suggestions to the erroneous code. However, two key challenges\nhinder the effectiveness of existing approaches. Firstly, the complexity and\nheterogeneity of inputs inherent in DT tasks significantly elevate the\nreasoning challenges faced by LLMs. Second, existing approaches often fail to\nfully leverage the availability of standard code in DT tasks, forcing models to\nrely solely on complex multi-step reasoning, which limits the potential of LLMs\nin addressing DT tasks effectively. To address these challenges, we propose\nDebugTA, a novel LLM-based debugging and teaching agent with specialized tools\nfor standard code retrieval, variable substitution to align reference code, and\nan external compiler for real-time code analysis. Guided by explicit\npedagogical and debugging principles, DebugTA acts as an agent that decomposes\na complex task into sequential LLM interactions, each utilizing distinct tools\nfor specific subtasks, thereby simplifying the logical reasoning at each step\nand reducing overall reasoning complexity. Furthermore, DebugTA utilizes tool\ncalls to align the standard code with the erroneous code as much as possible,\nallowing the LLM to focus on logic errors within the erroneous code and\nimproving the accuracy of the generated suggestions. To rigorously assess the\nquality of modification suggestions, we introduce a student simulator-teacher\ninteraction paradigm. Experimental results on three real-world code datasets\ndemonstrate that DebugTA consistently improves teaching effectiveness while\nsignificantly reducing computational costs.", "AI": {"tldr": "\u63d0\u51faDebugTA\uff0c\u4e00\u79cd\u57fa\u4e8eLLM\u7684\u8c03\u8bd5\u548c\u6559\u5b66\u4ee3\u7406\uff0c\u901a\u8fc7\u4e13\u7528\u5de5\u5177\u548c\u663e\u5f0f\u6559\u5b66\u539f\u5219\uff0c\u5c06\u590d\u6742\u8c03\u8bd5\u4efb\u52a1\u5206\u89e3\u4e3a\u987a\u5e8fLLM\u4ea4\u4e92\uff0c\u63d0\u9ad8\u6559\u5b66\u6548\u679c\u5e76\u964d\u4f4e\u8ba1\u7b97\u6210\u672c\u3002", "motivation": "\u7f16\u7a0b\u6559\u80b2\u4e2d\u7684\u8c03\u8bd5\u4e0e\u6559\u5b66\u4efb\u52a1\u9762\u4e34\u8f93\u5165\u590d\u6742\u6027\u548c\u5f02\u8d28\u6027\u6311\u6218\uff0c\u73b0\u6709\u65b9\u6cd5\u672a\u80fd\u5145\u5206\u5229\u7528\u6807\u51c6\u4ee3\u7801\uff0c\u9650\u5236\u4e86LLM\u7684\u6f5c\u529b\u3002", "method": "\u5f00\u53d1DebugTA\u4ee3\u7406\uff0c\u5305\u542b\u6807\u51c6\u4ee3\u7801\u68c0\u7d22\u3001\u53d8\u91cf\u66ff\u6362\u5bf9\u9f50\u53c2\u8003\u4ee3\u7801\u3001\u5916\u90e8\u7f16\u8bd1\u5668\u5b9e\u65f6\u5206\u6790\u7b49\u4e13\u7528\u5de5\u5177\uff0c\u901a\u8fc7\u5206\u89e3\u4efb\u52a1\u4e3a\u987a\u5e8fLLM\u4ea4\u4e92\u7b80\u5316\u63a8\u7406\u3002", "result": "\u5728\u4e09\u4e2a\u771f\u5b9e\u4e16\u754c\u4ee3\u7801\u6570\u636e\u96c6\u4e0a\u7684\u5b9e\u9a8c\u8868\u660e\uff0cDebugTA\u6301\u7eed\u63d0\u9ad8\u6559\u5b66\u6548\u679c\uff0c\u540c\u65f6\u663e\u8457\u964d\u4f4e\u8ba1\u7b97\u6210\u672c\u3002", "conclusion": "DebugTA\u901a\u8fc7\u5de5\u5177\u8c03\u7528\u548c\u4efb\u52a1\u5206\u89e3\u6709\u6548\u89e3\u51b3\u4e86DT\u4efb\u52a1\u4e2d\u7684\u63a8\u7406\u6311\u6218\uff0c\u4e3a\u7f16\u7a0b\u6559\u80b2\u4e2d\u7684\u8c03\u8bd5\u6559\u5b66\u63d0\u4f9b\u4e86\u6709\u6548\u89e3\u51b3\u65b9\u6848\u3002"}}
{"id": "2510.11138", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.11138", "abs": "https://arxiv.org/abs/2510.11138", "authors": ["Zitao Wang", "Zhimin Zhao", "Michael W. Godfrey"], "title": "What Slows Down FMware Development? An Empirical Study of Developer Challenges and Resolution Times", "comment": null, "summary": "Foundation Models (FMs), such as OpenAI's GPT, are fundamentally transforming\nthe practice of software engineering by enabling the development of\n\\emph{FMware} -- applications and infrastructures built around these models.\nFMware systems now support tasks such as code generation, natural-language\ninteraction, knowledge integration, and multi-modal content creation,\nunderscoring their disruptive impact on current software engineering workflows.\nHowever, the design, implementation, and evolution of FMware present\nsignificant new challenges, particularly across cloud-based and on-premise\nplatforms where goals, processes, and tools often diverge from those of\ntraditional software development.\n  To our knowledge, this is the first large-scale analysis of FMware\ndevelopment across both cloud-based platforms and open-source repositories. We\nempirically investigate the FMware ecosystem through three focus areas: (1) the\nmost common application domains of FMware, (2) the key challenges developers\nencounter, and (3) the types of issues that demand the greatest effort to\nresolve. Our analysis draws on data from GitHub repositories and from leading\nFMware platforms, including HuggingFace, GPTStore, Ora, and Poe. Our findings\nreveal a strong focus on education, content creation, and business strategy,\nalongside persistent technical challenges in memory management, dependency\nhandling, and tokenizer configuration. On GitHub, bug reports and core\nfunctionality issues are the most frequently reported problems, while code\nreview, similarity search, and prompt template design are the most\ntime-consuming to resolve.\n  By uncovering developer practices and pain points, this study points to\nopportunities to improve FMware tools, workflows, and community support, and\nprovides actionable insights to help guide the future of FMware development.", "AI": {"tldr": "\u672c\u6587\u9996\u6b21\u5bf9FMware\uff08\u57fa\u4e8e\u57fa\u7840\u6a21\u578b\u7684\u5e94\u7528\u548c\u57fa\u7840\u8bbe\u65bd\uff09\u5728\u4e91\u7aef\u5e73\u53f0\u548c\u5f00\u6e90\u4ed3\u5e93\u4e2d\u7684\u5f00\u53d1\u8fdb\u884c\u4e86\u5927\u89c4\u6a21\u5206\u6790\uff0c\u63ed\u793a\u4e86\u4e3b\u8981\u5e94\u7528\u9886\u57df\u3001\u5f00\u53d1\u6311\u6218\u548c\u8017\u65f6\u95ee\u9898\u3002", "motivation": "\u57fa\u7840\u6a21\u578b\uff08\u5982GPT\uff09\u6b63\u5728\u5f7b\u5e95\u6539\u53d8\u8f6f\u4ef6\u5de5\u7a0b\u5b9e\u8df5\uff0c\u4f46FMware\u7684\u8bbe\u8ba1\u3001\u5b9e\u73b0\u548c\u6f14\u8fdb\u5e26\u6765\u4e86\u65b0\u7684\u6311\u6218\uff0c\u7279\u522b\u662f\u5728\u4e91\u7aef\u548c\u672c\u5730\u5e73\u53f0\u4e2d\uff0c\u5176\u76ee\u6807\u3001\u6d41\u7a0b\u548c\u5de5\u5177\u4e0e\u4f20\u7edf\u8f6f\u4ef6\u5f00\u53d1\u5b58\u5728\u5dee\u5f02\u3002", "method": "\u901a\u8fc7\u5206\u6790GitHub\u4ed3\u5e93\u548c\u4e3b\u8981FMware\u5e73\u53f0\uff08HuggingFace\u3001GPTStore\u3001Ora\u3001Poe\uff09\u7684\u6570\u636e\uff0c\u4ece\u4e09\u4e2a\u7ef4\u5ea6\u5b9e\u8bc1\u7814\u7a76FMware\u751f\u6001\u7cfb\u7edf\uff1a\u5e38\u89c1\u5e94\u7528\u9886\u57df\u3001\u5f00\u53d1\u8005\u9047\u5230\u7684\u5173\u952e\u6311\u6218\u3001\u9700\u8981\u6700\u5927\u52aa\u529b\u89e3\u51b3\u7684\u95ee\u9898\u7c7b\u578b\u3002", "result": "\u7814\u7a76\u53d1\u73b0FMware\u4e3b\u8981\u805a\u7126\u6559\u80b2\u3001\u5185\u5bb9\u521b\u4f5c\u548c\u5546\u4e1a\u6218\u7565\u9886\u57df\uff1b\u5b58\u5728\u5185\u5b58\u7ba1\u7406\u3001\u4f9d\u8d56\u5904\u7406\u548c\u5206\u8bcd\u5668\u914d\u7f6e\u7b49\u6280\u672f\u6311\u6218\uff1b\u5728GitHub\u4e0a\uff0c\u9519\u8bef\u62a5\u544a\u548c\u6838\u5fc3\u529f\u80fd\u95ee\u9898\u6700\u5e38\u88ab\u62a5\u544a\uff0c\u800c\u4ee3\u7801\u5ba1\u67e5\u3001\u76f8\u4f3c\u6027\u641c\u7d22\u548c\u63d0\u793a\u6a21\u677f\u8bbe\u8ba1\u6700\u8017\u65f6\u3002", "conclusion": "\u901a\u8fc7\u63ed\u793a\u5f00\u53d1\u5b9e\u8df5\u548c\u75db\u70b9\uff0c\u672c\u7814\u7a76\u4e3a\u6539\u8fdbFMware\u5de5\u5177\u3001\u5de5\u4f5c\u6d41\u7a0b\u548c\u793e\u533a\u652f\u6301\u63d0\u4f9b\u4e86\u673a\u4f1a\uff0c\u5e76\u4e3aFMware\u5f00\u53d1\u7684\u672a\u6765\u63d0\u4f9b\u4e86\u53ef\u64cd\u4f5c\u7684\u89c1\u89e3\u3002"}}
{"id": "2510.11179", "categories": ["cs.SE", "astro-ph.IM"], "pdf": "https://arxiv.org/pdf/2510.11179", "abs": "https://arxiv.org/abs/2510.11179", "authors": ["David Georg Reichelt", "Shinhyung Yang", "Wilhelm Hasselbring"], "title": "Interoperability From OpenTelemetry to Kieker: Demonstrated as Export from the Astronomy Shop", "comment": "Accepted for publication in Symposium on Software Performance 2025", "summary": "The observability framework Kieker provides a range of analysis capabilities,\nbut it is currently only able to instrument a smaller selection of languages\nand technologies, including Java, C, Fortran, and Python. The OpenTelemetry\nstandard aims for providing reference implementations for most programming\nlanguages, including C# and JavaScript, that are currently not supported by\nKieker. In this work, we describe how to transform OpenTelemetry tracing data\ninto the Kieker framework. Thereby, it becomes possible to create for example\ncall trees from OpenTelemetry instrumentations. We demonstrate the usability of\nour approach by visualizing trace data of the Astronomy Shop, which is an\nOpenTelemetry demo application.", "AI": {"tldr": "\u5c06OpenTelemetry\u8ffd\u8e2a\u6570\u636e\u8f6c\u6362\u4e3aKieker\u6846\u67b6\u683c\u5f0f\uff0c\u4f7fKieker\u80fd\u591f\u5206\u6790\u66f4\u591a\u7f16\u7a0b\u8bed\u8a00\u7684\u6570\u636e", "motivation": "Kieker\u6846\u67b6\u76ee\u524d\u53ea\u652f\u6301\u6709\u9650\u7684\u8bed\u8a00\uff08Java\u3001C\u3001Fortran\u3001Python\uff09\uff0c\u800cOpenTelemetry\u6807\u51c6\u652f\u6301\u66f4\u591a\u8bed\u8a00\uff08\u5982C#\u3001JavaScript\uff09\uff0c\u9700\u8981\u5c06\u4e24\u8005\u96c6\u6210\u4ee5\u6269\u5c55\u5206\u6790\u80fd\u529b", "method": "\u5f00\u53d1\u6570\u636e\u8f6c\u6362\u65b9\u6cd5\uff0c\u5c06OpenTelemetry\u7684\u8ffd\u8e2a\u6570\u636e\u683c\u5f0f\u8f6c\u6362\u4e3aKieker\u6846\u67b6\u53ef\u5904\u7406\u7684\u683c\u5f0f", "result": "\u6210\u529f\u5b9e\u73b0\u4e86\u6570\u636e\u8f6c\u6362\uff0c\u80fd\u591f\u4eceOpenTelemetry\u68c0\u6d4b\u7684\u5e94\u7528\uff08\u5982Astronomy Shop\u6f14\u793a\u5e94\u7528\uff09\u751f\u6210\u8c03\u7528\u6811\u7b49\u5206\u6790\u7ed3\u679c", "conclusion": "\u901a\u8fc7\u96c6\u6210OpenTelemetry\u548cKieker\uff0c\u663e\u8457\u6269\u5c55\u4e86Kieker\u6846\u67b6\u7684\u8bed\u8a00\u652f\u6301\u8303\u56f4\uff0c\u589e\u5f3a\u4e86\u5176\u53ef\u89c2\u6d4b\u6027\u5206\u6790\u80fd\u529b"}}
{"id": "2510.11310", "categories": ["cs.SE", "cs.OS", "cs.PF", "D.2.8; D.4.8; C.4"], "pdf": "https://arxiv.org/pdf/2510.11310", "abs": "https://arxiv.org/abs/2510.11310", "authors": ["Shinhyung Yang", "David Georg Reichelt", "Henrik Ingo", "Wilhelm Hasselbring"], "title": "Detection of Performance Changes in MooBench Results Using Nyrki\u00f6 on GitHub Actions", "comment": "3 pages, 3 figures, 16th Symposium on Software Performance\n  (https://www.performance-symposium.org/)", "summary": "In GitHub with its 518 million hosted projects, performance changes within\nthese projects are highly relevant to the project's users. Although performance\nmeasurement is supported by GitHub CI/CD, performance change detection is a\nchallenging topic.\n  In this paper, we demonstrate how we incorporated Nyrki\\\"o to MooBench. Prior\nto this work, Moobench continuously ran on GitHub virtual machines, measuring\noverhead of tracing agents, but without change detection. By adding the upload\nof the measurements to the Nyrki\\\"o change detection service, we made it\npossible to detect performance changes. We identified one major performance\nregression and examined the performance change in depth. We report that (1) it\nis reproducible with GitHub actions, and (2) the performance regression is\ncaused by a Linux Kernel version change.", "AI": {"tldr": "\u5c06Nyrki\u00f6\u53d8\u66f4\u68c0\u6d4b\u670d\u52a1\u96c6\u6210\u5230MooBench\u4e2d\uff0c\u5b9e\u73b0\u4e86GitHub\u9879\u76ee\u6027\u80fd\u53d8\u5316\u7684\u81ea\u52a8\u68c0\u6d4b\uff0c\u53d1\u73b0\u4e86\u4e00\u4e2a\u7531Linux\u5185\u6838\u7248\u672c\u53d8\u66f4\u5bfc\u81f4\u7684\u6027\u80fd\u56de\u5f52\u95ee\u9898\u3002", "motivation": "GitHub\u4e0a\u67095.18\u4ebf\u4e2a\u9879\u76ee\uff0c\u6027\u80fd\u53d8\u5316\u5bf9\u9879\u76ee\u7528\u6237\u81f3\u5173\u91cd\u8981\uff0c\u4f46\u6027\u80fd\u53d8\u66f4\u68c0\u6d4b\u662f\u4e00\u4e2a\u5177\u6709\u6311\u6218\u6027\u7684\u95ee\u9898\u3002", "method": "\u5728MooBench\u4e2d\u96c6\u6210Nyrki\u00f6\u53d8\u66f4\u68c0\u6d4b\u670d\u52a1\uff0c\u5c06\u6d4b\u91cf\u6570\u636e\u4e0a\u4f20\u5230\u8be5\u670d\u52a1\u4ee5\u68c0\u6d4b\u6027\u80fd\u53d8\u5316\u3002", "result": "\u8bc6\u522b\u51fa\u4e00\u4e2a\u4e3b\u8981\u7684\u6027\u80fd\u56de\u5f52\u95ee\u9898\uff0c\u8be5\u95ee\u9898\u53ef\u901a\u8fc7GitHub Actions\u91cd\u73b0\uff0c\u4e14\u7531Linux\u5185\u6838\u7248\u672c\u53d8\u66f4\u5f15\u8d77\u3002", "conclusion": "\u901a\u8fc7\u96c6\u6210\u53d8\u66f4\u68c0\u6d4b\u670d\u52a1\uff0c\u6210\u529f\u5b9e\u73b0\u4e86GitHub\u9879\u76ee\u6027\u80fd\u53d8\u5316\u7684\u81ea\u52a8\u68c0\u6d4b\uff0c\u5e76\u53d1\u73b0\u4e86\u5177\u4f53\u7684\u6027\u80fd\u56de\u5f52\u539f\u56e0\u3002"}}
{"id": "2510.11516", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.11516", "abs": "https://arxiv.org/abs/2510.11516", "authors": ["Jeena Javahar", "Tanya Budhrani", "Manaal Basha", "Cleidson R. B. de Souza", "Ivan Beschastnikh", "Gema Rodriguez-Perez"], "title": "Cracking CodeWhisperer: Analyzing Developers' Interactions and Patterns During Programming Tasks", "comment": "VL/HCC 2025 Short Paper", "summary": "The use of AI code-generation tools is becoming increasingly common, making\nit important to understand how software developers are adopting these tools. In\nthis study, we investigate how developers engage with Amazon's CodeWhisperer,\nan LLM-based code-generation tool. We conducted two user studies with two\ngroups of 10 participants each, interacting with CodeWhisperer - the first to\nunderstand which interactions were critical to capture and the second to\ncollect low-level interaction data using a custom telemetry plugin. Our\nmixed-methods analysis identified four behavioral patterns: 1) incremental code\nrefinement, 2) explicit instruction using natural language comments, 3)\nbaseline structuring with model suggestions, and 4) integrative use with\nexternal sources. We provide a comprehensive analysis of these patterns .", "AI": {"tldr": "\u7814\u7a76\u5206\u6790\u4e86\u5f00\u53d1\u8005\u4f7f\u7528Amazon CodeWhisperer\uff08\u57fa\u4e8eLLM\u7684\u4ee3\u7801\u751f\u6210\u5de5\u5177\uff09\u7684\u884c\u4e3a\u6a21\u5f0f\uff0c\u901a\u8fc7\u7528\u6237\u7814\u7a76\u8bc6\u522b\u51fa\u56db\u79cd\u5173\u952e\u4ea4\u4e92\u6a21\u5f0f\u3002", "motivation": "\u968f\u7740AI\u4ee3\u7801\u751f\u6210\u5de5\u5177\u7684\u666e\u53ca\uff0c\u7406\u89e3\u5f00\u53d1\u8005\u5982\u4f55\u91c7\u7528\u8fd9\u4e9b\u5de5\u5177\u53d8\u5f97\u91cd\u8981\uff0c\u7279\u522b\u662f\u9488\u5bf9Amazon CodeWhisperer\u7684\u4f7f\u7528\u884c\u4e3a\u3002", "method": "\u8fdb\u884c\u4e86\u4e24\u4e2a\u7528\u6237\u7814\u7a76\uff0c\u6bcf\u7ec410\u540d\u53c2\u4e0e\u8005\uff0c\u7b2c\u4e00\u4e2a\u7814\u7a76\u786e\u5b9a\u5173\u952e\u4ea4\u4e92\uff0c\u7b2c\u4e8c\u4e2a\u7814\u7a76\u4f7f\u7528\u81ea\u5b9a\u4e49\u9065\u6d4b\u63d2\u4ef6\u6536\u96c6\u4f4e\u7ea7\u522b\u4ea4\u4e92\u6570\u636e\uff0c\u91c7\u7528\u6df7\u5408\u65b9\u6cd5\u5206\u6790\u3002", "result": "\u8bc6\u522b\u51fa\u56db\u79cd\u884c\u4e3a\u6a21\u5f0f\uff1a1\uff09\u589e\u91cf\u4ee3\u7801\u7cbe\u70bc 2\uff09\u4f7f\u7528\u81ea\u7136\u8bed\u8a00\u6ce8\u91ca\u7684\u663e\u5f0f\u6307\u4ee4 3\uff09\u57fa\u4e8e\u6a21\u578b\u5efa\u8bae\u7684\u57fa\u7ebf\u7ed3\u6784\u5316 4\uff09\u4e0e\u5916\u90e8\u8d44\u6e90\u7684\u6574\u5408\u4f7f\u7528\u3002", "conclusion": "\u63d0\u4f9b\u4e86\u5bf9\u8fd9\u4e9b\u884c\u4e3a\u6a21\u5f0f\u7684\u5168\u9762\u5206\u6790\uff0c\u6709\u52a9\u4e8e\u7406\u89e3\u5f00\u53d1\u8005\u5982\u4f55\u4e0eAI\u4ee3\u7801\u751f\u6210\u5de5\u5177\u4e92\u52a8\u3002"}}
{"id": "2510.11536", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.11536", "abs": "https://arxiv.org/abs/2510.11536", "authors": ["Manaal Basha", "Aime\u00ea M. Ribeiro", "Jeena Javahar", "Cleidson R. B. de Souza", "Gema Rodr\u00edguez-P\u00e9rez"], "title": "CodeWatcher: IDE Telemetry Data Extraction Tool for Understanding Coding Interactions with LLMs", "comment": "ICSME 2025 Tool Demonstration Track", "summary": "Understanding how developers interact with code generation tools (CGTs)\nrequires detailed, real-time data on programming behavior which is often\ndifficult to collect without disrupting workflow. We present\n\\textit{CodeWatcher}, a lightweight, unobtrusive client-server system designed\nto capture fine-grained interaction events from within the Visual Studio Code\n(VS Code) editor. \\textit{CodeWatcher} logs semantically meaningful events such\nas insertions made by CGTs, deletions, copy-paste actions, and focus shifts,\nenabling continuous monitoring of developer activity without modifying user\nworkflows. The system comprises a VS Code plugin, a Python-based RESTful API,\nand a MongoDB backend, all containerized for scalability and ease of\ndeployment. By structuring and timestamping each event, \\textit{CodeWatcher}\nenables post-hoc reconstruction of coding sessions and facilitates rich\nbehavioral analyses, including how and when CGTs are used during development.\nThis infrastructure is crucial for supporting research on responsible AI,\ndeveloper productivity, and the human-centered evaluation of CGTs. Please find\nthe demo, diagrams, and tool here: https://osf.io/j2kru/overview.", "AI": {"tldr": "CodeWatcher\u662f\u4e00\u4e2a\u8f7b\u91cf\u7ea7\u3001\u65e0\u5e72\u6270\u7684\u5ba2\u6237\u7aef-\u670d\u52a1\u5668\u7cfb\u7edf\uff0c\u7528\u4e8e\u5728VS Code\u7f16\u8f91\u5668\u4e2d\u6355\u83b7\u5f00\u53d1\u8005\u4e0e\u4ee3\u7801\u751f\u6210\u5de5\u5177\u7684\u7ec6\u7c92\u5ea6\u4ea4\u4e92\u4e8b\u4ef6\uff0c\u652f\u6301\u7f16\u7a0b\u884c\u4e3a\u7814\u7a76\u3002", "motivation": "\u7406\u89e3\u5f00\u53d1\u8005\u5982\u4f55\u4e0e\u4ee3\u7801\u751f\u6210\u5de5\u5177\u4ea4\u4e92\u9700\u8981\u8be6\u7ec6\u7684\u5b9e\u65f6\u7f16\u7a0b\u884c\u4e3a\u6570\u636e\uff0c\u4f46\u6536\u96c6\u8fd9\u4e9b\u6570\u636e\u5f80\u5f80\u4f1a\u5f71\u54cd\u5de5\u4f5c\u6d41\u7a0b\u3002", "method": "\u5f00\u53d1\u4e86\u5305\u542bVS Code\u63d2\u4ef6\u3001Python RESTful API\u548cMongoDB\u540e\u7aef\u7684\u7cfb\u7edf\uff0c\u8bb0\u5f55\u63d2\u5165\u3001\u5220\u9664\u3001\u590d\u5236\u7c98\u8d34\u548c\u7126\u70b9\u5207\u6362\u7b49\u8bed\u4e49\u5316\u4e8b\u4ef6\u3002", "result": "\u7cfb\u7edf\u80fd\u591f\u8fde\u7eed\u76d1\u63a7\u5f00\u53d1\u8005\u6d3b\u52a8\u800c\u4e0d\u4fee\u6539\u7528\u6237\u5de5\u4f5c\u6d41\u7a0b\uff0c\u652f\u6301\u7f16\u7a0b\u4f1a\u8bdd\u7684\u91cd\u6784\u548c\u884c\u4e3a\u5206\u6790\u3002", "conclusion": "\u8be5\u57fa\u7840\u8bbe\u65bd\u5bf9\u4e8e\u8d1f\u8d23\u4efbAI\u3001\u5f00\u53d1\u8005\u751f\u4ea7\u529b\u4ee5\u53ca\u4ee3\u7801\u751f\u6210\u5de5\u5177\u7684\u4eba\u672c\u8bc4\u4f30\u7814\u7a76\u81f3\u5173\u91cd\u8981\u3002"}}
{"id": "2510.11658", "categories": ["cs.SE", "97P50", "D.2.5; K.3.2"], "pdf": "https://arxiv.org/pdf/2510.11658", "abs": "https://arxiv.org/abs/2510.11658", "authors": ["Florian Oberm\u00fcller", "Gordon Fraser"], "title": "Automatically Generating Questions About Scratch Programs", "comment": "Accepted at CompEd 2025", "summary": "When learning to program, students are usually assessed based on the code\nthey wrote. However, the mere completion of a programming task does not\nguarantee actual comprehension of the underlying concepts. Asking learners\nquestions about the code they wrote has therefore been proposed as a means to\nassess program comprehension. As creating targeted questions for individual\nstudent programs can be tedious and challenging, prior work has proposed to\ngenerate such questions automatically. In this paper we generalize this idea to\nthe block-based programming language Scratch. We propose a set of 30 different\nquestions for Scratch code covering an established program comprehension model,\nand extend the LitterBox static analysis tool to automatically generate\ncorresponding questions for a given Scratch program. On a dataset of 600,913\nprojects we generated 54,118,694 questions automatically. Our initial\nexperiments with 34 ninth graders demonstrate that this approach can indeed\ngenerate meaningful questions for Scratch programs, and we find that the\nability of students to answer these questions on their programs relates to\ntheir overall performance.", "AI": {"tldr": "\u8be5\u8bba\u6587\u63d0\u51fa\u4e86\u4e00\u4e2a\u81ea\u52a8\u4e3aScratch\u7a0b\u5e8f\u751f\u6210\u7406\u89e3\u6027\u95ee\u9898\u7684\u65b9\u6cd5\uff0c\u57fa\u4e8eLitterBox\u9759\u6001\u5206\u6790\u5de5\u5177\uff0c\u572860\u591a\u4e07\u4e2a\u9879\u76ee\u4e2d\u751f\u6210\u4e865400\u591a\u4e07\u4e2a\u95ee\u9898\uff0c\u5e76\u901a\u8fc7\u5b9e\u9a8c\u9a8c\u8bc1\u4e86\u8fd9\u4e9b\u95ee\u9898\u7684\u6709\u6548\u6027\u3002", "motivation": "\u5b66\u751f\u5728\u7f16\u7a0b\u5b66\u4e60\u4e2d\uff0c\u4ec5\u4ec5\u5b8c\u6210\u7f16\u7a0b\u4efb\u52a1\u5e76\u4e0d\u80fd\u4fdd\u8bc1\u771f\u6b63\u7406\u89e3\u4e86\u7f16\u7a0b\u6982\u5ff5\u3002\u9700\u8981\u901a\u8fc7\u5bf9\u4ee3\u7801\u63d0\u95ee\u6765\u8bc4\u4f30\u7a0b\u5e8f\u7406\u89e3\u80fd\u529b\uff0c\u4f46\u4e3a\u6bcf\u4e2a\u5b66\u751f\u7a0b\u5e8f\u624b\u52a8\u521b\u5efa\u9488\u5bf9\u6027\u95ee\u9898\u5f88\u7e41\u7410\u3002", "method": "\u6269\u5c55LitterBox\u9759\u6001\u5206\u6790\u5de5\u5177\uff0c\u4e3aScratch\u7a0b\u5e8f\u81ea\u52a8\u751f\u621030\u79cd\u4e0d\u540c\u7c7b\u578b\u7684\u95ee\u9898\uff0c\u8fd9\u4e9b\u95ee\u9898\u57fa\u4e8e\u5df2\u5efa\u7acb\u7684\u7a0b\u5e8f\u7406\u89e3\u6a21\u578b\u3002", "result": "\u5728600,913\u4e2aScratch\u9879\u76ee\u4e2d\u81ea\u52a8\u751f\u6210\u4e8654,118,694\u4e2a\u95ee\u9898\u3002\u5bf934\u540d\u4e5d\u5e74\u7ea7\u5b66\u751f\u7684\u521d\u6b65\u5b9e\u9a8c\u8868\u660e\uff0c\u8be5\u65b9\u6cd5\u80fd\u751f\u6210\u6709\u610f\u4e49\u7684\u95ee\u9898\uff0c\u4e14\u5b66\u751f\u56de\u7b54\u95ee\u9898\u7684\u80fd\u529b\u4e0e\u5176\u6574\u4f53\u8868\u73b0\u76f8\u5173\u3002", "conclusion": "\u81ea\u52a8\u751f\u6210\u7a0b\u5e8f\u7406\u89e3\u95ee\u9898\u7684\u65b9\u6cd5\u5728Scratch\u7f16\u7a0b\u73af\u5883\u4e2d\u662f\u53ef\u884c\u7684\uff0c\u80fd\u591f\u6709\u6548\u8bc4\u4f30\u5b66\u751f\u7684\u7a0b\u5e8f\u7406\u89e3\u80fd\u529b\uff0c\u5e76\u4e0e\u5b66\u751f\u7684\u6574\u4f53\u5b66\u4e60\u8868\u73b0\u76f8\u5173\u8054\u3002"}}

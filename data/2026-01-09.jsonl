{"id": "2601.04252", "categories": ["cs.SE", "cs.CL"], "pdf": "https://arxiv.org/pdf/2601.04252", "abs": "https://arxiv.org/abs/2601.04252", "authors": ["Daoan Zhang", "Shuo Zhang", "Zijian Jin", "Jiebo Luo", "Shengyu Fu", "Elsie Nallipogu"], "title": "Sphinx: Benchmarking and Modeling for LLM-Driven Pull Request Review", "comment": null, "summary": "Pull request (PR) review is essential for ensuring software quality, yet automating this task remains challenging due to noisy supervision, limited contextual understanding, and inadequate evaluation metrics. We present Sphinx, a unified framework for LLM-based PR review that addresses these limitations through three key components: (1) a structured data generation pipeline that produces context-rich, semantically grounded review comments by comparing pseudo-modified and merged code; (2) a checklist-based evaluation benchmark that assesses review quality based on structured coverage of actionable verification points, moving beyond surface-level metrics like BLEU; and (3) Checklist Reward Policy Optimization (CRPO), a novel training paradigm that uses rule-based, interpretable rewards to align model behavior with real-world review practices. Extensive experiments show that models trained with Sphinx achieve state-of-the-art performance on review completeness and precision, outperforming both proprietary and open-source baselines by up to 40\\% in checklist coverage. Together, Sphinx enables the development of PR review models that are not only fluent but also context-aware, technically precise, and practically deployable in real-world development workflows. The data will be released after review."}
{"id": "2601.04293", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.04293", "abs": "https://arxiv.org/abs/2601.04293", "authors": ["Nathan Shaw", "Sanjeetha Pennada", "Robert M Hierons", "Donghwan Shin"], "title": "A Systematic Mapping Study on the Debugging of Autonomous Driving Systems", "comment": "33 pages, 7 figures", "summary": "As Autonomous Driving Systems (ADS) progress towards commercial deployment, there is an increasing focus on ensuring their safety and reliability. While considerable research has been conducted on testing methods for detecting faults in ADS, very little attention has been paid to debugging in ADS. Debugging is an essential process that follows test failures to localise and repair the faults in the systems to maintain their safety and reliability. This Systematic Mapping Study (SMS) aims to provide a detailed overview of the current landscape of ADS debugging, highlighting existing approaches and identifying gaps in research. The study also proposes directions for future work and standards for problem definition and terminology in the field. Our findings reveal various methods for ADS debugging and highlight the current fragmented yet promising landscape."}
{"id": "2601.04526", "categories": ["cs.SE", "cs.AI", "cs.CL"], "pdf": "https://arxiv.org/pdf/2601.04526", "abs": "https://arxiv.org/abs/2601.04526", "authors": ["Zhao Tian"], "title": "Advancing Language Models for Code-related Tasks", "comment": "Accepted by ICSE 2026 (DS)", "summary": "Recent advances in language models (LMs) have driven significant progress in various software engineering tasks. However, existing LMs still struggle with complex programming scenarios due to limitations in data quality, model architecture, and reasoning capability. This research systematically addresses these challenges through three complementary directions: (1) improving code data quality with a code difference-guided adversarial augmentation technique (CODA) and a code denoising technique (CodeDenoise); (2) enhancing model architecture via syntax-guided code LMs (LEAM and LEAM++); and (3) advancing model reasoning with a prompting technique (muFiX) and an agent-based technique (Specine). These techniques aim to promote the practical adoption of LMs in software development and further advance intelligent software engineering."}
{"id": "2601.04540", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2601.04540", "abs": "https://arxiv.org/abs/2601.04540", "authors": ["Tanghaoran Zhang", "Xinjun Mao", "Shangwen Wang", "Yuxin Zhao", "Yao Lu", "Jin Zhang", "Zhang Zhang", "Kang Yang", "Yue Yu"], "title": "AdaptEval: A Benchmark for Evaluating Large Language Models on Code Snippet Adaptation", "comment": "13 pages, 7 figures, Accepted by ASE 2025", "summary": "Recent advancements in large language models (LLMs) have automated various software engineering tasks, with benchmarks emerging to evaluate their capabilities. However, for adaptation, a critical activity during code reuse, there is no benchmark to assess LLMs' performance, leaving their practical utility in this area unclear. To fill this gap, we propose AdaptEval, a benchmark designed to evaluate LLMs on code snippet adaptation. Unlike existing benchmarks, AdaptEval incorporates the following three distinctive features: First, Practical Context. Tasks in AdaptEval are derived from developers' practices, preserving rich contextual information from Stack Overflow and GitHub communities. Second, Multi-granularity Annotation. Each task is annotated with requirements at both task and adaptation levels, supporting the evaluation of LLMs across diverse adaptation scenarios. Third, Fine-grained Evaluation. AdaptEval includes a two-tier testing framework combining adaptation-level and function-level tests, which enables evaluating LLMs' performance across various individual adaptations. Based on AdaptEval, we conduct the first empirical study to evaluate six instruction-tuned LLMs and especially three reasoning LLMs on code snippet adaptation. Experimental results demonstrate that AdaptEval enables the assessment of LLMs' adaptation capabilities from various perspectives. It also provides critical insights into their current limitations, particularly their struggle to follow explicit instructions. We hope AdaptEval can facilitate further investigation and enhancement of LLMs' capabilities in code snippet adaptation, supporting their real-world applications."}
{"id": "2601.04902", "categories": ["cs.FL"], "pdf": "https://arxiv.org/pdf/2601.04902", "abs": "https://arxiv.org/abs/2601.04902", "authors": ["Sławomir Lasota", "Mathieu Lehaut", "Julie Parreaux", "Radosław Piórkowski"], "title": "One-clock synthesis problems", "comment": null, "summary": "We study a generalisation of Büchi-Landweber games to the timed setting. The winning condition is specified by a non-deterministic timed automaton, and one of the players can elapse time. We perform a systematic study of synthesis problems in all variants of timed games, depending on which player's winning condition is specified, and which player's strategy (or controller, a finite-memory strategy) is sought. As our main result we prove ubiquitous undecidability in all the variants, both for strategy and controller synthesis, already for winning conditions specified by one-clock automata. This strengthens and generalises previously known undecidability results. We also fully characterise those cases where finite memory is sufficient to win, namely existence of a strategy implies existence of a controller. All our results are stated in the timed setting, while analogous results hold in the data setting where one-clock automata are replaced by one-register ones."}
{"id": "2601.04492", "categories": ["cs.PL", "cs.AI"], "pdf": "https://arxiv.org/pdf/2601.04492", "abs": "https://arxiv.org/abs/2601.04492", "authors": ["Yuanzhuo Zhang", "Zhoulai Fu", "Binoy Ravindran"], "title": "Scalable Floating-Point Satisfiability via Staged Optimization", "comment": null, "summary": "This work introduces StageSAT, a new approach to solving floating-point satisfiability that bridges SMT solving with numerical optimization. StageSAT reframes a floating-point formula as a series of optimization problems in three stages of increasing precision. It begins with a fast, projection-aided descent objective to guide the search toward a feasible region, proceeding to bit-level accuracy with ULP$^2$ optimization and a final $n$-ULP lattice refinement.\n  By construction, the final stage uses a representing function that is zero if and only if a candidate satisfies all constraints. Thus, when optimization drives the objective to zero, the resulting assignment is a valid solution, providing a built-in guarantee of soundness.\n  To improve search, StageSAT introduces a partial monotone descent property on linear constraints via orthogonal projection, preventing the optimizer from stalling on flat or misleading landscapes. Critically, this solver requires no heavy bit-level reasoning or specialized abstractions; it treats complex arithmetic as a black-box, using runtime evaluations to navigate the input space.\n  We implement StageSAT and evaluate it on extensive benchmarks, including SMT-COMP'25 suites and difficult cases from prior work. StageSAT proved more scalable and accurate than state-of-the-art optimization-based alternatives. It solved strictly more formulas than any competing solver under the same time budget, finding most satisfiable instances without producing spurious models. This amounts to 99.4% recall on satisfiable cases with 0% false SAT, exceeding the reliability of prior optimization-based solvers. StageSAT also delivered significant speedups (often 5--10$\\times$) over traditional bit-precise SMT and numeric solvers. These results demonstrate that staged optimization significantly improves performance and correctness of floating-point satisfiability solving."}
{"id": "2601.04634", "categories": ["cs.LO"], "pdf": "https://arxiv.org/pdf/2601.04634", "abs": "https://arxiv.org/abs/2601.04634", "authors": ["Lian Wen"], "title": "Limited Math: Aligning Mathematical Semantics with Finite Computation", "comment": null, "summary": "Classical mathematical models used in the semantics of programming languages and computation rely on idealized abstractions such as infinite-precision real numbers, unbounded sets, and unrestricted computation. In contrast, concrete computation is inherently finite, operating under bounded precision, bounded memory, and explicit resource constraints. This discrepancy complicates semantic reasoning about numerical behavior, algebraic properties, and termination under finite execution.\n  This paper introduces Limited Math (LM), a bounded semantic framework that aligns mathematical reasoning with finite computation. Limited Math makes constraints on numeric magnitude, numeric precision, and structural complexity explicit and foundational. A finite numeric domain parameterized by a single bound \\(M\\) is equipped with a deterministic value-mapping operator that enforces quantization and explicit boundary behavior. Functions and operators retain their classical mathematical interpretation and are mapped into the bounded domain only at a semantic boundary, separating meaning from bounded evaluation.\n  Within representable bounds, LM coincides with classical arithmetic; when bounds are exceeded, deviations are explicit, deterministic, and analyzable. By additionally bounding set cardinality, LM prevents implicit infinitary behavior from re-entering through structural constructions. As a consequence, computations realized under LM induce finite-state semantic models, providing a principled foundation for reasoning about arithmetic, structure, and execution in finite computational settings."}
{"id": "2601.04556", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.04556", "abs": "https://arxiv.org/abs/2601.04556", "authors": ["Bo Yu", "Lei Zhao"], "title": "4D-ARE: Bridging the Attribution Gap in LLM Agent Requirements Engineering", "comment": "39 pages, 11 tables", "summary": "We deployed an LLM agent with ReAct reasoning and full data access. It executed flawlessly, yet when asked \"Why is completion rate 80%?\", it returned metrics instead of causal explanation. The agent knew how to reason but we had not specified what to reason about. This reflects a gap: runtime reasoning frameworks (ReAct, Chain-of-Thought) have transformed LLM agents, but design-time specification--determining what domain knowledge agents need--remains under-explored. We propose 4D-ARE (4-Dimensional Attribution-Driven Agent Requirements Engineering), a preliminary methodology for specifying attribution-driven agents. The core insight: decision-makers seek attribution, not answers. Attribution concerns organize into four dimensions (Results -> Process -> Support -> Long-term), motivated by Pearl's causal hierarchy. The framework operationalizes through five layers producing artifacts that compile directly to system prompts. We demonstrate the methodology through an industrial pilot deployment in financial services. 4D-ARE addresses what agents should reason about, complementing runtime frameworks that address how. We hypothesize systematic specification amplifies the power of these foundational advances. This paper presents a methodological proposal with preliminary industrial validation; rigorous empirical evaluation is planned for future work."}
{"id": "2601.04573", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2601.04573", "abs": "https://arxiv.org/abs/2601.04573", "authors": ["Kazutaka Matsuda", "Minh Nguyen", "Meng Wang"], "title": "Lenses for Partially-Specified States (Extended Version)", "comment": "Extended version of our paper to appear in ESOP 2026", "summary": "A bidirectional transformation is a pair of transformations satisfying certain well-behavedness properties: one maps source data into view data, and the other translates changes on the view back to the source. However, when multiple views share a source, an update on one view may affect the others, making it hard to maintain correspondence while preserving the user's update, especially when multiple views are changed at once. Ensuring these properties within a compositional framework is even more challenging. In this paper, we propose partial-state lenses, which allow source and view states to be partially specified to precisely represent the user's update intentions. These intentions are partially ordered, providing clear semantics for merging intentions of updates coming from multiple views and a refined notion of update preservation compatible with this merging. We formalize partial-state lenses, together with partial-specifiedness-aware well-behavedness that supports compositional reasoning and ensures update preservation. In addition, we demonstrate the utility of the proposed system through examples."}
{"id": "2601.04739", "categories": ["cs.LO", "cs.FL"], "pdf": "https://arxiv.org/pdf/2601.04739", "abs": "https://arxiv.org/abs/2601.04739", "authors": ["Denis Kuperberg", "Damian Niwiński", "Paweł Parys", "Michał Skrzypczak"], "title": "Generalised Quantifiers Based on Rabin-Mostowski Index", "comment": "Full version of a paper accepted to STACS 2026", "summary": "In this work we introduce new generalised quantifiers which allow us to express the Rabin-Mostowski index of automata. Our main results study expressive power and decidability of the monadic second-order (MSO) logic extended with these quantifiers. We study these problems in the realm of both $ω$-words and infinite trees. As it turns out, the pictures in these two cases are very different. In the case of $ω$-words the new quantifiers can be effectively expressed in pure MSO logic. In contrast, in the case of infinite trees, addition of these quantifiers leads to an undecidable formalism.\n  To realise index-quantifier elimination, we consider the extension of MSO by game quantifiers. As a tool, we provide a specific quantifier-elimination procedure for them. Moreover, we introduce a novel construction of transducers realising strategies in $ω$-regular games with monadic parameters."}
{"id": "2601.04689", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.04689", "abs": "https://arxiv.org/abs/2601.04689", "authors": ["Charaka Geethal Kapugama"], "title": "Extending Delta Debugging Minimization for Spectrum-Based Fault Localization", "comment": "Accepted to 2026 IEEE 16th Annual Computing and Communication Workshop and Conference (CCWC)", "summary": "This paper introduces DDMIN-LOC, a technique that combines Delta Debugging Minimization (DDMIN) with Spectrum-Based Fault Localization (SBFL). It can be applied to programs taking string inputs, even when only a single failure-inducing input is available. DDMIN is an algorithm that systematically explores the minimal failure-inducing input that exposes a bug, given an initial failing input. However, it does not provide information about the faulty statements responsible for the failure. DDMIN-LOC addresses this limitation by collecting the passing and failing inputs generated during the DDMIN process and computing suspiciousness scores for program statements and predicates using SBFL algorithms. These scores are then combined to rank statements according to their likelihood of being faulty. DDMIN-LOC requires only one failing input of the buggy program, although it can be applied only to programs that take string inputs. DDMIN-LOC was evaluated on 136 programs selected from the QuixBugs and Codeflaws benchmarks using the SBFL algorithms Tarantula, Ochiai, GenProg, Jaccard and DStar. Experimental results show that DDMIN-LOC performs best with Jaccard: in most subjects, fewer than 20% executable lines need to be examined to locate the faulty statements. Moreover, in most subjects, faulty statements are ranked within the top 3 positions in all the generated test suites derived from different failing inputs."}
{"id": "2601.05012", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2601.05012", "abs": "https://arxiv.org/abs/2601.05012", "authors": ["Luke A. D. Hutchison"], "title": "The Squirrel Parser: A Linear-Time PEG Packrat Parser Capable of Left Recursion and Optimal Error Recovery", "comment": null, "summary": "We present the squirrel parser, a PEG packrat parser that directly handles all forms of left recursion with optimal error recovery, while maintaining linear time complexity in the length of the input even in the presence of an arbitrary number of errors. Traditional approaches to handling left recursion in a recursive descent parser require grammar rewriting or complex algorithmic extensions. We derive a minimal algorithm from first principles: cycle detection via per-position state tracking and $O(1)$-per-LR-cycle communication from descendant to ancestor recursion frames, and fixed-point search via iterative expansion. For error recovery, we derived a set of four axioms and twelve constraints that must be imposed upon an optimal error recovery design to ensure completeness, correctness, optimality of performance, and intuitiveness of behavior. We utilized a constraint satisfaction mechanism to search the space of all possibilities, arriving at a provably optimal and robust error recovery strategy that maintains perfect performance linearity."}
{"id": "2601.04814", "categories": ["cs.LO", "math.CT"], "pdf": "https://arxiv.org/pdf/2601.04814", "abs": "https://arxiv.org/abs/2601.04814", "authors": ["Kobe Wullaert", "Niels van der Weide"], "title": "The Rezk Completion for Elementary Topoi", "comment": "22 pages", "summary": "The development of category theory in univalent foundations and the formalization thereof is an active field of research. Categories in that setting are often assumed to be univalent which means that identities and isomorphisms of objects coincide. One consequence hereof is that equivalences and identities coincide for univalent categories and that structure on univalent categories transfers along equivalences. However, constructions such as the Kleisli category, the Karoubi envelope, and the tripos-to-topos construction, do not necessarily give univalent categories. To deal with that problem, one uses the Rezk completion, which completes a category into a univalent one. However, to use the Rezk completion when considering categories with structure, one also needs to show that the Rezk completion inherits the structure from the original category. In this work, we present a modular framework for lifting the Rezk completion from categories to categories with structure. We demonstrate the modularity of our framework by lifting the Rezk completion from categories to elementary topoi in manageable steps."}
{"id": "2601.04841", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.04841", "abs": "https://arxiv.org/abs/2601.04841", "authors": ["Jefferson Seide Molléri", "Sami Hyrynsalmi", "Antti Hakkala", "Kai K. Kimppa", "Jouni Smed"], "title": "A Longitudinal Analysis of Gamification in Untappd: Ethical Reflections on a Social Drinking Application", "comment": null, "summary": "This paper presents a longitudinal ethical analysis of Untappd, a social drinking application that gamifies beer consumption through badges, streaks, and social sharing. Building on an exploratory study conducted in 2020, we revisit the platform in 2025 to examine how its gamification features and ethical framings have evolved. Drawing on traditional ethical theory and practical frameworks for Software Engineering, we analyze five categories of badges and their implications for user autonomy and well-being. Our findings show that, despite small adjustments and superficial disclaimers, many of the original ethical issues remain. We argue for continuous ethical reflection built embedded into software lifecycles to prevent the normalization of risky behaviors through design."}
{"id": "2601.05199", "categories": ["cs.LO"], "pdf": "https://arxiv.org/pdf/2601.05199", "abs": "https://arxiv.org/abs/2601.05199", "authors": ["Kostia Chardonnet", "Jules Chouquet", "Axel Kerinec"], "title": "Approximation theory for distant Bang calculus", "comment": "27 pages", "summary": "Approximation semantics capture the observable behaviour of λ-terms, with Böhm Trees and Taylor Expansion standing as two central paradigms. Although conceptually different, these notions are related via the Commutation Theorem, which links the Taylor expansion of a term to that of its Böhm tree. These notions are well understood in Call-by-Name λ-calculus and have been more recently introduced in Call-by-Value settings. Since these two evaluation strategies traditionally require separate theories, a natural next step is to seek a unified setting for approximation semantics. The Bang-calculus offers exactly such a framework, subsuming both CbN and CbV through linear-logic translations while providing robust rewriting properties. However, its approximation semantics is yet to be fully developed. In this work, we develop the approximation semantics for dBang, the Bang-calculus with explicit substitutions and distant reductions. We define Böhm trees and Taylor expansion within dBang and establish their fundamental properties. Our results subsume and generalize Call-By-Name and Call-By-Value through their translations into Bang, offering a single framework that uniformly captures infinitary and resource-sensitive semantics across evaluation strategies."}
{"id": "2601.04886", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2601.04886", "abs": "https://arxiv.org/abs/2601.04886", "authors": ["Jingzhi Gong", "Giovanni Pinna", "Yixin Bian", "Jie M. Zhang"], "title": "Analyzing Message-Code Inconsistency in AI Coding Agent-Authored Pull Requests", "comment": null, "summary": "Pull request (PR) descriptions generated by AI coding agents are the primary channel for communicating code changes to human reviewers. However, the alignment between these messages and the actual changes remains unexplored, raising concerns about the trustworthiness of AI agents. To fill this gap, we analyzed 23,247 agentic PRs across five agents using PR message-code inconsistency (PR-MCI). We contributed 974 manually annotated PRs, found 406 PRs (1.7%) exhibited high PR-MCI, and identified eight PR-MCI types, revealing that descriptions claiming unimplemented changes was the most common issue (45.4%). Statistical tests confirmed that high-MCI PRs had 51.7% lower acceptance rates (28.3% vs. 80.0%) and took 3.5x longer to merge (55.8 vs. 16.0 hours). Our findings suggest that unreliable PR descriptions undermine trust in AI agents, highlighting the need for PR-MCI verification mechanisms and improved PR generation to enable trustworthy human-AI collaboration."}
{"id": "2601.05247", "categories": ["cs.LO"], "pdf": "https://arxiv.org/pdf/2601.05247", "abs": "https://arxiv.org/abs/2601.05247", "authors": ["Oskar Fiuk"], "title": "Random Models and Guarded Logic", "comment": "This is the full version of a paper that appears in the Proceedings of STACS 2026", "summary": "Building on ideas of Gurevich and Shelah for the Gödel Class, we present a new probabilistic proof of the finite model property for the Guarded Fragment of First-Order Logic. Our proof is conceptually simple and yields the optimal doubly-exponential upper bound on the size of minimal models. We precisely analyse the obtained bound, up to constant factors in the exponents, and construct sentences that enforce models of tightly matching size. The probabilistic approach adapts naturally to the Triguarded Fragment, an extension of the Guarded Fragment that also subsumes the Two-Variable Fragment. Finally, we derandomise the probabilistic proof by providing an explicit model construction which replaces randomness with deterministic hash functions."}
{"id": "2601.04922", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2601.04922", "abs": "https://arxiv.org/abs/2601.04922", "authors": ["Théo Boivin", "Joeffrey Legaux"], "title": "AVX / NEON Intrinsic Functions: When Should They Be Used?", "comment": null, "summary": "A cross-configuration benchmark is proposed to explore the capacities and limitations of AVX / NEON intrinsic functions in a generic context of development project, when a vectorisation strategy is required to optimise the code. The main aim is to guide developers to choose when using intrinsic functions, depending on the OS, architecture and/or available compiler. Intrinsic functions were observed highly efficient in conditional branching, with intrinsic version execution time reaching around 5% of plain code execution time. However, intrinsic functions were observed as unnecessary in many cases, as the compilers already well auto-vectorise the code."}

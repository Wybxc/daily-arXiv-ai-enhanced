<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 2]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Refactoring and Equivalence in Rust: Expanding the REM Toolchain with a Novel Approach to Automated Equivalence Proofs](https://arxiv.org/abs/2601.19207)
*Matthew Britton,Sasha Pak,Alex Potanin*

Main category: cs.PL

TL;DR: REM2.0是基于rust-analyzer的Rust提取函数重构工具链，提供低延迟重构、自动修复借用检查器问题，并可选生成Coq等价性证明


<details>
  <summary>Details</summary>
Motivation: Rust的所有权、借用和高级类型特性使得自动化提取函数重构具有挑战性，现有工具要么依赖缓慢的编译器分析，要么仅支持受限语言片段，或仅提供"仍能编译"的有限保证

Method: 基于rust-analyzer构建持久守护进程，提供低延迟重构；添加自动修复器调整生命周期和签名以解决借用检查器问题；可选验证管道连接CHARON和AENEAS为支持的Rust子集生成Coq等价性证明

Result: 在三个基准测试套件上评估：1) 原始REM工件上实现100%兼容性，延迟从~1000ms降至个位数毫秒；2) 20个高星GitHub仓库的40个特性提取中，处理了涉及async/await、const fn、非局部控制流、泛型和高阶trait边界的大多数示例；3) 20个验证基准上，CHARON/AENEAS管道为当前子集内的案例构建了端到端等价性证明

Conclusion: 基于rust-analyzer的设计能够为真实Rust程序提供快速、功能丰富的提取函数重构，同时可选验证提供机器检查的行为保持保证

Abstract: Refactoring tools are central to modern development, with extract-function refactorings used heavily in day-to-day work. For Rust, however, ownership, borrowing, and advanced type features make automated extract-function refactoring challenging. Existing tools either rely on slow compiler-based analysis, support only restricted language fragments, or provide little assurance beyond "it still compiles." This paper presents REM2.0, a new extract-function and verification toolchain for Rust. REM2.0 works atop rust-analyzer as a persistent daemon, providing low-latency refactorings with a VSCode front-end. It adds a repairer that automatically adjusts lifetimes and signatures when extraction exposes borrow-checker issues, and an optional verification pipeline connecting to CHARON and AENEAS to generate Coq equivalence proofs for a supported Rust subset. The architecture is evaluated on three benchmark suites. On the original REM artefact, REM2.0 achieves 100% compatibility while reducing latency from ~1000ms to single-digit milliseconds in the daemon. On 40 feature-focused extractions from 20 highly starred GitHub repositories, REM2.0 handles most examples involving async/await, const fn, non-local control flow, generics, and higher-ranked trait bounds. On twenty verification benchmarks, the CHARON/AENEAS pipeline constructs end-to-end equivalence proofs for cases within its current subset. Overall, results show that a rust-analyzer-based design can provide fast, feature-rich extract-function refactoring for real Rust programs, while opt-in verification delivers machine-checked behaviour preservation.

</details>


### [2] [For Generalised Algebraic Theories, Two Sorts Are Enough](https://arxiv.org/abs/2601.19426)
*Samy Avrillon,Ambrus Kaposi,Ambroise Lafont,Niyousha Najmaei,Johann Rosain*

Main category: cs.PL

TL;DR: 该论文提出了一种将任意广义代数理论(GAT)简化为仅有两个类别的GAT的方法，并建立了原理论与简化理论模型之间的严格余反射对应关系。


<details>
  <summary>Details</summary>
Motivation: 广义代数理论(GATs)允许类别相互索引，如范畴论有两个类别（对象和态射），Martin-Löf类型论有四个类别（上下文、替换、类型和项）。然而，某些类型论元理论（如Cubical Agda）不支持具有类别等式或交错构造子的商归纳-归纳类型(QIITs)。因此需要一种方法将复杂的GAT简化为更简单的形式，以便在现有框架中实现。

Method: 采用语义方法，不依赖GAT的语法描述，而是基于Uemura在具有选定可指数态射的有限完备范畴的2-范畴中对（有限）GAT范畴的双初始刻画。通过构造一个严格余反射，将任意GAT简化为仅有两个类别的GAT，消除了类别等式和交错类别与操作的问题。

Result: 证明了任何GAT都可以简化为仅有两个类别的GAT，并且在原理论与简化GAT的模型之间存在严格的余反射对应关系。简化后的GAT具有以下优点：没有类别等式；没有交错类别和操作；如果原GAT没有交错类别和操作，则简化GAT也不会有不同类别间的交错操作。

Conclusion: 该简化方法为在Cubical Agda等不支持类别等式或交错构造子的类型论元理论中实现商归纳-归纳类型(QIITs)提供了一种途径。该方法的一个特例是将互归纳类型简化为单个索引族的经典方法。语义方法确保了理论的普适性和严谨性。

Abstract: Generalised algebraic theories (GATs) allow multiple sorts indexed over each other. For example, the theories of categories or Martin-L{ö}f type theories form GATs. Categories have two sorts, objects and morphisms, and the latter are double-indexed over the former. Martin-L{ö}f type theory has four sorts: contexts, substitutions, types and terms. For example, types are indexed over contexts, and terms are indexed over both contexts and types. In this paper we show that any GAT can be reduced to a GAT with only two sorts, and there is a section-retraction correspondence (formally, a strict coreflection) between models of the original and the reduced GAT. In particular, any model of the original GAT can be turned into a model of the reduced (two-sorted) GAT and back, and this roundtrip is the identity.
  The reduced GAT is simpler than the original GAT in the following aspects: it does not have sort equalities; it does not have interleaved sorts and operations; if the original GAT did not have interleaved sorts and operations, then the reduced GAT won't have operations interleaved between different sorts. In a type-theoretic metatheory, the initial algebra of a GAT is called a quotient inductive-inductive type (QIIT). Our reduction provides a way to implement QIITs with sort equalities or interleaved constructors which are not allowed by Cubical Agda. An instance of our reduction is the well-known method of reducing mutual inductive types to a single indexed family. Our approach is semantic in that it does not rely on a syntactic description of GATs, but instead, on Uemura's bi-initial characterisation of the category of (finite) GATs in the 2-category of finitely complete categories with a chosen exponentiable morphism.

</details>

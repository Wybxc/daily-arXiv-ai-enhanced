{"id": "2510.16398", "categories": ["cs.LO"], "pdf": "https://arxiv.org/pdf/2510.16398", "abs": "https://arxiv.org/abs/2510.16398", "authors": ["Nick Bezhanishvili", "Balder ten Cate", "Rosalie Iemhoff"], "title": "Six Proofs of Interpolation for the Modal Logic K", "comment": "The article will appear in Balder ten Cate, Jean Christoph Jung,\n  Patrick Koopmann, Christoph Wernhard and Frank Wolter, editors. Theory and\n  Applications of Craig Interpolation. Ubiquity Press, 2026", "summary": "In this chapter, we present six different proofs of Craig interpolation for\nthe modal logic K, each using a different set of techniques (model-theoretic,\nproof-theoretic, syntactic, automata-theoretic, using quasi-models, and\nalgebraic). We compare the pros and cons of each proof technique.", "AI": {"tldr": "\u672c\u6587\u63d0\u4f9b\u4e86\u6a21\u6001\u903b\u8f91K\u7684Craig\u63d2\u503c\u5b9a\u7406\u7684\u516d\u79cd\u4e0d\u540c\u8bc1\u660e\u65b9\u6cd5\uff0c\u5206\u522b\u57fa\u4e8e\u6a21\u578b\u8bba\u3001\u8bc1\u660e\u8bba\u3001\u53e5\u6cd5\u3001\u81ea\u52a8\u673a\u7406\u8bba\u3001\u51c6\u6a21\u578b\u548c\u4ee3\u6570\u65b9\u6cd5\uff0c\u5e76\u6bd4\u8f83\u4e86\u5404\u79cd\u8bc1\u660e\u6280\u672f\u7684\u4f18\u7f3a\u70b9\u3002", "motivation": "\u7814\u7a76\u6a21\u6001\u903b\u8f91K\u7684Craig\u63d2\u503c\u5b9a\u7406\u7684\u591a\u79cd\u8bc1\u660e\u65b9\u6cd5\uff0c\u65e8\u5728\u5c55\u793a\u4e0d\u540c\u6570\u5b66\u5de5\u5177\u5728\u8bc1\u660e\u540c\u4e00\u91cd\u8981\u903b\u8f91\u5b9a\u7406\u65f6\u7684\u5e94\u7528\u548c\u6bd4\u8f83\u3002", "method": "\u4f7f\u7528\u516d\u79cd\u4e0d\u540c\u7684\u8bc1\u660e\u6280\u672f\uff1a\u6a21\u578b\u8bba\u65b9\u6cd5\u3001\u8bc1\u660e\u8bba\u65b9\u6cd5\u3001\u53e5\u6cd5\u65b9\u6cd5\u3001\u81ea\u52a8\u673a\u7406\u8bba\u65b9\u6cd5\u3001\u51c6\u6a21\u578b\u65b9\u6cd5\u548c\u4ee3\u6570\u65b9\u6cd5\u3002", "result": "\u6210\u529f\u5730\u4e3a\u6a21\u6001\u903b\u8f91K\u7684Craig\u63d2\u503c\u5b9a\u7406\u63d0\u4f9b\u4e86\u516d\u79cd\u4e0d\u540c\u7684\u5b8c\u6574\u8bc1\u660e\u3002", "conclusion": "\u4e0d\u540c\u8bc1\u660e\u6280\u672f\u5404\u6709\u4f18\u7f3a\u70b9\uff0c\u5c55\u793a\u4e86\u6570\u5b66\u5de5\u5177\u591a\u6837\u6027\u5728\u903b\u8f91\u5b9a\u7406\u8bc1\u660e\u4e2d\u7684\u4ef7\u503c\uff0c\u4e3a\u7406\u89e3Craig\u63d2\u503c\u5b9a\u7406\u63d0\u4f9b\u4e86\u591a\u89d2\u5ea6\u89c6\u89d2\u3002"}}
{"id": "2510.16402", "categories": ["cs.LO"], "pdf": "https://arxiv.org/pdf/2510.16402", "abs": "https://arxiv.org/abs/2510.16402", "authors": ["Bernd Finkbeiner", "Julian Siber"], "title": "Explainability Requirements as Hyperproperties", "comment": null, "summary": "Explainability is emerging as a key requirement for autonomous systems. While\nmany works have focused on what constitutes a valid explanation, few have\nconsidered formalizing explainability as a system property. In this work, we\napproach this problem from the perspective of hyperproperties. We start with a\ncombination of three prominent flavors of modal logic and show how they can be\nused for specifying and verifying counterfactual explainability in multi-agent\nsystems: With Lewis' counterfactuals, linear-time temporal logic, and a\nknowledge modality, we can reason about whether agents know why a specific\nobservation occurs, i.e., whether that observation is explainable to them. We\nuse this logic to formalize multiple notions of explainability on the system\nlevel. We then show how this logic can be embedded into a hyperlogic. Notably,\nfrom this analysis we conclude that the model-checking problem of our logic is\ndecidable, which paves the way for the automated verification of explainability\nrequirements.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u57fa\u4e8e\u8d85\u5c5e\u6027\u7684\u5f62\u5f0f\u5316\u65b9\u6cd5\u6765\u9a8c\u8bc1\u591a\u667a\u80fd\u4f53\u7cfb\u7edf\u4e2d\u7684\u53cd\u4e8b\u5b9e\u53ef\u89e3\u91ca\u6027\uff0c\u7ed3\u5408\u4e86\u4e09\u79cd\u6a21\u6001\u903b\u8f91\u5e76\u8bc1\u660e\u4e86\u5176\u6a21\u578b\u68c0\u6d4b\u95ee\u9898\u7684\u53ef\u5224\u5b9a\u6027\u3002", "motivation": "\u53ef\u89e3\u91ca\u6027\u6b63\u6210\u4e3a\u81ea\u4e3b\u7cfb\u7edf\u7684\u5173\u952e\u9700\u6c42\uff0c\u4f46\u76ee\u524d\u5f88\u5c11\u6709\u5de5\u4f5c\u5c06\u53ef\u89e3\u91ca\u6027\u5f62\u5f0f\u5316\u4e3a\u7cfb\u7edf\u5c5e\u6027\uff0c\u672c\u6587\u65e8\u5728\u586b\u8865\u8fd9\u4e00\u7a7a\u767d\u3002", "method": "\u7ed3\u5408Lewis\u53cd\u4e8b\u5b9e\u903b\u8f91\u3001\u7ebf\u6027\u65f6\u5e8f\u903b\u8f91\u548c\u77e5\u8bc6\u6a21\u6001\u903b\u8f91\uff0c\u6784\u5efa\u4e86\u4e00\u79cd\u7528\u4e8e\u6307\u5b9a\u548c\u9a8c\u8bc1\u591a\u667a\u80fd\u4f53\u7cfb\u7edf\u53cd\u4e8b\u5b9e\u53ef\u89e3\u91ca\u6027\u7684\u903b\u8f91\u6846\u67b6\uff0c\u5e76\u5c06\u5176\u5d4c\u5165\u5230\u8d85\u903b\u8f91\u4e2d\u3002", "result": "\u5f00\u53d1\u4e86\u7528\u4e8e\u5f62\u5f0f\u5316\u7cfb\u7edf\u5c42\u9762\u53ef\u89e3\u91ca\u6027\u6982\u5ff5\u7684\u65b0\u903b\u8f91\uff0c\u5e76\u8bc1\u660e\u4e86\u8be5\u903b\u8f91\u7684\u6a21\u578b\u68c0\u6d4b\u95ee\u9898\u662f\u53ef\u5224\u5b9a\u7684\u3002", "conclusion": "\u8be5\u65b9\u6cd5\u4e3a\u81ea\u52a8\u5316\u9a8c\u8bc1\u53ef\u89e3\u91ca\u6027\u9700\u6c42\u94fa\u5e73\u4e86\u9053\u8def\uff0c\u4e3a\u81ea\u4e3b\u7cfb\u7edf\u7684\u53ef\u89e3\u91ca\u6027\u63d0\u4f9b\u4e86\u5f62\u5f0f\u5316\u57fa\u7840\u3002"}}
{"id": "2510.16763", "categories": ["cs.LO", "03F03, 00A30", "F.3; F.4"], "pdf": "https://arxiv.org/pdf/2510.16763", "abs": "https://arxiv.org/abs/2510.16763", "authors": ["Victor Barroso-Nascimento", "Maria Os\u00f3rio Costa", "Elaine Pimentel"], "title": "Bilateralist base-extension semantics with incompatible proofs and refutations", "comment": null, "summary": "Logical bilateralism challenges traditional concepts of logic by treating\nassertion and denial as independent yet opposed acts. While initially devised\nto justify classical logic, its constructive variants show that both acts admit\nintuitionistic interpretations. This paper presents a bilateral system where a\nformula cannot be both provable and refutable without contradiction, offering a\nframework for modelling epistemic entities, such as mathematical proofs and\nrefutations, that exclude inconsistency.\n  The logic is formalised through a bilateral natural deduction system with\ndesirable proof-theoretic properties, including normalisation. We also\nintroduce a base-extension semantics requiring explicit constructions of proofs\nand refutations while preventing them from being established for the same\nformula. The semantics is proven sound and complete with respect to the\ncalculus. Finally, we show that our notion of refutation corresponds to David\nNelson's constructive falsity, extending rather than revising intuitionistic\nlogic and reinforcing the system's suitability for representing constructive\nepistemic reasoning.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u4e2a\u53cc\u8fb9\u903b\u8f91\u7cfb\u7edf\uff0c\u5176\u4e2d\u516c\u5f0f\u4e0d\u80fd\u540c\u65f6\u53ef\u8bc1\u660e\u548c\u53ef\u53cd\u9a73\uff0c\u4e3a\u5efa\u6a21\u6392\u9664\u4e0d\u4e00\u81f4\u6027\u7684\u8ba4\u77e5\u5b9e\u4f53\uff08\u5982\u6570\u5b66\u8bc1\u660e\u548c\u53cd\u9a73\uff09\u63d0\u4f9b\u4e86\u6846\u67b6\u3002", "motivation": "\u6311\u6218\u4f20\u7edf\u903b\u8f91\u6982\u5ff5\uff0c\u5c06\u65ad\u8a00\u548c\u5426\u8ba4\u89c6\u4e3a\u72ec\u7acb\u4f46\u5bf9\u7acb\u7684\u884c\u4e3a\uff0c\u65e8\u5728\u4e3a\u7ecf\u5178\u903b\u8f91\u63d0\u4f9b\u6b63\u5f53\u6027\uff0c\u540c\u65f6\u5c55\u793a\u4e24\u79cd\u884c\u4e3a\u90fd\u5141\u8bb8\u76f4\u89c9\u4e3b\u4e49\u89e3\u91ca\u3002", "method": "\u901a\u8fc7\u5177\u6709\u826f\u597d\u8bc1\u660e\u8bba\u6027\u8d28\uff08\u5305\u62ec\u6b63\u89c4\u5316\uff09\u7684\u53cc\u8fb9\u81ea\u7136\u6f14\u7ece\u7cfb\u7edf\u5f62\u5f0f\u5316\u903b\u8f91\uff0c\u5e76\u5f15\u5165\u57fa\u6269\u5c55\u8bed\u4e49\uff0c\u8981\u6c42\u660e\u786e\u6784\u9020\u8bc1\u660e\u548c\u53cd\u9a73\uff0c\u540c\u65f6\u9632\u6b62\u5b83\u4eec\u5bf9\u540c\u4e00\u516c\u5f0f\u6210\u7acb\u3002", "result": "\u8bc1\u660e\u4e86\u8bed\u4e49\u76f8\u5bf9\u4e8e\u6f14\u7b97\u7684\u5065\u5168\u6027\u548c\u5b8c\u5907\u6027\uff0c\u5e76\u8868\u660e\u53cd\u9a73\u6982\u5ff5\u5bf9\u5e94\u4e8eDavid Nelson\u7684\u6784\u9020\u6027\u865a\u5047\uff0c\u6269\u5c55\u800c\u975e\u4fee\u6b63\u76f4\u89c9\u4e3b\u4e49\u903b\u8f91\u3002", "conclusion": "\u8be5\u7cfb\u7edf\u5f3a\u5316\u4e86\u8868\u793a\u6784\u9020\u6027\u8ba4\u77e5\u63a8\u7406\u7684\u9002\u7528\u6027\uff0c\u4e3a\u5efa\u6a21\u6570\u5b66\u8bc1\u660e\u548c\u53cd\u9a73\u7b49\u8ba4\u77e5\u5b9e\u4f53\u63d0\u4f9b\u4e86\u5408\u9002\u7684\u6846\u67b6\u3002"}}
{"id": "2510.17306", "categories": ["cs.LO", "cs.MA"], "pdf": "https://arxiv.org/pdf/2510.17306", "abs": "https://arxiv.org/abs/2510.17306", "authors": ["Sofia Garcia de Blas Garcia-Alcalde", "Francesco Belardinelli"], "title": "ATL*AS: An Automata-Theoretic Approach and Tool for the Verification of Strategic Abilities in Multi-Agent Systems", "comment": null, "summary": "We present two novel symbolic algorithms for model checking the\nAlternating-time Temporal Logic ATL*, over both the infinite-trace and the\nfinite-trace semantics. In particular, for infinite traces we design a novel\nsymbolic reduction to parity games. We implement both methods in the ATL*AS\nmodel checker and evaluate it using synthetic benchmarks as well as a\ncybersecurity scenario. Our results demonstrate that the symbolic approach\nsignificantly outperforms the explicit-state representation and we find that\nour parity-game-based algorithm offers a more scalable and efficient solution\nfor infinite-trace verification, outperforming previously available tools. Our\nresults also confirm that finite-trace model checking yields substantial\nperformance benefits over infinite-trace verification. As such, we provide a\ncomprehensive toolset for verifying multiagent systems against specifications\nin ATL*.", "AI": {"tldr": "\u63d0\u51fa\u4e86\u4e24\u79cd\u65b0\u7684\u7b26\u53f7\u7b97\u6cd5\u7528\u4e8e\u6a21\u578b\u68c0\u67e5ATL*\u903b\u8f91\uff0c\u5305\u62ec\u65e0\u9650\u8ff9\u548c\u6709\u9650\u8ff9\u8bed\u4e49\u3002\u901a\u8fc7\u7b26\u53f7\u5316\u65b9\u6cd5\u663e\u8457\u4f18\u4e8e\u663e\u5f0f\u72b6\u6001\u8868\u793a\uff0c\u5176\u4e2d\u57fa\u4e8e\u5947\u5076\u535a\u5f08\u7684\u7b97\u6cd5\u5728\u65e0\u9650\u8ff9\u9a8c\u8bc1\u4e2d\u8868\u73b0\u66f4\u4f73\u3002", "motivation": "\u4e3a\u591a\u667a\u80fd\u4f53\u7cfb\u7edf\u63d0\u4f9b\u5168\u9762\u7684ATL*\u89c4\u8303\u9a8c\u8bc1\u5de5\u5177\u96c6\uff0c\u89e3\u51b3\u73b0\u6709\u5de5\u5177\u5728\u53ef\u6269\u5c55\u6027\u548c\u6548\u7387\u65b9\u9762\u7684\u4e0d\u8db3\u3002", "method": "\u8bbe\u8ba1\u4e86\u7b26\u53f7\u5316\u65b9\u6cd5\uff0c\u5305\u62ec\u57fa\u4e8e\u5947\u5076\u535a\u5f08\u7684\u65e0\u9650\u8ff9\u9a8c\u8bc1\u7b97\u6cd5\u548c\u6709\u9650\u8ff9\u9a8c\u8bc1\u65b9\u6cd5\uff0c\u5e76\u5728ATL*AS\u6a21\u578b\u68c0\u67e5\u5668\u4e2d\u5b9e\u73b0\u3002", "result": "\u7b26\u53f7\u5316\u65b9\u6cd5\u663e\u8457\u4f18\u4e8e\u663e\u5f0f\u72b6\u6001\u8868\u793a\uff0c\u57fa\u4e8e\u5947\u5076\u535a\u5f08\u7684\u7b97\u6cd5\u5728\u65e0\u9650\u8ff9\u9a8c\u8bc1\u4e2d\u66f4\u9ad8\u6548\u53ef\u6269\u5c55\uff0c\u6709\u9650\u8ff9\u6a21\u578b\u68c0\u67e5\u6bd4\u65e0\u9650\u8ff9\u9a8c\u8bc1\u6027\u80fd\u66f4\u597d\u3002", "conclusion": "\u63d0\u4f9b\u4e86\u5168\u9762\u7684ATL*\u9a8c\u8bc1\u5de5\u5177\u96c6\uff0c\u7b26\u53f7\u5316\u65b9\u6cd5\u7279\u522b\u662f\u57fa\u4e8e\u5947\u5076\u535a\u5f08\u7684\u7b97\u6cd5\u4e3a\u591a\u667a\u80fd\u4f53\u7cfb\u7edf\u9a8c\u8bc1\u63d0\u4f9b\u4e86\u9ad8\u6548\u89e3\u51b3\u65b9\u6848\u3002"}}
{"id": "2510.17386", "categories": ["cs.FL", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.17386", "abs": "https://arxiv.org/abs/2510.17386", "authors": ["Elaheh Hosseinkhani", "Martin Leucker"], "title": "Inference of Deterministic Finite Automata via Q-Learning", "comment": null, "summary": "Traditional approaches to inference of deterministic finite-state automata\n(DFA) stem from symbolic AI, including both active learning methods (e.g.,\nAngluin's L* algorithm and its variants) and passive techniques (e.g., Biermann\nand Feldman's method, RPNI). Meanwhile, sub-symbolic AI, particularly machine\nlearning, offers alternative paradigms for learning from data, such as\nsupervised, unsupervised, and reinforcement learning (RL). This paper\ninvestigates the use of Q-learning, a well-known reinforcement learning\nalgorithm, for the passive inference of deterministic finite automata. It\nbuilds on the core insight that the learned Q-function, which maps state-action\npairs to rewards, can be reinterpreted as the transition function of a DFA over\na finite domain. This provides a novel bridge between sub-symbolic learning and\nsymbolic representations. The paper demonstrates how Q-learning can be adapted\nfor automaton inference and provides an evaluation on several examples.", "AI": {"tldr": "\u4f7f\u7528Q\u5b66\u4e60\u7b97\u6cd5\u8fdb\u884c\u786e\u5b9a\u6027\u6709\u9650\u81ea\u52a8\u673a(DFA)\u7684\u88ab\u52a8\u63a8\u65ad\uff0c\u5c06Q\u51fd\u6570\u91cd\u65b0\u89e3\u91ca\u4e3aDFA\u7684\u8f6c\u79fb\u51fd\u6570\uff0c\u5728\u5b50\u7b26\u53f7\u5b66\u4e60\u548c\u7b26\u53f7\u8868\u793a\u4e4b\u95f4\u5efa\u7acb\u6865\u6881\u3002", "motivation": "\u4f20\u7edfDFA\u63a8\u65ad\u65b9\u6cd5\u57fa\u4e8e\u7b26\u53f7AI\uff0c\u800c\u5b50\u7b26\u53f7AI\uff08\u7279\u522b\u662f\u673a\u5668\u5b66\u4e60\uff09\u63d0\u4f9b\u4e86\u4ece\u6570\u636e\u4e2d\u5b66\u4e60\u7684\u66ff\u4ee3\u8303\u5f0f\u3002\u672c\u6587\u63a2\u7d22\u4f7f\u7528\u5f3a\u5316\u5b66\u4e60\u4e2d\u7684Q\u5b66\u4e60\u7b97\u6cd5\u8fdb\u884cDFA\u88ab\u52a8\u63a8\u65ad\u7684\u53ef\u80fd\u6027\u3002", "method": "\u5c06Q\u5b66\u4e60\u7b97\u6cd5\u5e94\u7528\u4e8e\u81ea\u52a8\u673a\u63a8\u65ad\uff0c\u6838\u5fc3\u6d1e\u5bdf\u662f\u5c06\u5b66\u4e60\u5230\u7684Q\u51fd\u6570\uff08\u6620\u5c04\u72b6\u6001-\u52a8\u4f5c\u5bf9\u5230\u5956\u52b1\uff09\u91cd\u65b0\u89e3\u91ca\u4e3a\u6709\u9650\u57df\u4e0aDFA\u7684\u8f6c\u79fb\u51fd\u6570\u3002", "result": "\u5728\u591a\u4e2a\u793a\u4f8b\u4e0a\u8fdb\u884c\u4e86\u8bc4\u4f30\uff0c\u5c55\u793a\u4e86Q\u5b66\u4e60\u5982\u4f55\u9002\u5e94\u81ea\u52a8\u673a\u63a8\u65ad\u4efb\u52a1\u3002", "conclusion": "Q\u5b66\u4e60\u4e3aDFA\u88ab\u52a8\u63a8\u65ad\u63d0\u4f9b\u4e86\u4e00\u79cd\u65b0\u9896\u7684\u65b9\u6cd5\uff0c\u5728\u5b50\u7b26\u53f7\u5b66\u4e60\u548c\u7b26\u53f7\u8868\u793a\u4e4b\u95f4\u5efa\u7acb\u4e86\u6865\u6881\u3002"}}
{"id": "2510.16059", "categories": ["cs.SE", "cs.CL", "D.2.2; D.2.3"], "pdf": "https://arxiv.org/pdf/2510.16059", "abs": "https://arxiv.org/abs/2510.16059", "authors": ["Xin Cao", "Nan Yu"], "title": "SIADAFIX: issue description response for adaptive program repair", "comment": "20 pages, 3 figures", "summary": "We propose utilizing fast and slow thinking to enhance the capabilities of\nlarge language model-based agents on complex tasks such as program repair. In\nparticular, we design an adaptive program repair method based on issue\ndescription response, called SIADAFIX. The proposed method utilizes slow\nthinking bug fix agent to complete complex program repair tasks, and employs\nfast thinking workflow decision components to optimize and classify issue\ndescriptions, using issue description response results to guide the\norchestration of bug fix agent workflows. SIADAFIX adaptively selects three\nrepair modes, i.e., easy, middle and hard mode, based on problem complexity. It\nemploys fast generalization for simple problems and test-time scaling\ntechniques for complex problems. Experimental results on the SWE-bench Lite\nshow that the proposed method achieves 60.67% pass@1 performance using the\nClaude-4 Sonnet model, reaching state-of-the-art levels among all open-source\nmethods. SIADAFIX effectively balances repair efficiency and accuracy,\nproviding new insights for automated program repair. Our code is available at\nhttps://github.com/liauto-siada/siada-cli.", "AI": {"tldr": "\u63d0\u51faSIADAFIX\u65b9\u6cd5\uff0c\u5229\u7528\u5feb\u6162\u601d\u7ef4\u589e\u5f3a\u5927\u8bed\u8a00\u6a21\u578b\u5728\u7a0b\u5e8f\u4fee\u590d\u4efb\u52a1\u4e2d\u7684\u80fd\u529b\uff0c\u901a\u8fc7\u95ee\u9898\u63cf\u8ff0\u54cd\u5e94\u81ea\u9002\u5e94\u9009\u62e9\u4e09\u79cd\u4fee\u590d\u6a21\u5f0f\uff0c\u5728SWE-bench Lite\u4e0a\u8fbe\u523060.67%\u7684pass@1\u6027\u80fd\u3002", "motivation": "\u5229\u7528\u5feb\u6162\u601d\u7ef4\u6765\u589e\u5f3a\u57fa\u4e8e\u5927\u8bed\u8a00\u6a21\u578b\u7684\u667a\u80fd\u4f53\u5728\u590d\u6742\u4efb\u52a1\uff08\u5982\u7a0b\u5e8f\u4fee\u590d\uff09\u4e0a\u7684\u80fd\u529b\uff0c\u5e73\u8861\u4fee\u590d\u6548\u7387\u548c\u51c6\u786e\u6027\u3002", "method": "\u8bbe\u8ba1\u57fa\u4e8e\u95ee\u9898\u63cf\u8ff0\u54cd\u5e94\u7684\u81ea\u9002\u5e94\u7a0b\u5e8f\u4fee\u590d\u65b9\u6cd5SIADAFIX\uff0c\u4f7f\u7528\u6162\u601d\u7ef4\u9519\u8bef\u4fee\u590d\u4ee3\u7406\u5b8c\u6210\u590d\u6742\u4fee\u590d\u4efb\u52a1\uff0c\u5feb\u601d\u7ef4\u5de5\u4f5c\u6d41\u51b3\u7b56\u7ec4\u4ef6\u4f18\u5316\u548c\u5206\u7c7b\u95ee\u9898\u63cf\u8ff0\uff0c\u6839\u636e\u95ee\u9898\u590d\u6742\u5ea6\u81ea\u9002\u5e94\u9009\u62e9\u7b80\u5355\u3001\u4e2d\u7b49\u3001\u56f0\u96be\u4e09\u79cd\u4fee\u590d\u6a21\u5f0f\u3002", "result": "\u5728SWE-bench Lite\u4e0a\u7684\u5b9e\u9a8c\u7ed3\u679c\u663e\u793a\uff0c\u4f7f\u7528Claude-4 Sonnet\u6a21\u578b\u8fbe\u523060.67%\u7684pass@1\u6027\u80fd\uff0c\u5728\u6240\u6709\u5f00\u6e90\u65b9\u6cd5\u4e2d\u8fbe\u5230\u6700\u5148\u8fdb\u6c34\u5e73\u3002", "conclusion": "SIADAFIX\u6709\u6548\u5e73\u8861\u4e86\u4fee\u590d\u6548\u7387\u548c\u51c6\u786e\u6027\uff0c\u4e3a\u81ea\u52a8\u5316\u7a0b\u5e8f\u4fee\u590d\u63d0\u4f9b\u4e86\u65b0\u7684\u601d\u8def\u3002"}}
{"id": "2510.15912", "categories": ["cs.PL", "cs.AR", "cs.PF"], "pdf": "https://arxiv.org/pdf/2510.15912", "abs": "https://arxiv.org/abs/2510.15912", "authors": ["Jack Cashman"], "title": "Latency Based Tiling", "comment": null, "summary": "Latency Based Tiling provides a systems based approach to deriving\napproximate tiling solution that maximizes locality while maintaining a fast\ncompile time. The method uses triangular loops to characterize miss ratio\nscaling of a machine avoiding prefetcher distortion. Miss ratio scaling\ncaptures the relationship between data access latency and working set size with\nsharp increases in latency indicating the data footprint exceeds capacity from\na cache level. Through these noticeable increases in latency we can determine\nan approximate location for L1, L2, and L3 memory sizes. These sizes are\nexpected to be under approximations of a systems true memory sizes which is in\nline with our expectations given the shared nature of cache in a multi process\nsystem as described in defensive loop tiling. Unlike auto tuning, which can be\neffective but prohibitively slow, Latency Based Tiling achieves negligible\ncompile time overhead. The implementation in Rust enables a hardware agnostic\napproach which combined with a cache timing based techniques, yields a\nportable, memory safe system running wherever Rust is supported. The tiling\nstrategy is applied to a subset of the polyhedral model, where loop nestings\nare tiled based on both the derived memory hierarchy and the observed data\nfootprint per iteration.", "AI": {"tldr": "Latency Based Tiling\u662f\u4e00\u79cd\u7cfb\u7edf\u65b9\u6cd5\uff0c\u901a\u8fc7\u4e09\u89d2\u5faa\u73af\u5206\u6790\u673a\u5668\u7f13\u5b58\u7f3a\u5931\u7387\u7f29\u653e\u7279\u6027\uff0c\u5feb\u901f\u63a8\u5bfc\u8fd1\u4f3c\u5206\u5757\u65b9\u6848\uff0c\u5728\u4fdd\u6301\u5feb\u901f\u7f16\u8bd1\u65f6\u95f4\u7684\u540c\u65f6\u6700\u5927\u5316\u6570\u636e\u5c40\u90e8\u6027\u3002", "motivation": "\u4f20\u7edf\u81ea\u52a8\u8c03\u4f18\u65b9\u6cd5\u867d\u7136\u6709\u6548\u4f46\u7f16\u8bd1\u65f6\u95f4\u8fc7\u957f\uff0c\u9700\u8981\u4e00\u79cd\u80fd\u591f\u5feb\u901f\u786e\u5b9a\u7f13\u5b58\u5c42\u6b21\u7ed3\u6784\u5e76\u5b9e\u73b0\u9ad8\u6548\u5206\u5757\u7684\u8f7b\u91cf\u7ea7\u65b9\u6cd5\u3002", "method": "\u4f7f\u7528\u4e09\u89d2\u5faa\u73af\u5206\u6790\u7f13\u5b58\u7f3a\u5931\u7387\u7f29\u653e\uff0c\u901a\u8fc7\u5ef6\u8fdf\u7a81\u589e\u8bc6\u522bL1\u3001L2\u3001L3\u7f13\u5b58\u5927\u5c0f\uff0c\u7ed3\u5408\u591a\u9762\u4f53\u6a21\u578b\u5bf9\u5faa\u73af\u5d4c\u5957\u8fdb\u884c\u57fa\u4e8e\u5185\u5b58\u5c42\u6b21\u7ed3\u6784\u548c\u6570\u636e\u8db3\u8ff9\u7684\u5206\u5757\u3002", "result": "\u8be5\u65b9\u6cd5\u5b9e\u73b0\u4e86\u53ef\u5ffd\u7565\u7684\u7f16\u8bd1\u65f6\u95f4\u5f00\u9500\uff0c\u63d0\u4f9b\u4e86\u786c\u4ef6\u65e0\u5173\u7684\u4fbf\u643a\u5f0f\u89e3\u51b3\u65b9\u6848\uff0c\u5728Rust\u652f\u6301\u7684\u4efb\u4f55\u5e73\u53f0\u4e0a\u90fd\u80fd\u8fd0\u884c\u3002", "conclusion": "Latency Based Tiling\u63d0\u4f9b\u4e86\u4e00\u79cd\u5feb\u901f\u3001\u4fbf\u643a\u7684\u5206\u5757\u65b9\u6cd5\uff0c\u80fd\u591f\u5728\u591a\u8fdb\u7a0b\u5171\u4eab\u7f13\u5b58\u73af\u5883\u4e2d\u6709\u6548\u5de5\u4f5c\uff0c\u662f\u81ea\u52a8\u8c03\u4f18\u7684\u8f7b\u91cf\u7ea7\u66ff\u4ee3\u65b9\u6848\u3002"}}
{"id": "2510.17494", "categories": ["cs.LO"], "pdf": "https://arxiv.org/pdf/2510.17494", "abs": "https://arxiv.org/abs/2510.17494", "authors": ["Jacob Neumann"], "title": "A Judgmental Construction of Directed Type Theory", "comment": null, "summary": "We reformulate recent advances in directed type theory--a type theory where\nthe types have the structure of synthetic (higher) categories--as a logical\ncalculus with multiple context 'zones', following the example of Pfenning and\nDavies. This allows us to have two kinds of variables--'neutral' and\n'polar'--with different functoriality requirements. We focus on the\nlowest-dimension version of this theory (where types are synthetic preorders)\nand apply the logical language to articulate concepts from the theory of\nrewriting. We also take the occasion to develop the categorical semantics of\ndual-context systems, proposing a notion of dual CwF to serve as a common\nstructural base for the model theories of such logics.", "AI": {"tldr": "\u5c06\u5b9a\u5411\u7c7b\u578b\u8bba\u91cd\u65b0\u8868\u8ff0\u4e3a\u5177\u6709\u591a\u4e2a\u4e0a\u4e0b\u6587\u533a\u57df\u7684\u903b\u8f91\u6f14\u7b97\uff0c\u5f15\u5165\u4e2d\u6027\u548c\u6781\u6027\u53d8\u91cf\uff0c\u5e76\u5e94\u7528\u4e8e\u91cd\u5199\u7406\u8bba\uff0c\u540c\u65f6\u53d1\u5c55\u4e86\u5bf9\u5076\u4e0a\u4e0b\u6587\u7cfb\u7edf\u7684\u8303\u7574\u8bed\u4e49\u3002", "motivation": "\u5c06\u5b9a\u5411\u7c7b\u578b\u8bba\uff08\u7c7b\u578b\u5177\u6709\u5408\u6210\u8303\u7574\u7ed3\u6784\u7684\u7c7b\u578b\u8bba\uff09\u91cd\u65b0\u8868\u8ff0\u4e3a\u66f4\u6e05\u6670\u7684\u903b\u8f91\u6f14\u7b97\u5f62\u5f0f\uff0c\u4ee5\u4fbf\u66f4\u597d\u5730\u8868\u8fbe\u91cd\u5199\u7406\u8bba\u4e2d\u7684\u6982\u5ff5\uff0c\u5e76\u5efa\u7acb\u5bf9\u5076\u4e0a\u4e0b\u6587\u7cfb\u7edf\u7684\u8bed\u4e49\u57fa\u7840\u3002", "method": "\u4f7f\u7528\u591a\u4e0a\u4e0b\u6587\u533a\u57df\u903b\u8f91\u6f14\u7b97\uff0c\u5f15\u5165\u4e2d\u6027\u548c\u6781\u6027\u4e24\u79cd\u53d8\u91cf\u7c7b\u578b\uff0c\u6784\u5efa\u5bf9\u5076CwF\u4f5c\u4e3a\u6a21\u578b\u7406\u8bba\u57fa\u7840\uff0c\u5e76\u5e94\u7528\u4e8e\u5408\u6210\u9884\u5e8f\u7684\u4f4e\u7ef4\u7248\u672c\u7406\u8bba\u3002", "result": "\u6210\u529f\u5c06\u5b9a\u5411\u7c7b\u578b\u8bba\u91cd\u65b0\u8868\u8ff0\u4e3a\u591a\u4e0a\u4e0b\u6587\u903b\u8f91\u6f14\u7b97\uff0c\u5efa\u7acb\u4e86\u5bf9\u5076\u4e0a\u4e0b\u6587\u7cfb\u7edf\u7684\u8303\u7574\u8bed\u4e49\u6846\u67b6\uff0c\u5e76\u5c55\u793a\u4e86\u5728\u91cd\u5199\u7406\u8bba\u4e2d\u7684\u5e94\u7528\u3002", "conclusion": "\u591a\u4e0a\u4e0b\u6587\u533a\u57df\u65b9\u6cd5\u4e3a\u5b9a\u5411\u7c7b\u578b\u8bba\u63d0\u4f9b\u4e86\u66f4\u6e05\u6670\u7684\u903b\u8f91\u8868\u8ff0\uff0c\u5bf9\u5076CwF\u4e3a\u8fd9\u7c7b\u903b\u8f91\u7684\u6a21\u578b\u7406\u8bba\u63d0\u4f9b\u4e86\u7edf\u4e00\u7684\u8bed\u4e49\u57fa\u7840\uff0c\u5728\u91cd\u5199\u7406\u8bba\u4e2d\u5177\u6709\u5e94\u7528\u4ef7\u503c\u3002"}}
{"id": "2510.17438", "categories": ["cs.FL"], "pdf": "https://arxiv.org/pdf/2510.17438", "abs": "https://arxiv.org/abs/2510.17438", "authors": ["Christian Hercher"], "title": "Castor Ministerialis", "comment": null, "summary": "The famous problem of Busy Beavers can be stated as the question on how long\na $n$-state Turing machine (using a 2-symbol alphabet or -- in a generalization\n-- a $m$-symbol alphabet) can run if it is started on the blank tape before it\nholds. Thus, not halting Turing machines are excluded. For up to four states\nthe answer to this question is well-known. Recently, it could be verified that\nthe widely assumed candidate for five states is in fact the champion. And there\nis progress in searching for good candidates with six or more states.\n  We investigate a variant of this problem: Additionally to the requirement\nthat the Turing machines have to start from the blank tape we only consider\nsuch Turing machines that hold on the blank tape, too. For this variant we give\ndefinitive answers on how long such a Turing machine with up to five states can\nrun, analyze the behavior of a six-states candidate and give some findings on\nthe generalization of Turing-machines with $m$-symbol alphabet.", "AI": {"tldr": "\u8be5\u8bba\u6587\u7814\u7a76\u4e86\u4e00\u4e2aBusy Beaver\u95ee\u9898\u7684\u53d8\u4f53\uff1a\u53ea\u8003\u8651\u4ece\u7a7a\u767d\u78c1\u5e26\u5f00\u59cb\u5e76\u5728\u7a7a\u767d\u78c1\u5e26\u4e0a\u505c\u6b62\u7684\u56fe\u7075\u673a\u3002\u4f5c\u8005\u7ed9\u51fa\u4e86\u6700\u591a5\u4e2a\u72b6\u6001\u56fe\u7075\u673a\u7684\u660e\u786e\u7b54\u6848\uff0c\u5206\u6790\u4e866\u72b6\u6001\u5019\u9009\u673a\u7684\u884c\u4e3a\uff0c\u5e76\u63a2\u8ba8\u4e86\u591a\u7b26\u53f7\u5b57\u6bcd\u8868\u7684\u63a8\u5e7f\u3002", "motivation": "\u7814\u7a76Busy Beaver\u95ee\u9898\u7684\u53d8\u4f53\uff0c\u9650\u5236\u56fe\u7075\u673a\u5fc5\u987b\u4ece\u7a7a\u767d\u78c1\u5e26\u5f00\u59cb\u5e76\u5728\u7a7a\u767d\u78c1\u5e26\u4e0a\u505c\u6b62\uff0c\u8fd9\u4e3a\u7406\u89e3\u56fe\u7075\u673a\u884c\u4e3a\u63d0\u4f9b\u4e86\u65b0\u7684\u89c6\u89d2\u3002", "method": "\u901a\u8fc7\u5206\u6790\u56fe\u7075\u673a\u7684\u72b6\u6001\u8f6c\u6362\u548c\u8fd0\u884c\u884c\u4e3a\uff0c\u7cfb\u7edf\u5730\u7814\u7a76\u4ece\u7a7a\u767d\u78c1\u5e26\u5f00\u59cb\u5e76\u5728\u7a7a\u767d\u78c1\u5e26\u4e0a\u505c\u6b62\u7684\u56fe\u7075\u673a\u7684\u6700\u957f\u8fd0\u884c\u65f6\u95f4\u3002", "result": "\u7ed9\u51fa\u4e86\u6700\u591a5\u4e2a\u72b6\u6001\u56fe\u7075\u673a\u7684\u660e\u786e\u6700\u957f\u8fd0\u884c\u65f6\u95f4\uff0c\u5206\u6790\u4e866\u72b6\u6001\u5019\u9009\u673a\u7684\u884c\u4e3a\uff0c\u5e76\u63d0\u4f9b\u4e86\u591a\u7b26\u53f7\u5b57\u6bcd\u8868\u63a8\u5e7f\u7684\u521d\u6b65\u53d1\u73b0\u3002", "conclusion": "\u8fd9\u79cdBusy Beaver\u95ee\u9898\u7684\u53d8\u4f53\u4e3a\u7406\u89e3\u56fe\u7075\u673a\u884c\u4e3a\u63d0\u4f9b\u4e86\u6709\u4ef7\u503c\u7684\u89c1\u89e3\uff0c\u7279\u522b\u662f\u5728\u9650\u5236\u8d77\u59cb\u548c\u505c\u6b62\u6761\u4ef6\u4e3a\u7a7a\u767d\u78c1\u5e26\u7684\u60c5\u51b5\u4e0b\u3002"}}
{"id": "2510.16242", "categories": ["cs.SE", "cs.DL"], "pdf": "https://arxiv.org/pdf/2510.16242", "abs": "https://arxiv.org/abs/2510.16242", "authors": ["Eva Maxfield Brown", "Isaac Slaughter", "Nicholas Weber"], "title": "Code Contribution and Credit in Science", "comment": null, "summary": "Software development has become essential to scientific research, but its\nrelationship to traditional metrics of scholarly credit remains poorly\nunderstood. We develop a dataset of approximately 140,000 paired research\narticles and code repositories, as well as a predictive model that matches\nresearch article authors with software repository developer accounts. We use\nthis data to investigate how software development activities influence credit\nallocation in collaborative scientific settings. Our findings reveal\nsignificant patterns distinguishing software contributions from traditional\nauthorship credit. We find that nearly 30% of articles include non-author code\ncontributors- individuals who participated in software development but received\nno formal authorship recognition. While code-contributing authors show a modest\n$\\sim$4.2% increase in article citations, this effect becomes non-significant\nwhen controlling for domain, article type, and open access status. First\nauthors are significantly more likely to be code contributors than other author\npositions. Notably, we identify a negative relationship between coding\nfrequency and scholarly impact metrics. Authors who contribute code more\nfrequently exhibit progressively lower h-indices than non-coding colleagues,\neven when controlling for publication count, author position, domain, and\narticle type. These results suggest a disconnect between software contributions\nand credit, highlighting important implications for institutional reward\nstructures and science policy.", "AI": {"tldr": "\u7814\u7a76\u53d1\u73b0\u79d1\u5b66\u8f6f\u4ef6\u5f00\u53d1\u4e0e\u5b66\u672f\u8ba4\u53ef\u4e4b\u95f4\u5b58\u5728\u8131\u8282\uff1a\u8fd130%\u8bba\u6587\u6709\u4ee3\u7801\u8d21\u732e\u8005\u672a\u83b7\u7f72\u540d\uff0c\u9891\u7e41\u7f16\u7801\u7684\u4f5c\u8005h\u6307\u6570\u66f4\u4f4e\uff0c\u8f6f\u4ef6\u8d21\u732e\u672a\u5728\u4f20\u7edf\u5b66\u672f\u8bc4\u4ef7\u4f53\u7cfb\u4e2d\u5f97\u5230\u5145\u5206\u8ba4\u53ef\u3002", "motivation": "\u63a2\u7a76\u8f6f\u4ef6\u5f00\u53d1\u6d3b\u52a8\u5728\u79d1\u5b66\u5408\u4f5c\u4e2d\u5982\u4f55\u5f71\u54cd\u5b66\u672f\u8ba4\u53ef\u5206\u914d\uff0c\u7406\u89e3\u8f6f\u4ef6\u8d21\u732e\u4e0e\u4f20\u7edf\u5b66\u672f\u8bc4\u4ef7\u6307\u6807\u4e4b\u95f4\u7684\u5173\u7cfb\u3002", "method": "\u6784\u5efa\u5305\u542b14\u4e07\u7bc7\u7814\u7a76\u8bba\u6587\u4e0e\u4ee3\u7801\u4ed3\u5e93\u914d\u5bf9\u7684\u6570\u636e\u96c6\uff0c\u5f00\u53d1\u9884\u6d4b\u6a21\u578b\u5339\u914d\u8bba\u6587\u4f5c\u8005\u4e0e\u4ee3\u7801\u4ed3\u5e93\u5f00\u53d1\u8005\u8d26\u6237\uff0c\u5206\u6790\u8f6f\u4ef6\u8d21\u732e\u4e0e\u5b66\u672f\u8ba4\u53ef\u7684\u5173\u7cfb\u3002", "result": "30%\u8bba\u6587\u6709\u975e\u4f5c\u8005\u4ee3\u7801\u8d21\u732e\u8005\uff1b\u4ee3\u7801\u8d21\u732e\u4f5c\u8005\u5f15\u7528\u7387\u4ec5\u589e\u52a04.2%\uff1b\u7b2c\u4e00\u4f5c\u8005\u66f4\u53ef\u80fd\u662f\u4ee3\u7801\u8d21\u732e\u8005\uff1b\u7f16\u7801\u9891\u7387\u4e0eh\u6307\u6570\u5448\u8d1f\u76f8\u5173\u3002", "conclusion": "\u8f6f\u4ef6\u8d21\u732e\u4e0e\u5b66\u672f\u8ba4\u53ef\u4e4b\u95f4\u5b58\u5728\u8131\u8282\uff0c\u8fd9\u5bf9\u673a\u6784\u5956\u52b1\u673a\u5236\u548c\u79d1\u5b66\u653f\u7b56\u5177\u6709\u91cd\u8981\u542f\u793a\u610f\u4e49\u3002"}}
{"id": "2510.16133", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2510.16133", "abs": "https://arxiv.org/abs/2510.16133", "authors": ["Daniel Sainati", "Joseph W. Cutler", "Benjamin C. Pierce", "Stephanie Weirich"], "title": "Typing Strictness (Extended Version)", "comment": "30 pages, 22 figures, extended version of a paper to be published at\n  POPL 2026", "summary": "Strictness analysis is critical to efficient implementation of languages with\nnon-strict evaluation, mitigating much of the performance overhead of laziness.\nHowever, reasoning about strictness at the source level can be challenging and\nunintuitive. We propose a new definition of strictness that refines the\ntraditional one by describing variable usage more precisely. We lay\ntype-theoretic foundations for this definition in both call-by-name and\ncall-by-push-value settings, drawing inspiration from the literature on type\nsystems tracking effects and coeffects. We prove via a logical relation that\nthe strictness attributes computed by our type systems accurately describe the\nuse of variables at runtime, and we offer a strictness-annotation-preserving\ntranslation from the call-by-name system to the call-by-push-value one. All our\nresults are mechanized in Rocq.", "AI": {"tldr": "\u63d0\u51fa\u4e86\u4e00\u79cd\u65b0\u7684\u4e25\u683c\u6027\u5b9a\u4e49\uff0c\u901a\u8fc7\u66f4\u7cbe\u786e\u63cf\u8ff0\u53d8\u91cf\u4f7f\u7528\u6765\u6539\u8fdb\u4f20\u7edf\u5b9a\u4e49\uff0c\u5728\u6309\u540d\u8c03\u7528\u548c\u6309\u503c\u63a8\u9001\u8c03\u7528\u8bbe\u7f6e\u4e2d\u5efa\u7acb\u4e86\u7c7b\u578b\u7406\u8bba\u57fa\u7840\uff0c\u5e76\u901a\u8fc7\u903b\u8f91\u5173\u7cfb\u8bc1\u660e\u4e86\u4e25\u683c\u6027\u5c5e\u6027\u80fd\u51c6\u786e\u63cf\u8ff0\u8fd0\u884c\u65f6\u53d8\u91cf\u4f7f\u7528\u3002", "motivation": "\u4e25\u683c\u6027\u5206\u6790\u5bf9\u4e8e\u975e\u4e25\u683c\u6c42\u503c\u8bed\u8a00\u7684\u9ad8\u6548\u5b9e\u73b0\u81f3\u5173\u91cd\u8981\uff0c\u4f46\u6e90\u7ea7\u522b\u7684\u4e25\u683c\u6027\u63a8\u7406\u5177\u6709\u6311\u6218\u6027\u548c\u53cd\u76f4\u89c9\u6027\u3002", "method": "\u57fa\u4e8e\u8ddf\u8e2a\u6548\u679c\u548c\u5171\u6548\u679c\u7684\u7c7b\u578b\u7cfb\u7edf\u6587\u732e\uff0c\u5728\u6309\u540d\u8c03\u7528\u548c\u6309\u503c\u63a8\u9001\u8c03\u7528\u8bbe\u7f6e\u4e2d\u5efa\u7acb\u4e86\u7c7b\u578b\u7406\u8bba\u57fa\u7840\uff0c\u5e76\u901a\u8fc7\u903b\u8f91\u5173\u7cfb\u8bc1\u660e\u4e25\u683c\u6027\u5c5e\u6027\u7684\u51c6\u786e\u6027\u3002", "result": "\u5f00\u53d1\u4e86\u65b0\u7684\u4e25\u683c\u6027\u5b9a\u4e49\u548c\u7c7b\u578b\u7cfb\u7edf\uff0c\u80fd\u591f\u66f4\u7cbe\u786e\u5730\u63cf\u8ff0\u53d8\u91cf\u4f7f\u7528\uff0c\u5e76\u63d0\u4f9b\u4e86\u4e25\u683c\u6027\u6ce8\u91ca\u4fdd\u6301\u7684\u7ffb\u8bd1\u673a\u5236\u3002", "conclusion": "\u6240\u63d0\u51fa\u7684\u4e25\u683c\u6027\u5b9a\u4e49\u548c\u7c7b\u578b\u7cfb\u7edf\u4e3a\u4e25\u683c\u6027\u5206\u6790\u63d0\u4f9b\u4e86\u66f4\u7cbe\u786e\u7684\u7406\u8bba\u57fa\u7840\uff0c\u6240\u6709\u7ed3\u679c\u5df2\u5728Rocq\u4e2d\u673a\u68b0\u5316\u9a8c\u8bc1\u3002"}}
{"id": "2510.17622", "categories": ["cs.LO", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.17622", "abs": "https://arxiv.org/abs/2510.17622", "authors": ["Hongyi Duan", "Haoyang Liu", "Jian'an Zhang", "Fengrui Liu", "Yiyi Wang"], "title": "Just-In-Time Piecewise-Linear Semantics for ReLU-type Networks", "comment": null, "summary": "We present a JIT PL semantics for ReLU-type networks that compiles models\ninto a guarded CPWL transducer with shared guards. The system adds hyperplanes\nonly when operands are affine on the current cell, maintains global lower/upper\nenvelopes, and uses a budgeted branch-and-bound. We obtain anytime soundness,\nexactness on fully refined cells, monotone progress, guard-linear complexity\n(avoiding global $\\binom{k}{2}$), dominance pruning, and decidability under\nfinite refinement. The shared carrier supports region extraction, decision\ncomplexes, Jacobians, exact/certified Lipschitz, LP/SOCP robustness, and\nmaximal causal influence. A minimal prototype returns certificates or\ncounterexamples with cost proportional to visited subdomains.", "AI": {"tldr": "\u63d0\u51fa\u4e86\u4e00\u79cd\u7528\u4e8eReLU\u578b\u7f51\u7edc\u7684\u5373\u65f6\u7f16\u8bd1PL\u8bed\u4e49\uff0c\u5c06\u6a21\u578b\u7f16\u8bd1\u4e3a\u5e26\u6709\u5171\u4eab\u5b88\u536b\u7684\u5206\u6bb5\u7ebf\u6027\u8f6c\u6362\u5668\uff0c\u5b9e\u73b0\u4efb\u610f\u65f6\u95f4\u6b63\u786e\u6027\u3001\u7cbe\u786e\u6027\u548c\u5355\u8c03\u8fdb\u5c55\u3002", "motivation": "\u4e3aReLU\u578b\u795e\u7ecf\u7f51\u7edc\u63d0\u4f9b\u7cbe\u786e\u7684\u8bed\u4e49\u5206\u6790\u548c\u9a8c\u8bc1\u65b9\u6cd5\uff0c\u652f\u6301\u533a\u57df\u63d0\u53d6\u3001\u51b3\u7b56\u590d\u6742\u6027\u5206\u6790\u3001\u96c5\u53ef\u6bd4\u77e9\u9635\u8ba1\u7b97\u3001\u7cbe\u786eLipschitz\u5e38\u6570\u8ba4\u8bc1\u4ee5\u53ca\u9c81\u68d2\u6027\u9a8c\u8bc1\u7b49\u529f\u80fd\u3002", "method": "\u4f7f\u7528\u5e26\u5171\u4eab\u5b88\u536b\u7684\u5206\u6bb5\u7ebf\u6027\u8f6c\u6362\u5668\uff0c\u4ec5\u5728\u64cd\u4f5c\u6570\u5728\u5f53\u524d\u5355\u5143\u4e0a\u4e3a\u4eff\u5c04\u65f6\u6dfb\u52a0\u8d85\u5e73\u9762\uff0c\u7ef4\u62a4\u5168\u5c40\u4e0a\u4e0b\u5305\u7edc\uff0c\u91c7\u7528\u9884\u7b97\u5206\u652f\u5b9a\u754c\u6cd5\u3002", "result": "\u5b9e\u73b0\u4e86\u4efb\u610f\u65f6\u95f4\u6b63\u786e\u6027\u3001\u5b8c\u5168\u7ec6\u5316\u5355\u5143\u4e0a\u7684\u7cbe\u786e\u6027\u3001\u5355\u8c03\u8fdb\u5c55\u3001\u5b88\u536b\u7ebf\u6027\u590d\u6742\u5ea6\u3001\u4f18\u52bf\u526a\u679d\u4ee5\u53ca\u5728\u6709\u9650\u7ec6\u5316\u4e0b\u7684\u53ef\u5224\u5b9a\u6027\u3002", "conclusion": "\u8be5\u7cfb\u7edf\u4e3a\u795e\u7ecf\u7f51\u7edc\u5206\u6790\u63d0\u4f9b\u4e86\u5f3a\u5927\u7684\u5de5\u5177\uff0c\u652f\u6301\u591a\u79cd\u9a8c\u8bc1\u548c\u5206\u6790\u4efb\u52a1\uff0c\u539f\u578b\u5b9e\u73b0\u80fd\u591f\u4ee5\u4e0e\u8bbf\u95ee\u5b50\u57df\u6210\u672c\u6210\u6bd4\u4f8b\u7684\u65b9\u5f0f\u8fd4\u56de\u8bc1\u4e66\u6216\u53cd\u4f8b\u3002"}}
{"id": "2510.17582", "categories": ["cs.FL"], "pdf": "https://arxiv.org/pdf/2510.17582", "abs": "https://arxiv.org/abs/2510.17582", "authors": ["Ning Ran", "Zhengguang Wu", "Shaokang Zhang", "Zhou He", "Carla Seatzu"], "title": "Non-interference analysis of bounded labeled Petri nets", "comment": null, "summary": "This paper focuses on a fundamental problem on information security of\nbounded labeled Petri nets: non-interference analysis. As in hierarchical\ncontrol, we assume that a system is observed by users at different levels,\nnamely high-level users and low-level users. The output events produced by the\nfiring of transitions are also partitioned into high-level output events and\nlow-level output events. In general, high-level users can observe the\noccurrence of all the output events, while low-level users can only observe the\noccurrence of low-level output events. A system is said to be non-interferent\nif low-level users cannot infer the firing of transitions labeled with\nhigh-level output events by looking at low-level outputs. In this paper, we\nstudy a particular non-interference property, namely strong non-deterministic\nnon-interference (SNNI), using a special automaton called SNNI Verifier, and\npropose a necessary and sufficient condition for SNNI.", "AI": {"tldr": "\u672c\u6587\u7814\u7a76\u4e86\u6709\u754c\u6807\u8bb0Petri\u7f51\u7684\u975e\u5e72\u6d89\u5206\u6790\u95ee\u9898\uff0c\u63d0\u51fa\u4e86\u4f7f\u7528SNNI\u9a8c\u8bc1\u5668\u7684\u5fc5\u8981\u5145\u5206\u6761\u4ef6\u6765\u9a8c\u8bc1\u5f3a\u975e\u786e\u5b9a\u6027\u975e\u5e72\u6d89\u5c5e\u6027\u3002", "motivation": "\u5728\u5206\u5c42\u63a7\u5236\u7cfb\u7edf\u5b89\u5168\u4e2d\uff0c\u4e0d\u540c\u7ea7\u522b\u7528\u6237\u5bf9\u7cfb\u7edf\u8f93\u51fa\u7684\u89c2\u5bdf\u80fd\u529b\u4e0d\u540c\uff0c\u9700\u8981\u786e\u4fdd\u4f4e\u7ea7\u522b\u7528\u6237\u65e0\u6cd5\u901a\u8fc7\u89c2\u5bdf\u4f4e\u7ea7\u8f93\u51fa\u6765\u63a8\u65ad\u9ad8\u7ea7\u522b\u4e8b\u4ef6\u7684\u53d1\u751f\u3002", "method": "\u4f7f\u7528\u4e00\u79cd\u7279\u6b8a\u7684\u81ea\u52a8\u673a\u2014\u2014SNNI\u9a8c\u8bc1\u5668\uff0c\u6765\u5206\u6790\u7cfb\u7edf\u7684\u5f3a\u975e\u786e\u5b9a\u6027\u975e\u5e72\u6d89\u5c5e\u6027\u3002", "result": "\u63d0\u51fa\u4e86\u9a8c\u8bc1SNNI\u5c5e\u6027\u7684\u5fc5\u8981\u5145\u5206\u6761\u4ef6\u3002", "conclusion": "\u901a\u8fc7SNNI\u9a8c\u8bc1\u5668\u53ef\u4ee5\u6709\u6548\u5206\u6790\u6709\u754c\u6807\u8bb0Petri\u7f51\u7684\u975e\u5e72\u6d89\u5b89\u5168\u6027\u3002"}}
{"id": "2510.16357", "categories": ["cs.SE", "cs.LG", "cs.PL"], "pdf": "https://arxiv.org/pdf/2510.16357", "abs": "https://arxiv.org/abs/2510.16357", "authors": ["Jugal Gajjar", "Kamalasankari Subramaniakuppusamy"], "title": "MLCPD: A Unified Multi-Language Code Parsing Dataset with Universal AST Schema", "comment": "12 pages, 7 figures, 4 tables, 2 algorithms, and 34 references.\n  HuggingFace:\n  https://huggingface.co/datasets/jugalgajjar/MultiLang-Code-Parser-Dataset\n  GitHub: https://github.com/JugalGajjar/MultiLang-Code-Parser-Dataset", "summary": "We introduce the MultiLang Code Parser Dataset (MLCPD), a large-scale,\nlanguage-agnostic dataset unifying syntactic and structural representations of\ncode across ten major programming languages. MLCPD contains over seven million\nparsed source files normalized under our proposed universal Abstract Syntax\nTree (AST) schema, enabling consistent cross-language reasoning, structural\nlearning, and multilingual software analysis. Unlike existing corpora that\nfocus purely on token-level code or isolated parsers, MLCPD provides both\nhierarchical tree representations and rich metadata for every file, ensuring\nlossless syntactic coverage and structural uniformity. Each entry includes a\nnormalized schema, language-level metadata, and abstracted node semantics\nstored in Parquet format for scalable retrieval. Empirical analyses reveal\nstrong cross-language structural regularities-demonstrating that syntactic\ngraphs from languages as diverse as Python, Java, and Go can be aligned under a\nshared schema. We release the dataset publicly on Hugging Face and the\naccompanying codebase on GitHub, which includes complete pipelines for dataset\nreproduction, grammar compilation, and a visualization tool for exploring the\nunified AST across languages. Together, these resources establish MLCPD as an\nopen, reproducible foundation for future research in cross-language\nrepresentation learning and program analysis.", "AI": {"tldr": "MLCPD\u662f\u4e00\u4e2a\u5927\u89c4\u6a21\u3001\u8bed\u8a00\u65e0\u5173\u7684\u4ee3\u7801\u89e3\u6790\u6570\u636e\u96c6\uff0c\u7edf\u4e00\u4e8610\u79cd\u4e3b\u8981\u7f16\u7a0b\u8bed\u8a00\u7684\u8bed\u6cd5\u548c\u7ed3\u6784\u8868\u793a\uff0c\u5305\u542b\u8d85\u8fc7700\u4e07\u4e2a\u89e3\u6790\u540e\u7684\u6e90\u6587\u4ef6\uff0c\u91c7\u7528\u7edf\u4e00\u7684\u62bd\u8c61\u8bed\u6cd5\u6811\u6a21\u5f0f\u3002", "motivation": "\u73b0\u6709\u8bed\u6599\u5e93\u4e3b\u8981\u5173\u6ce8\u8bcd\u6cd5\u7ea7\u4ee3\u7801\u6216\u5b64\u7acb\u89e3\u6790\u5668\uff0c\u7f3a\u4e4f\u7edf\u4e00\u7684\u8de8\u8bed\u8a00\u7ed3\u6784\u8868\u793a\uff0c\u9700\u8981\u5efa\u7acb\u80fd\u591f\u652f\u6301\u8de8\u8bed\u8a00\u63a8\u7406\u3001\u7ed3\u6784\u5b66\u4e60\u548c\u591a\u8bed\u8a00\u8f6f\u4ef6\u5206\u6790\u7684\u6570\u636e\u96c6\u3002", "method": "\u63d0\u51fa\u901a\u7528\u62bd\u8c61\u8bed\u6cd5\u6811\u6a21\u5f0f\uff0c\u5bf910\u79cd\u7f16\u7a0b\u8bed\u8a00\u7684\u6e90\u4ee3\u7801\u8fdb\u884c\u89e3\u6790\u548c\u89c4\u8303\u5316\uff0c\u63d0\u4f9b\u5c42\u6b21\u5316\u6811\u8868\u793a\u548c\u4e30\u5bcc\u5143\u6570\u636e\uff0c\u786e\u4fdd\u65e0\u635f\u8bed\u6cd5\u8986\u76d6\u548c\u7ed3\u6784\u4e00\u81f4\u6027\u3002", "result": "\u7ecf\u9a8c\u5206\u6790\u663e\u793a\u5b58\u5728\u5f3a\u70c8\u7684\u8de8\u8bed\u8a00\u7ed3\u6784\u89c4\u5f8b\u6027\uff0c\u5373\u4f7f\u662fPython\u3001Java\u548cGo\u7b49\u4e0d\u540c\u8bed\u8a00\u7684\u8bed\u6cd5\u56fe\u4e5f\u80fd\u5728\u5171\u4eab\u6a21\u5f0f\u4e0b\u5bf9\u9f50\u3002\u6570\u636e\u96c6\u4ee5Parquet\u683c\u5f0f\u5b58\u50a8\uff0c\u4fbf\u4e8e\u6269\u5c55\u68c0\u7d22\u3002", "conclusion": "MLCPD\u4e3a\u8de8\u8bed\u8a00\u8868\u793a\u5b66\u4e60\u548c\u7a0b\u5e8f\u5206\u6790\u7684\u672a\u6765\u7814\u7a76\u5efa\u7acb\u4e86\u5f00\u653e\u3001\u53ef\u590d\u73b0\u7684\u57fa\u7840\uff0c\u76f8\u5173\u8d44\u6e90\u5df2\u5728Hugging Face\u548cGitHub\u4e0a\u516c\u5f00\u3002"}}
{"id": "2510.16594", "categories": ["cs.PL", "F.3.2; F.1.1"], "pdf": "https://arxiv.org/pdf/2510.16594", "abs": "https://arxiv.org/abs/2510.16594", "authors": ["Moida Praneeth Jain", "Venkatesh Choppella"], "title": "SimpliPy: A Source-Tracking Notional Machine for Simplified Python", "comment": "15 pages, 1 figure, 1 table. Accepted at the 4th Workshop on Research\n  Highlights in Programming Languages (RHPL 2025), co-located with FSTTCS 2025.\n  Code available at: https://github.com/PraneethJain/simplipy", "summary": "Misconceptions about program execution hinder many novice programmers. We\nintroduce SimpliPy, a notional machine designed around a carefully chosen\nPython subset to clarify core control flow and scoping concepts. Its foundation\nis a precise operational semantics that explicitly tracks source code line\nnumbers for each execution step, making the link between code and behavior\nunambiguous. Complementing the dynamic semantics, SimpliPy uses static analysis\nto generate Control Flow Graphs (CFGs) and identify lexical scopes, helping\nstudents build a structural understanding before tracing. We also present an\ninteractive web-based debugger built on these principles. This tool embodies\nthe formal techniques, visualizing the operational state (environments, stack)\nand using the static CFG to animate control flow directly on the graph during\nstep-by-step execution. SimpliPy thus integrates formal semantics, program\nanalysis, and visualization to offer both a pedagogical approach and a\npractical demonstration of applying formal methods to program understanding.", "AI": {"tldr": "SimpliPy\u662f\u4e00\u4e2a\u4e3aPython\u5b50\u96c6\u8bbe\u8ba1\u7684\u6559\u5b66\u6027\u6982\u5ff5\u673a\u5668\uff0c\u901a\u8fc7\u7cbe\u786e\u7684\u64cd\u4f5c\u8bed\u4e49\u548c\u9759\u6001\u5206\u6790\u6765\u6f84\u6e05\u7a0b\u5e8f\u6267\u884c\u4e2d\u7684\u63a7\u5236\u6d41\u548c\u4f5c\u7528\u57df\u6982\u5ff5\uff0c\u5e76\u63d0\u4f9b\u4e86\u57fa\u4e8eweb\u7684\u4ea4\u4e92\u5f0f\u8c03\u8bd5\u5668\u3002", "motivation": "\u89e3\u51b3\u521d\u5b66\u8005\u5bf9\u7a0b\u5e8f\u6267\u884c\u7684\u8bef\u89e3\u95ee\u9898\uff0c\u7279\u522b\u662f\u63a7\u5236\u6d41\u548c\u4f5c\u7528\u57df\u7b49\u6838\u5fc3\u6982\u5ff5\u7684\u7406\u89e3\u56f0\u96be\u3002", "method": "\u5f00\u53d1SimpliPy\u6982\u5ff5\u673a\u5668\uff0c\u5305\u542b\u7cbe\u786e\u7684\u64cd\u4f5c\u8bed\u4e49\uff08\u660e\u786e\u8ddf\u8e2a\u6e90\u4ee3\u7801\u884c\u53f7\uff09\u3001\u9759\u6001\u5206\u6790\u751f\u6210\u63a7\u5236\u6d41\u56fe\u548c\u8bcd\u6cd5\u4f5c\u7528\u57df\u8bc6\u522b\uff0c\u5e76\u6784\u5efa\u4ea4\u4e92\u5f0fweb\u8c03\u8bd5\u5668\u8fdb\u884c\u53ef\u89c6\u5316\u3002", "result": "\u5b9e\u73b0\u4e86\u5c06\u5f62\u5f0f\u8bed\u4e49\u3001\u7a0b\u5e8f\u5206\u6790\u548c\u53ef\u89c6\u5316\u96c6\u6210\u5728\u4e00\u8d77\u7684\u6559\u5b66\u5de5\u5177\uff0c\u80fd\u591f\u6e05\u6670\u5730\u5c55\u793a\u4ee3\u7801\u4e0e\u6267\u884c\u884c\u4e3a\u4e4b\u95f4\u7684\u8054\u7cfb\u3002", "conclusion": "SimpliPy\u6210\u529f\u5730\u5c06\u5f62\u5f0f\u65b9\u6cd5\u5e94\u7528\u4e8e\u7a0b\u5e8f\u7406\u89e3\u6559\u5b66\uff0c\u63d0\u4f9b\u4e86\u4e00\u4e2a\u7ed3\u5408\u5f62\u5f0f\u8bed\u4e49\u3001\u7a0b\u5e8f\u5206\u6790\u548c\u53ef\u89c6\u5316\u7684\u7efc\u5408\u6559\u5b66\u65b9\u6cd5\u548c\u5b9e\u8df5\u6f14\u793a\u3002"}}
{"id": "2510.17691", "categories": ["cs.LO", "F.4.1"], "pdf": "https://arxiv.org/pdf/2510.17691", "abs": "https://arxiv.org/abs/2510.17691", "authors": ["Bama Srinivasan"], "title": "A Mimamsa Inspired Framework For Instruction Sequencing In AI Agents", "comment": "16 pages", "summary": "This paper presents a formal framework for sequencing instructions in AI\nagents, inspired by the Indian philosophical system of Mimamsa. The framework\nformalizes sequencing mechanisms through action object pairs in three distinct\nways: direct assertion (Srutikrama) for temporal precedence, purpose driven\nsequencing (Arthakrama) for functional dependencies, and iterative procedures\n(Pravrittikrama) for distinguishing between parallel and sequential execution\nin repetitive tasks. It introduces the syntax and semantics of an action object\nimperative logic, extending the MIRA formalism (Srinivasan and Parthasarathi,\n2021) with explicit deduction rules for sequencing. The correctness of\ninstruction sequencing is established through a validated theorem, which is\nbased on object dependencies across successive instructions. This is further\nsupported by proofs of soundness and completeness. This formal verification\nenables reliable instruction sequencing, impacting AI applications across areas\nlike task planning and robotics by addressing temporal reasoning and dependency\nmodeling.", "AI": {"tldr": "\u63d0\u51fa\u57fa\u4e8e\u5370\u5ea6\u54f2\u5b66Mimamsa\u7cfb\u7edf\u7684AI\u6307\u4ee4\u6392\u5e8f\u6846\u67b6\uff0c\u901a\u8fc7\u52a8\u4f5c\u5bf9\u8c61\u5bf9\u5b9e\u73b0\u4e09\u79cd\u6392\u5e8f\u673a\u5236\uff1a\u76f4\u63a5\u65ad\u8a00\u3001\u76ee\u7684\u9a71\u52a8\u6392\u5e8f\u548c\u8fed\u4ee3\u7a0b\u5e8f\uff0c\u5e76\u5efa\u7acb\u4e86\u5f62\u5f0f\u5316\u9a8c\u8bc1\u7cfb\u7edf\u3002", "motivation": "\u53d7\u5370\u5ea6\u54f2\u5b66Mimamsa\u7cfb\u7edf\u542f\u53d1\uff0c\u89e3\u51b3AI\u4ee3\u7406\u4e2d\u6307\u4ee4\u6392\u5e8f\u7684\u53ef\u9760\u6027\u548c\u5f62\u5f0f\u5316\u9a8c\u8bc1\u95ee\u9898\uff0c\u7279\u522b\u662f\u5728\u4efb\u52a1\u89c4\u5212\u548c\u673a\u5668\u4eba\u5e94\u7528\u4e2d\u5904\u7406\u65f6\u95f4\u63a8\u7406\u548c\u4f9d\u8d56\u5efa\u6a21\u3002", "method": "\u6269\u5c55MIRA\u5f62\u5f0f\u5316\u7cfb\u7edf\uff0c\u5f15\u5165\u52a8\u4f5c\u5bf9\u8c61\u547d\u4ee4\u903b\u8f91\u7684\u8bed\u6cd5\u548c\u8bed\u4e49\uff0c\u5b9a\u4e49\u4e09\u79cd\u6392\u5e8f\u673a\u5236\uff1aSrutikrama\uff08\u76f4\u63a5\u65ad\u8a00\uff09\u3001Arthakrama\uff08\u76ee\u7684\u9a71\u52a8\uff09\u548cPravrittikrama\uff08\u8fed\u4ee3\u7a0b\u5e8f\uff09\uff0c\u5e76\u5efa\u7acb\u660e\u786e\u7684\u6f14\u7ece\u89c4\u5219\u3002", "result": "\u57fa\u4e8e\u5bf9\u8c61\u4f9d\u8d56\u5173\u7cfb\u5efa\u7acb\u4e86\u6307\u4ee4\u6392\u5e8f\u6b63\u786e\u6027\u7684\u9a8c\u8bc1\u5b9a\u7406\uff0c\u8bc1\u660e\u4e86\u7cfb\u7edf\u7684\u53ef\u9760\u6027\u548c\u5b8c\u5907\u6027\uff0c\u4e3aAI\u5e94\u7528\u63d0\u4f9b\u4e86\u53ef\u9760\u7684\u6307\u4ee4\u6392\u5e8f\u80fd\u529b\u3002", "conclusion": "\u8be5\u6846\u67b6\u901a\u8fc7\u5f62\u5f0f\u5316\u9a8c\u8bc1\u5b9e\u73b0\u4e86\u53ef\u9760\u7684\u6307\u4ee4\u6392\u5e8f\uff0c\u80fd\u591f\u663e\u8457\u5f71\u54cdAI\u5728\u4efb\u52a1\u89c4\u5212\u548c\u673a\u5668\u4eba\u7b49\u9886\u57df\u7684\u5e94\u7528\uff0c\u6709\u6548\u89e3\u51b3\u4e86\u65f6\u95f4\u63a8\u7406\u548c\u4f9d\u8d56\u5efa\u6a21\u95ee\u9898\u3002"}}
{"id": "2510.16384", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.16384", "abs": "https://arxiv.org/abs/2510.16384", "authors": ["Yuwei Zhao", "Yuan-An Xiao", "Qianyu Xiao", "Zhao Zhang", "Yingfei Xiong"], "title": "SemOpt: LLM-Driven Code Optimization via Rule-Based Analysis", "comment": null, "summary": "Automated code optimization aims to improve performance in programs by\nrefactoring code, and recent studies focus on utilizing LLMs for the\noptimization. Typical existing approaches mine optimization commits from\nopen-source codebases to construct a large-scale knowledge base, then employ\ninformation retrieval techniques such as BM25 to retrieve relevant optimization\nexamples for hotspot code locations, thereby guiding LLMs to optimize these\nhotspots. However, since semantically equivalent optimizations can manifest in\nsyntactically dissimilar code snippets, current retrieval methods often fail to\nidentify pertinent examples, leading to suboptimal optimization performance.\nThis limitation significantly reduces the effectiveness of existing\noptimization approaches.\n  To address these limitations, we propose SemOpt, a novel framework that\nleverages static program analysis to precisely identify optimizable code\nsegments, retrieve the corresponding optimization strategies, and generate the\noptimized results. SemOpt consists of three key components: (1) A strategy\nlibrary builder that extracts and clusters optimization strategies from\nreal-world code modifications. (2) A rule generator that generates Semgrep\nstatic analysis rules to capture the condition of applying the optimization\nstrategy. (3) An optimizer that utilizes the strategy library to generate\noptimized code results. All the three components are powered by LLMs.\n  On our benchmark containing 151 optimization tasks, SemOpt demonstrates its\neffectiveness under different LLMs by increasing the number of successful\noptimizations by 1.38 to 28 times compared to the baseline. Moreover, on\npopular large-scale C/C++ projects, it can improve individual performance\nmetrics by 5.04% to 218.07%, demonstrating its practical utility.", "AI": {"tldr": "SemOpt\u662f\u4e00\u4e2a\u5229\u7528\u9759\u6001\u7a0b\u5e8f\u5206\u6790\u548cLLM\u7684\u4ee3\u7801\u4f18\u5316\u6846\u67b6\uff0c\u901a\u8fc7\u7b56\u7565\u5e93\u6784\u5efa\u3001\u89c4\u5219\u751f\u6210\u548c\u4f18\u5316\u5668\u4e09\u4e2a\u7ec4\u4ef6\uff0c\u663e\u8457\u63d0\u5347\u4e86\u4ee3\u7801\u4f18\u5316\u6548\u679c\u3002", "motivation": "\u73b0\u6709\u57fa\u4e8eLLM\u7684\u4ee3\u7801\u4f18\u5316\u65b9\u6cd5\u4f9d\u8d56\u4fe1\u606f\u68c0\u7d22\u6280\u672f\u4ece\u5f00\u6e90\u4ee3\u7801\u5e93\u4e2d\u83b7\u53d6\u4f18\u5316\u793a\u4f8b\uff0c\u4f46\u7531\u4e8e\u8bed\u4e49\u7b49\u6548\u7684\u4f18\u5316\u53ef\u80fd\u8868\u73b0\u4e3a\u8bed\u6cd5\u4e0d\u540c\u7684\u4ee3\u7801\u7247\u6bb5\uff0c\u73b0\u6709\u68c0\u7d22\u65b9\u6cd5\u5f80\u5f80\u65e0\u6cd5\u8bc6\u522b\u76f8\u5173\u793a\u4f8b\uff0c\u5bfc\u81f4\u4f18\u5316\u6027\u80fd\u4e0d\u4f73\u3002", "method": "SemOpt\u6846\u67b6\u5305\u542b\u4e09\u4e2a\u5173\u952e\u7ec4\u4ef6\uff1a(1) \u7b56\u7565\u5e93\u6784\u5efa\u5668\uff1a\u4ece\u771f\u5b9e\u4ee3\u7801\u4fee\u6539\u4e2d\u63d0\u53d6\u548c\u805a\u7c7b\u4f18\u5316\u7b56\u7565\uff1b(2) \u89c4\u5219\u751f\u6210\u5668\uff1a\u751f\u6210Semgrep\u9759\u6001\u5206\u6790\u89c4\u5219\u6765\u6355\u83b7\u5e94\u7528\u4f18\u5316\u7b56\u7565\u7684\u6761\u4ef6\uff1b(3) \u4f18\u5316\u5668\uff1a\u5229\u7528\u7b56\u7565\u5e93\u751f\u6210\u4f18\u5316\u4ee3\u7801\u7ed3\u679c\u3002\u6240\u6709\u7ec4\u4ef6\u90fd\u7531LLM\u9a71\u52a8\u3002", "result": "\u5728\u5305\u542b151\u4e2a\u4f18\u5316\u4efb\u52a1\u7684\u57fa\u51c6\u6d4b\u8bd5\u4e2d\uff0cSemOpt\u5728\u4e0d\u540cLLM\u4e0b\u5c06\u6210\u529f\u4f18\u5316\u6570\u91cf\u63d0\u9ad8\u4e861.38\u523028\u500d\u3002\u5728\u5927\u578bC/C++\u9879\u76ee\u4e2d\uff0c\u53ef\u5c06\u5355\u4e2a\u6027\u80fd\u6307\u6807\u63d0\u53475.04%\u5230218.07%\u3002", "conclusion": "SemOpt\u901a\u8fc7\u7ed3\u5408\u9759\u6001\u7a0b\u5e8f\u5206\u6790\u548cLLM\uff0c\u6709\u6548\u89e3\u51b3\u4e86\u73b0\u6709\u4ee3\u7801\u4f18\u5316\u65b9\u6cd5\u4e2d\u68c0\u7d22\u76f8\u5173\u793a\u4f8b\u7684\u5c40\u9650\u6027\uff0c\u663e\u8457\u63d0\u5347\u4e86\u4f18\u5316\u6548\u679c\uff0c\u5177\u6709\u5b9e\u9645\u5e94\u7528\u4ef7\u503c\u3002"}}
{"id": "2510.16883", "categories": ["cs.PL", "cs.LO"], "pdf": "https://arxiv.org/pdf/2510.16883", "abs": "https://arxiv.org/abs/2510.16883", "authors": ["Giulia Giusti", "Michele Pagani"], "title": "JAX Autodiff from a Linear Logic Perspective (Extended Version)", "comment": null, "summary": "Autodiff refers to the core of the automatic differentiation systems\ndeveloped in projects like JAX and Dex. Autodiff has recently been formalised\nin a linear typed calculus by Radul et al in arXiv:2204.10923. Although this\nformalisation suffices to express the main program transformations of Autodiff,\nthe calculus is very specific to this task, and it is not clear whether the\ntype system yields a substructural logic that has interest on its own.\n  We propose an encoding of Autodiff into a linear $\\lambda$-calculus that\nenjoys a Curry-Howard correspondence with Girard's linear logic. We prove that\nthe encoding is sound both qualitatively (the encoded terms are extensionally\nequivalent to the original ones) and quantitatively (the encoding preserves the\noriginal work cost as described in arXiv:2204.10923). As a byproduct, we show\nthat unzipping, one of the transformations used to implement backpropagation in\nAutodiff, is, in fact, optional.", "AI": {"tldr": "\u8be5\u8bba\u6587\u5c06Autodiff\u7f16\u7801\u5230\u7ebf\u6027\u03bb\u6f14\u7b97\u4e2d\uff0c\u5efa\u7acb\u4e86\u4e0eGirard\u7ebf\u6027\u903b\u8f91\u7684Curry-Howard\u5bf9\u5e94\u5173\u7cfb\uff0c\u8bc1\u660e\u4e86\u7f16\u7801\u7684\u5b9a\u6027\u548c\u5b9a\u91cf\u6b63\u786e\u6027\uff0c\u5e76\u53d1\u73b0\u53cd\u5411\u4f20\u64ad\u4e2d\u7684unzipping\u53d8\u6362\u662f\u53ef\u9009\u7684\u3002", "motivation": "Radul\u7b49\u4eba\u7684Autodiff\u5f62\u5f0f\u5316\u867d\u7136\u80fd\u8868\u8fbe\u4e3b\u8981\u7a0b\u5e8f\u53d8\u6362\uff0c\u4f46\u5176\u7c7b\u578b\u7cfb\u7edf\u975e\u5e38\u7279\u5b9a\u4e8e\u8be5\u4efb\u52a1\uff0c\u4e0d\u6e05\u695a\u662f\u5426\u6784\u6210\u6709\u72ec\u7acb\u610f\u4e49\u7684\u5b50\u7ed3\u6784\u903b\u8f91\u3002", "method": "\u63d0\u51fa\u5c06Autodiff\u7f16\u7801\u5230\u7ebf\u6027\u03bb\u6f14\u7b97\u4e2d\uff0c\u8be5\u6f14\u7b97\u4e0eGirard\u7ebf\u6027\u903b\u8f91\u5177\u6709Curry-Howard\u5bf9\u5e94\u5173\u7cfb\u3002", "result": "\u8bc1\u660e\u4e86\u7f16\u7801\u7684\u5b9a\u6027\u6b63\u786e\u6027\uff08\u7f16\u7801\u9879\u4e0e\u539f\u59cb\u9879\u5916\u5ef6\u7b49\u4ef7\uff09\u548c\u5b9a\u91cf\u6b63\u786e\u6027\uff08\u4fdd\u7559\u539f\u59cb\u5de5\u4f5c\u6210\u672c\uff09\uff0c\u5e76\u53d1\u73b0unzipping\u53d8\u6362\u662f\u53ef\u9009\u7684\u3002", "conclusion": "Autodiff\u53ef\u4ee5\u6210\u529f\u7f16\u7801\u5230\u7ebf\u6027\u903b\u8f91\u4e2d\uff0c\u8fd9\u4e3a\u7406\u89e3\u81ea\u52a8\u5fae\u5206\u63d0\u4f9b\u4e86\u65b0\u7684\u903b\u8f91\u57fa\u7840\uff0c\u5e76\u7b80\u5316\u4e86\u53cd\u5411\u4f20\u64ad\u7684\u5b9e\u73b0\u3002"}}
{"id": "2510.16395", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.16395", "abs": "https://arxiv.org/abs/2510.16395", "authors": ["Xin Peng", "Chong Wang"], "title": "Code Digital Twin: Empowering LLMs with Tacit Knowledge for Complex Software Development", "comment": null, "summary": "Recent advances in large language models (LLMs) have demonstrated strong\ncapabilities in software engineering tasks, raising expectations of\nrevolutionary productivity gains. However, enterprise software development is\nlargely driven by incremental evolution, where challenges extend far beyond\nroutine coding and depend critically on tacit knowledge, including design\ndecisions at different levels and historical trade-offs. To achieve effective\nAI-powered support for complex software development, we should align emerging\nAI capabilities with the practical realities of enterprise development. To this\nend, we systematically identify challenges from both software and LLM\nperspectives. Alongside these challenges, we outline opportunities where AI and\nstructured knowledge frameworks can enhance decision-making in tasks such as\nissue localization and impact analysis. To address these needs, we propose the\nCode Digital Twin, a living framework that models both the physical and\nconceptual layers of software, preserves tacit knowledge, and co-evolves with\nthe codebase. By integrating hybrid knowledge representations, multi-stage\nextraction pipelines, incremental updates, LLM-empowered applications, and\nhuman-in-the-loop feedback, the Code Digital Twin transforms fragmented\nknowledge into explicit and actionable representations. Our vision positions it\nas a bridge between AI advancements and enterprise software realities,\nproviding a concrete roadmap toward sustainable, intelligent, and resilient\ndevelopment and evolution of ultra-complex systems.", "AI": {"tldr": "\u63d0\u51faCode Digital Twin\u6846\u67b6\uff0c\u901a\u8fc7\u6df7\u5408\u77e5\u8bc6\u8868\u793a\u548c\u591a\u9636\u6bb5\u63d0\u53d6\u7ba1\u9053\uff0c\u5c06\u4f01\u4e1a\u8f6f\u4ef6\u5f00\u53d1\u4e2d\u7684\u9690\u6027\u77e5\u8bc6\u8f6c\u5316\u4e3a\u663e\u6027\u53ef\u64cd\u4f5c\u8868\u793a\uff0c\u5f25\u5408AI\u80fd\u529b\u4e0e\u4f01\u4e1a\u8f6f\u4ef6\u73b0\u5b9e\u4e4b\u95f4\u7684\u5dee\u8ddd\u3002", "motivation": "\u867d\u7136\u5927\u8bed\u8a00\u6a21\u578b\u5728\u8f6f\u4ef6\u5de5\u7a0b\u4efb\u52a1\u4e2d\u8868\u73b0\u51fa\u8272\uff0c\u4f46\u4f01\u4e1a\u8f6f\u4ef6\u5f00\u53d1\u4e3b\u8981\u4f9d\u8d56\u589e\u91cf\u6f14\u8fdb\uff0c\u5176\u6311\u6218\u8fdc\u8d85\u5e38\u89c4\u7f16\u7801\uff0c\u5173\u952e\u5728\u4e8e\u9690\u6027\u77e5\u8bc6\uff08\u8bbe\u8ba1\u51b3\u7b56\u548c\u5386\u53f2\u6743\u8861\uff09\u3002\u9700\u8981\u5c06\u65b0\u5174AI\u80fd\u529b\u4e0e\u4f01\u4e1a\u5f00\u53d1\u5b9e\u8df5\u5bf9\u9f50\u3002", "method": "\u63d0\u51faCode Digital Twin\u6846\u67b6\uff0c\u5305\u542b\uff1a\u6df7\u5408\u77e5\u8bc6\u8868\u793a\u3001\u591a\u9636\u6bb5\u63d0\u53d6\u7ba1\u9053\u3001\u589e\u91cf\u66f4\u65b0\u3001LLM\u8d4b\u80fd\u5e94\u7528\u548c\u4eba\u673a\u534f\u540c\u53cd\u9988\uff0c\u5bf9\u8f6f\u4ef6\u7684\u7269\u7406\u5c42\u548c\u6982\u5ff5\u5c42\u8fdb\u884c\u5efa\u6a21\u3002", "result": "\u8be5\u6846\u67b6\u5c06\u788e\u7247\u5316\u77e5\u8bc6\u8f6c\u5316\u4e3a\u663e\u6027\u53ef\u64cd\u4f5c\u8868\u793a\uff0c\u4e3a\u95ee\u9898\u5b9a\u4f4d\u548c\u5f71\u54cd\u5206\u6790\u7b49\u4efb\u52a1\u63d0\u4f9bAI\u652f\u6301\uff0c\u5b9e\u73b0\u53ef\u6301\u7eed\u3001\u667a\u80fd\u548c\u5f39\u6027\u7684\u8d85\u590d\u6742\u7cfb\u7edf\u5f00\u53d1\u548c\u6f14\u8fdb\u3002", "conclusion": "Code Digital Twin\u4f5c\u4e3aAI\u8fdb\u5c55\u4e0e\u4f01\u4e1a\u8f6f\u4ef6\u73b0\u5b9e\u4e4b\u95f4\u7684\u6865\u6881\uff0c\u4e3a\u5b9e\u73b0\u667a\u80fd\u8f6f\u4ef6\u5f00\u53d1\u63d0\u4f9b\u4e86\u5177\u4f53\u8def\u7ebf\u56fe\u3002"}}
{"id": "2510.17429", "categories": ["cs.PL", "D.3.1"], "pdf": "https://arxiv.org/pdf/2510.17429", "abs": "https://arxiv.org/abs/2510.17429", "authors": ["Jin Sano", "Naoki Yamamoto", "Kazunori Ueda"], "title": "Introducing Linear Implication Types to $\u03bb_{GT}$ for Computing With Incomplete Graphs", "comment": "26 pages, 14 figures, This paper is submitted to PRO2025-3", "summary": "Designing programming languages that enable intuitive and safe manipulation\nof data structures is a critical research challenge. Conventional destructive\nmemory operations using pointers are complex and prone to errors. Existing type\nsystems, such as affine types and shape types, address this problem towards\nsafe manipulation of heaps and pointers, but design of high-level declarative\nlanguages that allow us to manipulate complex pointer data structures at a\nhigher level of abstraction is largely an open problem. The $\\lambda_{GT}$\nlanguage, a purely functional programming language that treats hypergraphs\n(hereafter referred to as graphs) as primary data structures, addresses some of\nthese challenges. By abstracting data with shared references and cycles as\ngraphs, it enables declarative operations through pattern matching and\nleverages its type system to guarantee safety of these operations.\nNevertheless, the previously proposed type system of $\\lambda_{GT}$ leaves two\nsignificant open challenges. First, the type system does not support\n\\emph{incomplete graphs}, that is, graphs in which some elements are missing\nfrom the graphs of user-defined types. Second, the type system relies on\ndynamic type checking during pattern matching. This study addresses these two\nchallenges by incorporating linear implication into the $\\lambda_{GT}$ type\nsystem, while introducing new constraints to ensure its soundness.", "AI": {"tldr": "\u8be5\u8bba\u6587\u901a\u8fc7\u5728\u7ebf\u6027\u7c7b\u578b\u7cfb\u7edf\u4e2d\u5f15\u5165\u7ebf\u6027\u8574\u6db5\uff0c\u89e3\u51b3\u4e86\u03bb_GT\u8bed\u8a00\u7c7b\u578b\u7cfb\u7edf\u7684\u4e24\u4e2a\u5173\u952e\u95ee\u9898\uff1a\u652f\u6301\u4e0d\u5b8c\u6574\u56fe\u7ed3\u6784\u548c\u6d88\u9664\u6a21\u5f0f\u5339\u914d\u4e2d\u7684\u52a8\u6001\u7c7b\u578b\u68c0\u67e5\u3002", "motivation": "\u73b0\u6709\u03bb_GT\u8bed\u8a00\u7684\u7c7b\u578b\u7cfb\u7edf\u5b58\u5728\u4e24\u4e2a\u4e3b\u8981\u7f3a\u9677\uff1a\u4e0d\u652f\u6301\u4e0d\u5b8c\u6574\u56fe\u7ed3\u6784\uff08\u5373\u7528\u6237\u5b9a\u4e49\u7c7b\u578b\u4e2d\u7f3a\u5931\u67d0\u4e9b\u5143\u7d20\u7684\u56fe\uff09\uff0c\u4ee5\u53ca\u5728\u6a21\u5f0f\u5339\u914d\u65f6\u4f9d\u8d56\u52a8\u6001\u7c7b\u578b\u68c0\u67e5\u3002\u8fd9\u4e9b\u95ee\u9898\u9650\u5236\u4e86\u8bed\u8a00\u7684\u8868\u8fbe\u80fd\u529b\u548c\u5b89\u5168\u6027\u3002", "method": "\u5728\u03bb_GT\u7684\u7c7b\u578b\u7cfb\u7edf\u4e2d\u5f15\u5165\u7ebf\u6027\u8574\u6db5\uff0c\u5e76\u6dfb\u52a0\u65b0\u7684\u7ea6\u675f\u6761\u4ef6\u6765\u786e\u4fdd\u7c7b\u578b\u7cfb\u7edf\u7684\u53ef\u9760\u6027\u3002\u8fd9\u79cd\u65b9\u6cd5\u4f7f\u5f97\u7c7b\u578b\u7cfb\u7edf\u80fd\u591f\u5904\u7406\u4e0d\u5b8c\u6574\u56fe\u7ed3\u6784\uff0c\u540c\u65f6\u6d88\u9664\u52a8\u6001\u7c7b\u578b\u68c0\u67e5\u7684\u9700\u6c42\u3002", "result": "\u63d0\u51fa\u7684\u6539\u8fdb\u7c7b\u578b\u7cfb\u7edf\u80fd\u591f\u652f\u6301\u4e0d\u5b8c\u6574\u56fe\u7ed3\u6784\uff0c\u5e76\u901a\u8fc7\u9759\u6001\u7c7b\u578b\u68c0\u67e5\u4fdd\u8bc1\u6a21\u5f0f\u5339\u914d\u7684\u5b89\u5168\u6027\uff0c\u4ece\u800c\u63d0\u9ad8\u4e86\u8bed\u8a00\u7684\u8868\u8fbe\u80fd\u529b\u548c\u53ef\u9760\u6027\u3002", "conclusion": "\u901a\u8fc7\u5728\u7ebf\u6027\u7c7b\u578b\u7cfb\u7edf\u4e2d\u96c6\u6210\u7ebf\u6027\u8574\u6db5\uff0c\u6210\u529f\u89e3\u51b3\u4e86\u03bb_GT\u8bed\u8a00\u7684\u4e24\u4e2a\u5173\u952e\u7c7b\u578b\u7cfb\u7edf\u95ee\u9898\uff0c\u4e3a\u5b9e\u73b0\u66f4\u5b89\u5168\u3001\u66f4\u8868\u8fbe\u6027\u7684\u56fe\u64cd\u4f5c\u7f16\u7a0b\u8bed\u8a00\u63d0\u4f9b\u4e86\u7406\u8bba\u57fa\u7840\u3002"}}
{"id": "2510.16433", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.16433", "abs": "https://arxiv.org/abs/2510.16433", "authors": ["Tatsuya Shirai", "Olivier Nourry", "Yutaro Kashiwa", "Kenji Fujiwara", "Yasutaka Kamei", "Hajimu Iida"], "title": "Large-Scale Empirical Analysis of Continuous Fuzzing: Insights from 1 Million Fuzzing Sessions", "comment": null, "summary": "Software vulnerabilities are constantly being reported and exploited in\nsoftware products, causing significant impacts on society. In recent years, the\nmain approach to vulnerability detection, fuzzing, has been integrated into the\ncontinuous integration process to run in short and frequent cycles. This\ncontinuous fuzzing allows for fast identification and remediation of\nvulnerabilities during the development process. Despite adoption by thousands\nof projects, however, it is unclear how continuous fuzzing contributes to\nvulnerability detection. This study aims to elucidate the role of continuous\nfuzzing in vulnerability detection. Specifically, we investigate the coverage\nand the total number of fuzzing sessions when fuzzing bugs are discovered. We\ncollect issue reports, coverage reports, and fuzzing logs from OSS-Fuzz, an\nonline service provided by Google that performs fuzzing during continuous\nintegration. Through an empirical study of a total of approximately 1.12\nmillion fuzzing sessions from 878 projects participating in OSS-Fuzz, we reveal\nthat (i) a substantial number of fuzzing bugs exist prior to the integration of\ncontinuous fuzzing, leading to a high detection rate in the early stages; (ii)\ncode coverage continues to increase as continuous fuzzing progresses; and (iii)\nchanges in coverage contribute to the detection of fuzzing bugs. This study\nprovides empirical insights into how continuous fuzzing contributes to fuzzing\nbug detection, offering practical implications for future strategies and tool\ndevelopment in continuous fuzzing.", "AI": {"tldr": "\u8be5\u7814\u7a76\u901a\u8fc7\u5206\u6790OSS-Fuzz\u4e2d878\u4e2a\u9879\u76ee\u7684\u7ea6112\u4e07\u6b21\u6a21\u7cca\u6d4b\u8bd5\u4f1a\u8bdd\uff0c\u63ed\u793a\u4e86\u6301\u7eed\u6a21\u7cca\u6d4b\u8bd5\u5728\u6f0f\u6d1e\u68c0\u6d4b\u4e2d\u7684\u4f5c\u7528\uff1a\u65e9\u671f\u9636\u6bb5\u68c0\u6d4b\u7387\u9ad8\u3001\u4ee3\u7801\u8986\u76d6\u7387\u6301\u7eed\u589e\u957f\u3001\u8986\u76d6\u7387\u53d8\u5316\u6709\u52a9\u4e8e\u6f0f\u6d1e\u53d1\u73b0\u3002", "motivation": "\u5c3d\u7ba1\u6301\u7eed\u6a21\u7cca\u6d4b\u8bd5\u5df2\u88ab\u6570\u5343\u4e2a\u9879\u76ee\u91c7\u7528\uff0c\u4f46\u5176\u5728\u6f0f\u6d1e\u68c0\u6d4b\u4e2d\u7684\u5177\u4f53\u8d21\u732e\u5c1a\u4e0d\u660e\u786e\u3002\u672c\u7814\u7a76\u65e8\u5728\u9610\u660e\u6301\u7eed\u6a21\u7cca\u6d4b\u8bd5\u5728\u6f0f\u6d1e\u68c0\u6d4b\u4e2d\u7684\u4f5c\u7528\u3002", "method": "\u6536\u96c6OSS-Fuzz\u7684\u95ee\u9898\u62a5\u544a\u3001\u8986\u76d6\u7387\u62a5\u544a\u548c\u6a21\u7cca\u6d4b\u8bd5\u65e5\u5fd7\uff0c\u5bf9878\u4e2a\u9879\u76ee\u7684\u7ea6112\u4e07\u6b21\u6a21\u7cca\u6d4b\u8bd5\u4f1a\u8bdd\u8fdb\u884c\u5b9e\u8bc1\u7814\u7a76\u3002", "result": "\u53d1\u73b0\u5927\u91cf\u6a21\u7cca\u6d4b\u8bd5\u6f0f\u6d1e\u5728\u6301\u7eed\u6a21\u7cca\u6d4b\u8bd5\u96c6\u6210\u524d\u5c31\u5df2\u5b58\u5728\uff0c\u5bfc\u81f4\u65e9\u671f\u68c0\u6d4b\u7387\u9ad8\uff1b\u4ee3\u7801\u8986\u76d6\u7387\u968f\u6301\u7eed\u6a21\u7cca\u6d4b\u8bd5\u8fdb\u5c55\u800c\u6301\u7eed\u589e\u52a0\uff1b\u8986\u76d6\u7387\u53d8\u5316\u6709\u52a9\u4e8e\u6a21\u7cca\u6d4b\u8bd5\u6f0f\u6d1e\u7684\u68c0\u6d4b\u3002", "conclusion": "\u672c\u7814\u7a76\u4e3a\u6301\u7eed\u6a21\u7cca\u6d4b\u8bd5\u5982\u4f55\u4fc3\u8fdb\u6a21\u7cca\u6d4b\u8bd5\u6f0f\u6d1e\u68c0\u6d4b\u63d0\u4f9b\u4e86\u5b9e\u8bc1\u89c1\u89e3\uff0c\u5bf9\u672a\u6765\u7684\u6301\u7eed\u6a21\u7cca\u6d4b\u8bd5\u7b56\u7565\u548c\u5de5\u5177\u5f00\u53d1\u5177\u6709\u5b9e\u9645\u610f\u4e49\u3002"}}
{"id": "2510.17505", "categories": ["cs.PL", "cs.PF"], "pdf": "https://arxiv.org/pdf/2510.17505", "abs": "https://arxiv.org/abs/2510.17505", "authors": ["Jaeyeon Won", "Willow Ahrens", "Joel S. Emer", "Saman Amarasinghe"], "title": "Insum: Sparse GPU Kernels Simplified and Optimized with Indirect Einsums", "comment": null, "summary": "Programming high-performance sparse GPU kernels is notoriously difficult,\nrequiring both substantial effort and deep expertise. Sparse compilers aim to\nsimplify this process, but existing systems fall short in two key ways. First,\nthey are primarily designed for CPUs and rarely produce high-performance GPU\ncode. Second, when computations involve both sparse and dense regions, these\ncompilers often fail to optimize the dense portions effectively. In this paper,\nwe propose a new approach for expressing sparse computations. We start from\nformat-agnostic Einsums over sparse tensors and rewrite them into\nformat-conscious indirect Einsums, which explicitly encode format information\nby mapping sparse data and metadata onto dense tensor operations through\nindirect indexing. To execute indirect Einsums, we introduce the Insum\ncompiler, which generates efficient GPU code for these Einsums by lowering to\nthe PyTorch compiler, extended to better support Tensor Core-enabled indirect\nEinsums. We also present two fixed-length sparse formats, GroupCOO and\nBlockGroupCOO, designed to fit naturally with indirect Einsums. Our approach\nachieves 1.14x to 3.81x speedups across a range of sparse GPU applications\nwhile reducing lines of code by 202x to 4491x compared to hand-written\nimplementations.", "AI": {"tldr": "\u63d0\u51fa\u4e86\u4e00\u79cd\u65b0\u7684\u7a00\u758f\u8ba1\u7b97\u8868\u8fbe\u65b9\u6cd5\uff0c\u901a\u8fc7\u5c06\u683c\u5f0f\u65e0\u5173\u7684\u7a00\u758f\u5f20\u91cfEinsums\u91cd\u5199\u4e3a\u683c\u5f0f\u611f\u77e5\u7684\u95f4\u63a5Einsums\uff0c\u5e76\u5f00\u53d1Insum\u7f16\u8bd1\u5668\u751f\u6210\u9ad8\u6548\u7684GPU\u4ee3\u7801\uff0c\u5728\u7a00\u758fGPU\u5e94\u7528\u4e2d\u5b9e\u73b0\u4e861.14x\u52303.81x\u7684\u52a0\u901f\u3002", "motivation": "\u73b0\u6709\u7684\u7a00\u758f\u7f16\u8bd1\u5668\u4e3b\u8981\u9488\u5bf9CPU\u8bbe\u8ba1\uff0c\u5f88\u5c11\u80fd\u751f\u6210\u9ad8\u6027\u80fdGPU\u4ee3\u7801\uff0c\u4e14\u5728\u7a00\u758f\u548c\u5bc6\u96c6\u533a\u57df\u6df7\u5408\u8ba1\u7b97\u65f6\u65e0\u6cd5\u6709\u6548\u4f18\u5316\u5bc6\u96c6\u90e8\u5206\u3002", "method": "\u4ece\u683c\u5f0f\u65e0\u5173\u7684\u7a00\u758f\u5f20\u91cfEinsums\u51fa\u53d1\uff0c\u91cd\u5199\u4e3a\u683c\u5f0f\u611f\u77e5\u7684\u95f4\u63a5Einsums\uff0c\u901a\u8fc7\u95f4\u63a5\u7d22\u5f15\u5c06\u7a00\u758f\u6570\u636e\u548c\u5143\u6570\u636e\u6620\u5c04\u5230\u5bc6\u96c6\u5f20\u91cf\u64cd\u4f5c\uff0c\u5e76\u4f7f\u7528Insum\u7f16\u8bd1\u5668\u751f\u6210GPU\u4ee3\u7801\u3002", "result": "\u5728\u591a\u79cd\u7a00\u758fGPU\u5e94\u7528\u4e2d\u5b9e\u73b0\u4e861.14x\u52303.81x\u7684\u52a0\u901f\uff0c\u76f8\u6bd4\u624b\u5de5\u5b9e\u73b0\u51cf\u5c11\u4e86202x\u52304491x\u7684\u4ee3\u7801\u884c\u6570\u3002", "conclusion": "\u8be5\u65b9\u6cd5\u901a\u8fc7\u95f4\u63a5Einsums\u548c\u4e13\u95e8\u7684\u7f16\u8bd1\u5668\uff0c\u6210\u529f\u89e3\u51b3\u4e86\u7a00\u758fGPU\u5185\u6838\u7f16\u7a0b\u7684\u56f0\u96be\uff0c\u5b9e\u73b0\u4e86\u663e\u8457\u7684\u6027\u80fd\u63d0\u5347\u548c\u4ee3\u7801\u7b80\u5316\u3002"}}
{"id": "2510.16502", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.16502", "abs": "https://arxiv.org/abs/2510.16502", "authors": ["Sebasti\u00e1n Pizard", "Ramiro Moreira", "Federico Galiano", "Ignacio Sastre", "Lorena Etcheverry"], "title": "On the Use of Large Language Models for Qualitative Synthesis", "comment": null, "summary": "Large language models (LLMs) show promise for supporting systematic reviews\n(SR), even complex tasks such as qualitative synthesis (QS). However, applying\nthem to a stage that is unevenly reported and variably conducted carries\nimportant risks: misuse can amplify existing weaknesses and erode confidence in\nthe SR findings. To examine the challenges of using LLMs for QS, we conducted a\ncollaborative autoethnography involving two trials. We evaluated each trial for\nmethodological rigor and practical usefulness, and interpreted the results\nthrough a technical lens informed by how LLMs are built and their current\nlimitations.", "AI": {"tldr": "\u672c\u6587\u63a2\u8ba8\u4e86\u5728\u7cfb\u7edf\u6027\u7efc\u8ff0\u7684\u5b9a\u6027\u7efc\u5408\u9636\u6bb5\u4f7f\u7528\u5927\u578b\u8bed\u8a00\u6a21\u578b\u7684\u6311\u6218\uff0c\u901a\u8fc7\u534f\u4f5c\u81ea\u6c11\u65cf\u5fd7\u65b9\u6cd5\u8bc4\u4f30\u5176\u65b9\u6cd5\u4e25\u8c28\u6027\u548c\u5b9e\u9645\u6709\u7528\u6027\u3002", "motivation": "\u5927\u578b\u8bed\u8a00\u6a21\u578b\u5728\u7cfb\u7edf\u6027\u7efc\u8ff0\u4e2d\u663e\u793a\u51fa\u6f5c\u529b\uff0c\u4f46\u5c06\u5176\u5e94\u7528\u4e8e\u62a5\u544a\u4e0d\u4e00\u81f4\u3001\u6267\u884c\u591a\u53d8\u7684\u5b9a\u6027\u7efc\u5408\u9636\u6bb5\u5b58\u5728\u98ce\u9669\uff0c\u53ef\u80fd\u653e\u5927\u73b0\u6709\u5f31\u70b9\u5e76\u524a\u5f31\u7efc\u8ff0\u7ed3\u679c\u7684\u53ef\u4fe1\u5ea6\u3002", "method": "\u91c7\u7528\u534f\u4f5c\u81ea\u6c11\u65cf\u5fd7\u65b9\u6cd5\uff0c\u5305\u542b\u4e24\u4e2a\u8bd5\u9a8c\uff0c\u4ece\u65b9\u6cd5\u4e25\u8c28\u6027\u548c\u5b9e\u9645\u6709\u7528\u6027\u89d2\u5ea6\u8bc4\u4f30\uff0c\u5e76\u7ed3\u5408LLMs\u6784\u5efa\u65b9\u5f0f\u53ca\u5f53\u524d\u5c40\u9650\u7684\u6280\u672f\u89c6\u89d2\u8fdb\u884c\u89e3\u8bfb\u3002", "result": "\u7814\u7a76\u53d1\u73b0\u4f7f\u7528LLMs\u8fdb\u884c\u5b9a\u6027\u7efc\u5408\u9762\u4e34\u91cd\u8981\u6311\u6218\uff0c\u9700\u8981\u8c28\u614e\u8003\u8651\u5176\u5e94\u7528\u65b9\u5f0f\u4ee5\u907f\u514d\u653e\u5927\u7cfb\u7edf\u6027\u7efc\u8ff0\u4e2d\u7684\u73b0\u6709\u95ee\u9898\u3002", "conclusion": "\u5728\u7cfb\u7edf\u6027\u7efc\u8ff0\u7684\u5b9a\u6027\u7efc\u5408\u9636\u6bb5\u4f7f\u7528LLMs\u9700\u8981\u8c28\u614e\uff0c\u5fc5\u987b\u8003\u8651\u5176\u6280\u672f\u5c40\u9650\u6027\u548c\u53ef\u80fd\u5e26\u6765\u7684\u98ce\u9669\uff0c\u4ee5\u786e\u4fdd\u7814\u7a76\u7ed3\u679c\u7684\u53ef\u9760\u6027\u3002"}}
{"id": "2510.16579", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.16579", "abs": "https://arxiv.org/abs/2510.16579", "authors": ["Wendk\u00fbuni C. Ou\u00e9draogo", "Yinghua Li", "Xueqi Dang", "Pawel Borsukiewicz", "Xin Zhou", "Anil Koyuncu", "Jacques Klein", "David Lo", "Tegawend\u00e9 F. Bissyand\u00e9"], "title": "Human-Aligned Code Readability Assessment with Large Language Models", "comment": null, "summary": "Code readability is crucial for software comprehension and maintenance, yet\ndifficult to assess at scale. Traditional static metrics often fail to capture\nthe subjective, context-sensitive nature of human judgments. Large Language\nModels (LLMs) offer a scalable alternative, but their behavior as readability\nevaluators remains underexplored. We introduce CoReEval, the first large-scale\nbenchmark for evaluating LLM-based code readability assessment, comprising over\n1.4 million model-snippet-prompt evaluations across 10 state of the art LLMs.\nThe benchmark spans 3 programming languages (Java, Python, CUDA), 2 code types\n(functional code and unit tests), 4 prompting strategies (ZSL, FSL, CoT, ToT),\n9 decoding settings, and developer-guided prompts tailored to junior and senior\npersonas. We compare LLM outputs against human annotations and a validated\nstatic model, analyzing numerical alignment (MAE, Pearson's, Spearman's) and\njustification quality (sentiment, aspect coverage, semantic clustering). Our\nfindings show that developer-guided prompting grounded in human-defined\nreadability dimensions improves alignment in structured contexts, enhances\nexplanation quality, and enables lightweight personalization through persona\nframing. However, increased score variability highlights trade-offs between\nalignment, stability, and interpretability. CoReEval provides a robust\nfoundation for prompt engineering, model alignment studies, and human in the\nloop evaluation, with applications in education, onboarding, and CI/CD\npipelines where LLMs can serve as explainable, adaptable reviewers.", "AI": {"tldr": "CoReEval\u662f\u9996\u4e2a\u5927\u89c4\u6a21\u8bc4\u4f30LLM\u4ee3\u7801\u53ef\u8bfb\u6027\u8bc4\u4f30\u80fd\u529b\u7684\u57fa\u51c6\uff0c\u5305\u542b140\u4e07\u6b21\u6a21\u578b-\u4ee3\u7801\u7247\u6bb5-\u63d0\u793a\u8bc4\u4f30\uff0c\u6db5\u76d610\u4e2a\u5148\u8fdbLLM\u30013\u79cd\u7f16\u7a0b\u8bed\u8a00\u30012\u79cd\u4ee3\u7801\u7c7b\u578b\u30014\u79cd\u63d0\u793a\u7b56\u7565\u548c9\u79cd\u89e3\u7801\u8bbe\u7f6e\u3002\u7814\u7a76\u53d1\u73b0\u57fa\u4e8e\u5f00\u53d1\u8005\u6307\u5bfc\u7684\u63d0\u793a\u80fd\u6539\u5584\u5bf9\u9f50\u5ea6\u548c\u89e3\u91ca\u8d28\u91cf\uff0c\u4f46\u4f1a\u589e\u52a0\u8bc4\u5206\u53d8\u5f02\u6027\u3002", "motivation": "\u4ee3\u7801\u53ef\u8bfb\u6027\u5bf9\u8f6f\u4ef6\u7406\u89e3\u548c\u7ef4\u62a4\u81f3\u5173\u91cd\u8981\uff0c\u4f46\u96be\u4ee5\u5927\u89c4\u6a21\u8bc4\u4f30\u3002\u4f20\u7edf\u9759\u6001\u6307\u6807\u65e0\u6cd5\u6355\u6349\u4eba\u7c7b\u5224\u65ad\u7684\u4e3b\u89c2\u6027\u548c\u4e0a\u4e0b\u6587\u654f\u611f\u6027\uff0c\u800cLLM\u4f5c\u4e3a\u53ef\u6269\u5c55\u66ff\u4ee3\u65b9\u6848\u7684\u884c\u4e3a\u5c1a\u672a\u5145\u5206\u63a2\u7d22\u3002", "method": "\u6784\u5efaCoReEval\u57fa\u51c6\uff0c\u6bd4\u8f83LLM\u8f93\u51fa\u4e0e\u4eba\u5de5\u6807\u6ce8\u548c\u9a8c\u8bc1\u9759\u6001\u6a21\u578b\uff0c\u5206\u6790\u6570\u503c\u5bf9\u9f50\uff08MAE\u3001Pearson\u3001Spearman\uff09\u548c\u7406\u7531\u8d28\u91cf\uff08\u60c5\u611f\u3001\u65b9\u9762\u8986\u76d6\u3001\u8bed\u4e49\u805a\u7c7b\uff09\u3002\u4f7f\u7528\u5f00\u53d1\u8005\u6307\u5bfc\u7684\u63d0\u793a\u7b56\u7565\uff0c\u9488\u5bf9\u521d\u7ea7\u548c\u9ad8\u7ea7\u5f00\u53d1\u8005\u89d2\u8272\u8fdb\u884c\u4e2a\u6027\u5316\u3002", "result": "\u57fa\u4e8e\u4eba\u7c7b\u5b9a\u4e49\u53ef\u8bfb\u6027\u7ef4\u5ea6\u7684\u5f00\u53d1\u8005\u6307\u5bfc\u63d0\u793a\u5728\u7ed3\u6784\u5316\u4e0a\u4e0b\u6587\u4e2d\u6539\u5584\u4e86\u5bf9\u9f50\u5ea6\uff0c\u589e\u5f3a\u4e86\u89e3\u91ca\u8d28\u91cf\uff0c\u5e76\u901a\u8fc7\u89d2\u8272\u6846\u67b6\u5b9e\u73b0\u8f7b\u91cf\u7ea7\u4e2a\u6027\u5316\u3002\u4f46\u8bc4\u5206\u53d8\u5f02\u6027\u589e\u52a0\uff0c\u63ed\u793a\u4e86\u5bf9\u9f50\u5ea6\u3001\u7a33\u5b9a\u6027\u548c\u53ef\u89e3\u91ca\u6027\u4e4b\u95f4\u7684\u6743\u8861\u3002", "conclusion": "CoReEval\u4e3a\u63d0\u793a\u5de5\u7a0b\u3001\u6a21\u578b\u5bf9\u9f50\u7814\u7a76\u548c\u4eba\u673a\u534f\u540c\u8bc4\u4f30\u63d0\u4f9b\u4e86\u575a\u5b9e\u57fa\u7840\uff0c\u5728\u6559\u80b2\u57f9\u8bad\u3001\u5165\u804c\u6d41\u7a0b\u548cCI/CD\u7ba1\u9053\u4e2d\uff0cLLM\u53ef\u4f5c\u4e3a\u53ef\u89e3\u91ca\u3001\u9002\u5e94\u6027\u5f3a\u7684\u8bc4\u5ba1\u8005\u3002"}}
{"id": "2510.16809", "categories": ["cs.SE", "cs.AI", "cs.CL", "cs.PL", "68T50, 68N30, 68W40", "I.2.7; D.2.7; I.2.6"], "pdf": "https://arxiv.org/pdf/2510.16809", "abs": "https://arxiv.org/abs/2510.16809", "authors": ["Amirkia Rafiei Oskooei", "Kaan Baturalp Cosdan", "Husamettin Isiktas", "Mehmet S. Aktas"], "title": "When Many-Shot Prompting Fails: An Empirical Study of LLM Code Translation", "comment": null, "summary": "Large Language Models (LLMs) with vast context windows offer new avenues for\nin-context learning (ICL), where providing many examples (\"many-shot\"\nprompting) is often assumed to enhance performance. We investigate this\nassumption for the complex task of code translation. Through a large-scale\nempirical study of over 90,000 translations, we systematically evaluate the\nimpact of scaling in-context examples from zero-shot to many-shot\nconfigurations of up to 625 examples, with prompts spanning from approximately\n100,000 to 800,000 tokens. Our findings reveal a \"many-shot paradox\": while\nstatic similarity metrics may modestly improve with more examples, functional\ncorrectness consistently peaks with few-shot prompting (5-25 examples).\nProviding substantially more examples often degrades this crucial functional\nperformance. This study highlights that for code translation, the quality of a\nfew well-chosen examples outweighs sheer quantity, challenging the universal\nefficacy of \"more is better\" for ICL and underscoring the task-dependent nature\nof optimal prompting strategies. Our results have significant implications for\neffectively leveraging LLMs in software engineering.", "AI": {"tldr": "\u8bba\u6587\u53d1\u73b0\u4ee3\u7801\u7ffb\u8bd1\u4efb\u52a1\u4e2d\u5b58\u5728\"\u591a\u6837\u672c\u6096\u8bba\"\uff1a\u867d\u7136\u9759\u6001\u76f8\u4f3c\u5ea6\u6307\u6807\u968f\u6837\u672c\u6570\u91cf\u589e\u52a0\u7565\u6709\u6539\u5584\uff0c\u4f46\u529f\u80fd\u6b63\u786e\u6027\u5728\u5c11\u6837\u672c\u63d0\u793a\uff085-25\u4e2a\u793a\u4f8b\uff09\u65f6\u8fbe\u5230\u5cf0\u503c\uff0c\u63d0\u4f9b\u66f4\u591a\u6837\u672c\u53cd\u800c\u4f1a\u964d\u4f4e\u6027\u80fd\u3002", "motivation": "\u7814\u7a76\u5927\u578b\u8bed\u8a00\u6a21\u578b\u5728\u4ee3\u7801\u7ffb\u8bd1\u4efb\u52a1\u4e2d\uff0c\u968f\u7740\u4e0a\u4e0b\u6587\u7a97\u53e3\u4e2d\u63d0\u4f9b\u66f4\u591a\u793a\u4f8b\uff08\u4ece\u96f6\u6837\u672c\u5230\u591a\u6837\u672c\u914d\u7f6e\uff09\u5bf9\u6027\u80fd\u7684\u5f71\u54cd\uff0c\u6311\u6218\"\u8d8a\u591a\u8d8a\u597d\"\u7684\u666e\u904d\u5047\u8bbe\u3002", "method": "\u901a\u8fc7\u5927\u89c4\u6a21\u5b9e\u8bc1\u7814\u7a76\uff0c\u8bc4\u4f30\u4e86\u8d85\u8fc790,000\u6b21\u7ffb\u8bd1\uff0c\u7cfb\u7edf\u6027\u5730\u6d4b\u8bd5\u4e86\u4ece\u96f6\u6837\u672c\u5230625\u4e2a\u793a\u4f8b\u7684\u591a\u6837\u672c\u914d\u7f6e\uff0c\u63d0\u793a\u957f\u5ea6\u4ece\u7ea6100,000\u5230800,000\u4e2atoken\u3002", "result": "\u529f\u80fd\u6b63\u786e\u6027\u5728\u5c11\u6837\u672c\u63d0\u793a\uff085-25\u4e2a\u793a\u4f8b\uff09\u65f6\u8fbe\u5230\u6700\u4f73\uff0c\u63d0\u4f9b\u66f4\u591a\u793a\u4f8b\u4f1a\u964d\u4f4e\u6027\u80fd\uff0c\u800c\u9759\u6001\u76f8\u4f3c\u5ea6\u6307\u6807\u4ec5\u7565\u6709\u6539\u5584\u3002", "conclusion": "\u5bf9\u4e8e\u4ee3\u7801\u7ffb\u8bd1\u4efb\u52a1\uff0c\u5c11\u91cf\u7cbe\u5fc3\u9009\u62e9\u7684\u793a\u4f8b\u8d28\u91cf\u6bd4\u6570\u91cf\u66f4\u91cd\u8981\uff0c\u6311\u6218\u4e86ICL\u4e2d\"\u8d8a\u591a\u8d8a\u597d\"\u7684\u666e\u904d\u6709\u6548\u6027\uff0c\u5f3a\u8c03\u4e86\u6700\u4f18\u63d0\u793a\u7b56\u7565\u7684\u4efb\u52a1\u4f9d\u8d56\u6027\u3002"}}
{"id": "2510.16665", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.16665", "abs": "https://arxiv.org/abs/2510.16665", "authors": ["Mohamed Sami Rakha", "Andriy Miranskyy", "Daniel Alencar da Costa"], "title": "Contrasting the Hyperparameter Tuning Impact Across Software Defect Prediction Scenarios", "comment": "Accepted to IEEE Transactions on Software Engineering", "summary": "Software defect prediction (SDP) is crucial for delivering high-quality\nsoftware products. Recent research has indicated that prediction performance\nimprovements in SDP are achievable by applying hyperparameter tuning to a\nparticular SDP scenario. However, the positive impact resulting from the\nhyperparameter tuning step may differ based on the targeted SDP scenario.\nComparing the impact of hyperparameter tuning across SDP scenarios is necessary\nto provide comprehensive insights and enhance the robustness, generalizability,\nand, eventually, the practicality of SDP modeling for quality assurance.\n  Therefore, in this study, we contrast the impact of hyperparameter tuning\nacross two pivotal and consecutive SDP scenarios: (1) Inner Version Defect\nPrediction (IVDP) and (2) Cross Version Defect Prediction (CVDP). The main\ndistinctions between the two scenarios lie in the scope of defect prediction\nand the selected evaluation setups. This study's experiments use common\nevaluation setups, 28 machine learning (ML) algorithms, 53 post-release\nsoftware datasets, two tuning algorithms, and five optimization metrics. We\napply statistical analytics to compare the SDP performance impact differences\nby investigating the overall impact, the single ML algorithm impact, and\nvariations across different software dataset sizes.\n  The results indicate that the SDP gains within the IVDP scenario are\nsignificantly larger than those within the CVDP scenario. The results reveal\nthat asserting performance gains for up to 24 out of 28 ML algorithms may not\nhold across multiple SDP scenarios. Furthermore, we found that small software\ndatasets are more susceptible to larger differences in performance impacts.\nOverall, the study findings recommend software engineering researchers and\npractitioners to consider the effect of the selected SDP scenario when\nexpecting performance gains from hyperparameter tuning.", "AI": {"tldr": "\u8be5\u7814\u7a76\u5bf9\u6bd4\u4e86\u8d85\u53c2\u6570\u8c03\u4f18\u5728\u4e24\u79cd\u8f6f\u4ef6\u7f3a\u9677\u9884\u6d4b\u573a\u666f\uff08IVDP\u548cCVDP\uff09\u4e2d\u7684\u5f71\u54cd\u5dee\u5f02\uff0c\u53d1\u73b0IVDP\u573a\u666f\u4e2d\u7684\u6027\u80fd\u63d0\u5347\u663e\u8457\u5927\u4e8eCVDP\u573a\u666f\uff0c\u4e14\u5c0f\u6570\u636e\u96c6\u66f4\u5bb9\u6613\u53d7\u5230\u6027\u80fd\u5f71\u54cd\u5dee\u5f02\u7684\u5f71\u54cd\u3002", "motivation": "\u867d\u7136\u8d85\u53c2\u6570\u8c03\u4f18\u53ef\u4ee5\u63d0\u5347\u8f6f\u4ef6\u7f3a\u9677\u9884\u6d4b\u6027\u80fd\uff0c\u4f46\u5176\u5f71\u54cd\u7a0b\u5ea6\u53ef\u80fd\u56e0\u4e0d\u540c\u7684SDP\u573a\u666f\u800c\u5f02\u3002\u9700\u8981\u6bd4\u8f83\u8d85\u53c2\u6570\u8c03\u4f18\u5728\u4e0d\u540cSDP\u573a\u666f\u4e2d\u7684\u5f71\u54cd\uff0c\u4ee5\u63d0\u4f9b\u5168\u9762\u89c1\u89e3\u5e76\u589e\u5f3aSDP\u5efa\u6a21\u7684\u9c81\u68d2\u6027\u548c\u5b9e\u7528\u6027\u3002", "method": "\u4f7f\u752828\u79cd\u673a\u5668\u5b66\u4e60\u7b97\u6cd5\u300153\u4e2a\u53d1\u5e03\u540e\u8f6f\u4ef6\u6570\u636e\u96c6\u3001\u4e24\u79cd\u8c03\u4f18\u7b97\u6cd5\u548c\u4e94\u4e2a\u4f18\u5316\u6307\u6807\uff0c\u5728IVDP\u548cCVDP\u4e24\u79cd\u5173\u952eSDP\u573a\u666f\u4e0b\u8fdb\u884c\u5b9e\u9a8c\uff0c\u5e76\u5e94\u7528\u7edf\u8ba1\u5206\u6790\u6bd4\u8f83\u6027\u80fd\u5f71\u54cd\u5dee\u5f02\u3002", "result": "IVDP\u573a\u666f\u4e2d\u7684SDP\u6027\u80fd\u589e\u76ca\u663e\u8457\u5927\u4e8eCVDP\u573a\u666f\uff1b28\u79cdML\u7b97\u6cd5\u4e2d\u6709\u591a\u8fbe24\u79cd\u7b97\u6cd5\u7684\u6027\u80fd\u589e\u76ca\u65ad\u8a00\u53ef\u80fd\u65e0\u6cd5\u8de8\u591a\u4e2aSDP\u573a\u666f\u6210\u7acb\uff1b\u5c0f\u8f6f\u4ef6\u6570\u636e\u96c6\u66f4\u5bb9\u6613\u51fa\u73b0\u8f83\u5927\u7684\u6027\u80fd\u5f71\u54cd\u5dee\u5f02\u3002", "conclusion": "\u8f6f\u4ef6\u5de5\u7a0b\u7814\u7a76\u8005\u548c\u5b9e\u8df5\u8005\u5728\u671f\u671b\u4ece\u8d85\u53c2\u6570\u8c03\u4f18\u4e2d\u83b7\u5f97\u6027\u80fd\u589e\u76ca\u65f6\uff0c\u5e94\u8003\u8651\u6240\u9009SDP\u573a\u666f\u7684\u5f71\u54cd\u3002"}}
{"id": "2510.16779", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.16779", "abs": "https://arxiv.org/abs/2510.16779", "authors": ["Xiaoyu Guo", "Minggu Wang", "Jianjun Zhao"], "title": "QuanBench: Benchmarking Quantum Code Generation with Large Language Models", "comment": "This paper was accepted by ASE2025", "summary": "Large language models (LLMs) have demonstrated good performance in general\ncode generation; however, their capabilities in quantum code generation remain\ninsufficiently studied. This paper presents QuanBench, a benchmark for\nevaluating LLMs on quantum code generation. QuanBench includes 44 programming\ntasks that cover quantum algorithms, state preparation, gate decomposition, and\nquantum machine learning. Each task has an executable canonical solution and is\nevaluated by functional correctness (Pass@K) and quantum semantic equivalence\n(Process Fidelity). We evaluate several recent LLMs, including general-purpose\nand code-specialized models. The results show that current LLMs have limited\ncapability in generating the correct quantum code, with overall accuracy below\n40% and frequent semantic errors. We also analyze common failure cases, such as\noutdated API usage, circuit construction errors, and incorrect algorithm logic.\nQuanBench provides a basis for future work on improving quantum code generation\nwith LLMs.", "AI": {"tldr": "\u63d0\u51fa\u4e86QuanBench\u57fa\u51c6\u6d4b\u8bd5\uff0c\u7528\u4e8e\u8bc4\u4f30\u5927\u8bed\u8a00\u6a21\u578b\u5728\u91cf\u5b50\u4ee3\u7801\u751f\u6210\u65b9\u9762\u7684\u6027\u80fd\uff0c\u5305\u542b44\u4e2a\u7f16\u7a0b\u4efb\u52a1\uff0c\u6db5\u76d6\u91cf\u5b50\u7b97\u6cd5\u3001\u72b6\u6001\u51c6\u5907\u3001\u95e8\u5206\u89e3\u548c\u91cf\u5b50\u673a\u5668\u5b66\u4e60\u7b49\u9886\u57df\u3002", "motivation": "\u5927\u8bed\u8a00\u6a21\u578b\u5728\u901a\u7528\u4ee3\u7801\u751f\u6210\u65b9\u9762\u8868\u73b0\u826f\u597d\uff0c\u4f46\u5728\u91cf\u5b50\u4ee3\u7801\u751f\u6210\u65b9\u9762\u7684\u80fd\u529b\u5c1a\u672a\u5f97\u5230\u5145\u5206\u7814\u7a76\uff0c\u9700\u8981\u4e13\u95e8\u7684\u57fa\u51c6\u6d4b\u8bd5\u6765\u8bc4\u4f30\u5176\u6027\u80fd\u3002", "method": "\u5f00\u53d1\u4e86QuanBench\u57fa\u51c6\u6d4b\u8bd5\uff0c\u5305\u542b44\u4e2a\u91cf\u5b50\u7f16\u7a0b\u4efb\u52a1\uff0c\u6bcf\u4e2a\u4efb\u52a1\u90fd\u6709\u53ef\u6267\u884c\u7684\u89c4\u8303\u89e3\u51b3\u65b9\u6848\uff0c\u5e76\u901a\u8fc7\u529f\u80fd\u6b63\u786e\u6027\uff08Pass@K\uff09\u548c\u91cf\u5b50\u8bed\u4e49\u7b49\u4ef7\u6027\uff08\u8fc7\u7a0b\u4fdd\u771f\u5ea6\uff09\u8fdb\u884c\u8bc4\u4f30\u3002", "result": "\u8bc4\u4f30\u7ed3\u679c\u663e\u793a\u5f53\u524d\u5927\u8bed\u8a00\u6a21\u578b\u5728\u751f\u6210\u6b63\u786e\u91cf\u5b50\u4ee3\u7801\u65b9\u9762\u7684\u80fd\u529b\u6709\u9650\uff0c\u603b\u4f53\u51c6\u786e\u7387\u4f4e\u4e8e40%\uff0c\u4e14\u7ecf\u5e38\u51fa\u73b0\u8bed\u4e49\u9519\u8bef\uff0c\u5e38\u89c1\u5931\u8d25\u6848\u4f8b\u5305\u62ec\u8fc7\u65f6\u7684API\u4f7f\u7528\u3001\u7535\u8def\u6784\u5efa\u9519\u8bef\u548c\u7b97\u6cd5\u903b\u8f91\u9519\u8bef\u3002", "conclusion": "QuanBench\u4e3a\u672a\u6765\u6539\u8fdb\u5927\u8bed\u8a00\u6a21\u578b\u7684\u91cf\u5b50\u4ee3\u7801\u751f\u6210\u80fd\u529b\u63d0\u4f9b\u4e86\u57fa\u7840\uff0c\u5f53\u524d\u6a21\u578b\u5728\u6b64\u9886\u57df\u4ecd\u6709\u663e\u8457\u63d0\u5347\u7a7a\u95f4\u3002"}}
{"id": "2510.16786", "categories": ["cs.SE", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.16786", "abs": "https://arxiv.org/abs/2510.16786", "authors": ["Pengfei Gao", "Chao Peng"], "title": "More with Less: An Empirical Study of Turn-Control Strategies for Efficient Coding Agents", "comment": null, "summary": "LLM-powered coding agents, which operate in iterative loops (turns) to solve\nsoftware engineering tasks, are becoming increasingly powerful. However, their\npractical deployment is hindered by significant and unpredictable costs. This\nchallenge arises from a combination of factors: quadratically growing token\ncounts with each turn, the high price of models, the large number of turns\nrequired for real-world tasks, and the tendency of agents to take inefficient\nor unnecessary actions. While existing research focuses on optimizing\nindividual turns, the strategic control of the total number of turns remains an\nunderexplored area for managing agent performance and cost. To address this\ngap, we conduct a comprehensive empirical study on SWE-bench using three\nstate-of-the-art models and evaluate the impact of three distinct turn-control\nstrategies: an unrestricted baseline, a fixed-turn limit with reminders, and a\nnovel dynamic-turn strategy that grants extensions on-demand. Our findings\nfirst reveal a fundamental trade-off in the unrestricted setting, where no\nsingle model excels across performance, cost, and turn efficiency. We then show\nthat a fixed-turn limit, specifically at the 75th percentile of the baseline,\nserves as a \"sweet spot\", substantially reducing costs (by 24%-68%) with\nminimal impact on solve rates. Most significantly, the dynamic-turn strategy\nconsistently outperforms fixed-limit approaches, achieving comparable or better\nsolve rates while further reducing costs by an additional 12%-24% by\nintelligently allocating resources only to tasks that need them. This work\nprovides the first systematic analysis of turn-control strategies, offering\nsimple yet effective guidelines for developers to balance cost and efficacy. We\ndemonstrate that dynamic resource allocation is a superior, easy-to-implement\napproach for deploying powerful yet economically viable coding agents.", "AI": {"tldr": "\u672c\u6587\u7cfb\u7edf\u7814\u7a76\u4e86LLM\u7f16\u7801\u4ee3\u7406\u7684\u8f6e\u6b21\u63a7\u5236\u7b56\u7565\uff0c\u53d1\u73b0\u52a8\u6001\u8f6e\u6b21\u7b56\u7565\u5728\u4fdd\u6301\u6027\u80fd\u7684\u540c\u65f6\u80fd\u663e\u8457\u964d\u4f4e\u6210\u672c\u3002", "motivation": "LLM\u7f16\u7801\u4ee3\u7406\u5728\u5b9e\u9645\u90e8\u7f72\u4e2d\u9762\u4e34\u663e\u8457\u4e14\u4e0d\u53ef\u9884\u6d4b\u7684\u6210\u672c\u95ee\u9898\uff0c\u4e3b\u8981\u6e90\u4e8e\u8f6e\u6b21\u589e\u52a0\u5bfc\u81f4\u7684\u4ee4\u724c\u6570\u91cf\u4e8c\u6b21\u589e\u957f\u3001\u6a21\u578b\u4ef7\u683c\u9ad8\u6602\u3001\u4efb\u52a1\u6240\u9700\u8f6e\u6b21\u591a\u4ee5\u53ca\u4ee3\u7406\u6548\u7387\u4f4e\u4e0b\u3002\u73b0\u6709\u7814\u7a76\u4e3b\u8981\u5173\u6ce8\u5355\u8f6e\u4f18\u5316\uff0c\u800c\u8f6e\u6b21\u603b\u6570\u63a7\u5236\u7b56\u7565\u5c1a\u672a\u5145\u5206\u63a2\u7d22\u3002", "method": "\u5728SWE-bench\u4e0a\u4f7f\u7528\u4e09\u79cd\u6700\u5148\u8fdb\u6a21\u578b\u8fdb\u884c\u5b9e\u8bc1\u7814\u7a76\uff0c\u8bc4\u4f30\u4e09\u79cd\u8f6e\u6b21\u63a7\u5236\u7b56\u7565\uff1a\u65e0\u9650\u5236\u57fa\u7ebf\u3001\u5e26\u63d0\u9192\u7684\u56fa\u5b9a\u8f6e\u6b21\u9650\u5236\u3001\u4ee5\u53ca\u6309\u9700\u6269\u5c55\u7684\u65b0\u578b\u52a8\u6001\u8f6e\u6b21\u7b56\u7565\u3002", "result": "\u53d1\u73b0\u65e0\u9650\u5236\u8bbe\u7f6e\u4e2d\u5b58\u5728\u57fa\u672c\u6743\u8861\uff0c\u6ca1\u6709\u5355\u4e00\u6a21\u578b\u5728\u6027\u80fd\u3001\u6210\u672c\u548c\u8f6e\u6b21\u6548\u7387\u65b9\u9762\u8868\u73b0\u4f18\u5f02\u3002\u56fa\u5b9a\u8f6e\u6b21\u9650\u5236\u5728\u57fa\u7ebf75%\u5206\u4f4d\u6570\u65f6\u662f\"\u6700\u4f73\u70b9\"\uff0c\u53ef\u5927\u5e45\u964d\u4f4e\u6210\u672c(24%-68%)\u4e14\u5bf9\u89e3\u51b3\u7387\u5f71\u54cd\u6700\u5c0f\u3002\u52a8\u6001\u8f6e\u6b21\u7b56\u7565\u6301\u7eed\u4f18\u4e8e\u56fa\u5b9a\u9650\u5236\u65b9\u6cd5\uff0c\u5728\u8fdb\u4e00\u6b65\u964d\u4f4e\u6210\u672c12%-24%\u7684\u540c\u65f6\u8fbe\u5230\u76f8\u5f53\u6216\u66f4\u597d\u7684\u89e3\u51b3\u7387\u3002", "conclusion": "\u52a8\u6001\u8d44\u6e90\u5206\u914d\u662f\u90e8\u7f72\u5f3a\u5927\u4e14\u7ecf\u6d4e\u53ef\u884c\u7684\u7f16\u7801\u4ee3\u7406\u7684\u4f18\u8d8a\u4e14\u6613\u4e8e\u5b9e\u65bd\u7684\u65b9\u6cd5\uff0c\u4e3a\u5f00\u53d1\u8005\u63d0\u4f9b\u4e86\u5e73\u8861\u6210\u672c\u4e0e\u6548\u80fd\u7684\u7b80\u5355\u6709\u6548\u6307\u5357\u3002"}}
{"id": "2510.16823", "categories": ["cs.SE", "cs.CR"], "pdf": "https://arxiv.org/pdf/2510.16823", "abs": "https://arxiv.org/abs/2510.16823", "authors": ["Yue Liu", "Zhenchang Xing", "Shidong Pan", "Chakkrit Tantithamthavorn"], "title": "When AI Takes the Wheel: Security Analysis of Framework-Constrained Program Generation", "comment": null, "summary": "In recent years, the AI wave has grown rapidly in software development. Even\nnovice developers can now design and generate complex framework-constrained\nsoftware systems based on their high-level requirements with the help of Large\nLanguage Models (LLMs). However, when LLMs gradually \"take the wheel\" of\nsoftware development, developers may only check whether the program works. They\noften miss security problems hidden in how the generated programs are\nimplemented.\n  In this work, we investigate the security properties of framework-constrained\nprograms generated by state-of-the-art LLMs. We focus specifically on Chrome\nextensions due to their complex security model involving multiple privilege\nboundaries and isolated components. To achieve this, we built ChromeSecBench, a\ndataset with 140 prompts based on known vulnerable extensions. We used these\nprompts to instruct nine state-of-the-art LLMs to generate complete Chrome\nextensions, and then analyzed them for vulnerabilities across three dimensions:\nscenario types, model differences, and vulnerability categories. Our results\nshow that LLMs produced vulnerable programs at alarmingly high rates (18%-50%),\nparticularly in Authentication & Identity and Cookie Management scenarios (up\nto 83% and 78% respectively). Most vulnerabilities exposed sensitive browser\ndata like cookies, history, or bookmarks to untrusted code. Interestingly, we\nfound that advanced reasoning models performed worse, generating more\nvulnerabilities than simpler models. These findings highlight a critical gap\nbetween LLMs' coding skills and their ability to write secure\nframework-constrained programs.", "AI": {"tldr": "\u7814\u7a76\u53d1\u73b0\uff0cLLM\u751f\u6210\u7684Chrome\u6269\u5c55\u7a0b\u5e8f\u5b58\u5728\u4e25\u91cd\u5b89\u5168\u6f0f\u6d1e\uff0c\u6f0f\u6d1e\u7387\u9ad8\u8fbe18%-50%\uff0c\u7279\u522b\u662f\u5728\u8eab\u4efd\u9a8c\u8bc1\u548cCookie\u7ba1\u7406\u573a\u666f\u4e2d\u6f0f\u6d1e\u7387\u5206\u522b\u8fbe\u523083%\u548c78%\u3002", "motivation": "\u968f\u7740LLM\u5728\u8f6f\u4ef6\u5f00\u53d1\u4e2d\u7684\u5e7f\u6cdb\u5e94\u7528\uff0c\u5f00\u53d1\u8005\u53ef\u80fd\u53ea\u5173\u6ce8\u7a0b\u5e8f\u529f\u80fd\u800c\u5ffd\u7565\u5b9e\u73b0\u4e2d\u7684\u5b89\u5168\u95ee\u9898\uff0c\u7279\u522b\u662f\u5728\u6846\u67b6\u7ea6\u675f\u7a0b\u5e8f\u4e2d\u7684\u5b89\u5168\u9690\u60a3\u3002", "method": "\u6784\u5efa\u4e86\u5305\u542b140\u4e2a\u57fa\u4e8e\u5df2\u77e5\u6f0f\u6d1e\u6269\u5c55\u63d0\u793a\u7684ChromeSecBench\u6570\u636e\u96c6\uff0c\u4f7f\u75289\u4e2a\u6700\u5148\u8fdb\u7684LLM\u751f\u6210\u5b8c\u6574Chrome\u6269\u5c55\uff0c\u5e76\u4ece\u573a\u666f\u7c7b\u578b\u3001\u6a21\u578b\u5dee\u5f02\u548c\u6f0f\u6d1e\u7c7b\u522b\u4e09\u4e2a\u7ef4\u5ea6\u5206\u6790\u5b89\u5168\u6027\u3002", "result": "LLM\u751f\u6210\u7684\u7a0b\u5e8f\u5b58\u5728\u9ad8\u6f0f\u6d1e\u7387\uff0c\u5927\u591a\u6570\u6f0f\u6d1e\u4f1a\u5c06\u654f\u611f\u6d4f\u89c8\u5668\u6570\u636e\u66b4\u9732\u7ed9\u4e0d\u53ef\u4fe1\u4ee3\u7801\u3002\u4ee4\u4eba\u610f\u5916\u7684\u662f\uff0c\u9ad8\u7ea7\u63a8\u7406\u6a21\u578b\u8868\u73b0\u66f4\u5dee\uff0c\u6bd4\u7b80\u5355\u6a21\u578b\u751f\u6210\u66f4\u591a\u6f0f\u6d1e\u3002", "conclusion": "LLM\u7684\u7f16\u7801\u80fd\u529b\u4e0e\u7f16\u5199\u5b89\u5168\u6846\u67b6\u7ea6\u675f\u7a0b\u5e8f\u7684\u80fd\u529b\u4e4b\u95f4\u5b58\u5728\u5173\u952e\u5dee\u8ddd\uff0c\u9700\u8981\u52a0\u5f3aLLM\u5728\u5b89\u5168\u7f16\u7a0b\u65b9\u9762\u7684\u80fd\u529b\u3002"}}
{"id": "2510.17056", "categories": ["cs.SE", "cs.HC"], "pdf": "https://arxiv.org/pdf/2510.17056", "abs": "https://arxiv.org/abs/2510.17056", "authors": ["Luis F. G. Campos", "Leonardo C. Marques", "Walter T. Nakamura"], "title": "Will AI also replace inspectors? Investigating the potential of generative AIs in usability inspection", "comment": "Accepted and to be published in SBQS25 - Brazilian Symposium on\n  Software Quality 2025", "summary": "Usability inspection is a well-established technique for identifying\ninteraction issues in software interfaces, thereby contributing to improved\nproduct quality. However, it is a costly process that requires time and\nspecialized knowledge from inspectors. With advances in Artificial Intelligence\n(AI), new opportunities have emerged to support this task, particularly through\ngenerative models capable of interpreting interfaces and performing inspections\nmore efficiently. This study examines the performance of generative AIs in\nidentifying usability problems, comparing them to those of experienced human\ninspectors. A software prototype was evaluated by four specialists and two AI\nmodels (GPT-4o and Gemini 2.5 Flash), using metrics such as precision, recall,\nand F1-score. While inspectors achieved the highest levels of precision and\noverall coverage, the AIs demonstrated high individual performance and\ndiscovered many novel defects, but with a higher rate of false positives and\nredundant reports. The combination of AIs and human inspectors produced the\nbest results, revealing their complementarity. These findings suggest that AI,\nin its current stage, cannot replace human inspectors but can serve as a\nvaluable augmentation tool to improve efficiency and expand defect coverage.\nThe results provide evidence based on quantitative analysis to inform the\ndiscussion on the role of AI in usability inspections, pointing to viable paths\nfor its complementary use in software quality assessment contexts.", "AI": {"tldr": "\u672c\u7814\u7a76\u6bd4\u8f83\u4e86\u751f\u6210\u5f0fAI\u4e0e\u4eba\u7c7b\u4e13\u5bb6\u5728\u53ef\u7528\u6027\u68c0\u67e5\u4e2d\u7684\u8868\u73b0\uff0c\u53d1\u73b0AI\u80fd\u53d1\u73b0\u8bb8\u591a\u65b0\u7f3a\u9677\u4f46\u5047\u9633\u6027\u7387\u8f83\u9ad8\uff0cAI\u4e0e\u4eba\u7c7b\u68c0\u67e5\u5458\u7ed3\u5408\u53ef\u83b7\u5f97\u6700\u4f73\u7ed3\u679c\u3002", "motivation": "\u53ef\u7528\u6027\u68c0\u67e5\u6210\u672c\u9ad8\u4e14\u9700\u8981\u4e13\u4e1a\u77e5\u8bc6\uff0cAI\u6280\u672f\u4e3a\u652f\u6301\u8fd9\u4e00\u4efb\u52a1\u63d0\u4f9b\u4e86\u65b0\u673a\u4f1a\uff0c\u672c\u7814\u7a76\u65e8\u5728\u8bc4\u4f30AI\u5728\u8bc6\u522b\u53ef\u7528\u6027\u95ee\u9898\u65b9\u9762\u7684\u6027\u80fd\u3002", "method": "\u4f7f\u7528\u8f6f\u4ef6\u539f\u578b\uff0c\u75314\u540d\u4e13\u5bb6\u548c2\u4e2aAI\u6a21\u578b\uff08GPT-4o\u548cGemini 2.5 Flash\uff09\u8fdb\u884c\u8bc4\u4f30\uff0c\u91c7\u7528\u7cbe\u786e\u7387\u3001\u53ec\u56de\u7387\u548cF1\u5206\u6570\u7b49\u6307\u6807\u3002", "result": "\u4eba\u7c7b\u68c0\u67e5\u5458\u5728\u7cbe\u786e\u7387\u548c\u6574\u4f53\u8986\u76d6\u7387\u65b9\u9762\u8868\u73b0\u6700\u4f73\uff0cAI\u8868\u73b0\u51fa\u9ad8\u4e2a\u4f53\u6027\u80fd\u5e76\u53d1\u73b0\u8bb8\u591a\u65b0\u7f3a\u9677\uff0c\u4f46\u5047\u9633\u6027\u7387\u548c\u5197\u4f59\u62a5\u544a\u8f83\u9ad8\u3002AI\u4e0e\u4eba\u7c7b\u7ed3\u5408\u4ea7\u751f\u6700\u4f73\u7ed3\u679c\u3002", "conclusion": "\u5f53\u524d\u9636\u6bb5\u7684AI\u65e0\u6cd5\u66ff\u4ee3\u4eba\u7c7b\u68c0\u67e5\u5458\uff0c\u4f46\u53ef\u4f5c\u4e3a\u6709\u4ef7\u503c\u7684\u589e\u5f3a\u5de5\u5177\u6765\u63d0\u9ad8\u6548\u7387\u5e76\u6269\u5927\u7f3a\u9677\u8986\u76d6\u8303\u56f4\uff0c\u5728\u8f6f\u4ef6\u8d28\u91cf\u8bc4\u4f30\u4e2d\u5177\u6709\u4e92\u8865\u4f7f\u7528\u4ef7\u503c\u3002"}}
{"id": "2510.17110", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.17110", "abs": "https://arxiv.org/abs/2510.17110", "authors": ["Xiaoyu Guo", "Shinobu Saito", "Jianjun Zhao"], "title": "M2QCode: A Model-Driven Framework for Generating Multi-Platform Quantum Programs", "comment": "This paper was accepted by ASE2025", "summary": "With the growing interest in quantum computing, the emergence of quantum\nsupremacy has marked a pivotal milestone in the field. As a result, numerous\nquantum programming languages (QPLs) have been introduced to support the\ndevelopment of quantum algorithms. However, the application of Model-Driven\nDevelopment (MDD) in quantum system engineering remains largely underexplored.\nThis paper presents an MDD-based approach to support the structured design and\nimplementation of quantum systems. Our framework enables the automatic\ngeneration of quantum code for multiple QPLs, thereby enhancing development\nefficiency and consistency across heterogeneous quantum platforms. The\neffectiveness and practicality of our approach have been demonstrated through\nmultiple case studies.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u57fa\u4e8e\u6a21\u578b\u9a71\u52a8\u5f00\u53d1\uff08MDD\uff09\u7684\u65b9\u6cd5\uff0c\u7528\u4e8e\u652f\u6301\u91cf\u5b50\u7cfb\u7edf\u7684\u7ed3\u6784\u5316\u8bbe\u8ba1\u548c\u5b9e\u73b0\uff0c\u80fd\u591f\u81ea\u52a8\u4e3a\u591a\u79cd\u91cf\u5b50\u7f16\u7a0b\u8bed\u8a00\u751f\u6210\u4ee3\u7801\u3002", "motivation": "\u968f\u7740\u91cf\u5b50\u8ba1\u7b97\u7684\u53d1\u5c55\uff0c\u91cf\u5b50\u7f16\u7a0b\u8bed\u8a00\u4e0d\u65ad\u6d8c\u73b0\uff0c\u4f46\u6a21\u578b\u9a71\u52a8\u5f00\u53d1\u5728\u91cf\u5b50\u7cfb\u7edf\u5de5\u7a0b\u4e2d\u7684\u5e94\u7528\u4ecd\u672a\u88ab\u5145\u5206\u63a2\u7d22\u3002", "method": "\u5f00\u53d1\u4e86\u4e00\u4e2aMDD\u6846\u67b6\uff0c\u652f\u6301\u4ece\u6a21\u578b\u81ea\u52a8\u751f\u6210\u591a\u79cd\u91cf\u5b50\u7f16\u7a0b\u8bed\u8a00\u7684\u4ee3\u7801\u3002", "result": "\u901a\u8fc7\u591a\u4e2a\u6848\u4f8b\u7814\u7a76\u8bc1\u660e\u4e86\u8be5\u65b9\u6cd5\u7684\u6709\u6548\u6027\u548c\u5b9e\u7528\u6027\u3002", "conclusion": "\u8be5MDD\u65b9\u6cd5\u80fd\u591f\u63d0\u9ad8\u91cf\u5b50\u7cfb\u7edf\u5f00\u53d1\u6548\u7387\uff0c\u5e76\u786e\u4fdd\u5728\u4e0d\u540c\u91cf\u5b50\u5e73\u53f0\u4e0a\u7684\u4e00\u81f4\u6027\u3002"}}
{"id": "2510.17130", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.17130", "abs": "https://arxiv.org/abs/2510.17130", "authors": ["Shuzheng Gao", "Chaozheng Wang", "Cuiyun Gao", "Michael R. Lyu"], "title": "SEER: Enhancing Chain-of-Thought Code Generation through Self-Exploring Deep Reasoning", "comment": "The paper was completed in Feb. 2025, submitted to ICSE 2026 in Mar.\n  2025, received a major revision in Jun. 2025, and was finally accepted in\n  Oct. 2025", "summary": "Code generation, the task of creating executable programs from natural\nlanguage requirements, has recently seen tremendous advances through\nChain-of-Thought (CoT) reasoning, which enables Large Language Models (LLMs) to\ndevelop high-level reasoning plans before writing code. Recent research has\nproposed various methods to enhance models' CoT reasoning for code generation\nsuch as prompt engineering and supervised fine-tuning. However, existing\napproaches still face three critical limitations: (1) limited exploration of\ndiverse reasoning paths, which constrains generalization across various\nprogramming scenarios, (2) lack of quality assessment for intermediate\nreasoning steps, which hampers the reliability of the generated plans and code,\nand (3) the potential negative impact of \"overthinking\", potentially leading to\nunnecessarily complex and incorrect solutions. To address these limitations, we\nframe CoT code generation as a decision making problem and present SEER, a\nSElf-Exploring deep Reasoning framework that enables accurate and adaptive\nreasoning for code generation. SEER introduces three key components: (1)\nDiverse reasoning path exploration, which aims at exploring diverse reasoning\npaths and annotating intermediate steps without relying on manual experts or\nclosed-source proprietary models; (2) Reasoning quality-aware model training,\nwhich trains a policy model for generating candidate reasoning steps and a\nvalue model for assessing their quality; and (3) Adaptive CoT reasoning, which\ndynamically switches between direct generation and step-by-step reasoning for\ndifferent problems.", "AI": {"tldr": "SEER\u662f\u4e00\u4e2a\u81ea\u63a2\u7d22\u6df1\u5ea6\u63a8\u7406\u6846\u67b6\uff0c\u5c06\u4ee3\u7801\u751f\u6210\u7684\u601d\u7ef4\u94fe\u63a8\u7406\u6784\u5efa\u4e3a\u51b3\u7b56\u95ee\u9898\uff0c\u901a\u8fc7\u591a\u6837\u5316\u63a8\u7406\u8def\u5f84\u63a2\u7d22\u3001\u63a8\u7406\u8d28\u91cf\u611f\u77e5\u6a21\u578b\u8bad\u7ec3\u548c\u81ea\u9002\u5e94\u601d\u7ef4\u94fe\u63a8\u7406\u6765\u89e3\u51b3\u73b0\u6709\u65b9\u6cd5\u7684\u5c40\u9650\u6027\u3002", "motivation": "\u73b0\u6709\u601d\u7ef4\u94fe\u63a8\u7406\u65b9\u6cd5\u5b58\u5728\u4e09\u4e2a\u5173\u952e\u9650\u5236\uff1a\u63a8\u7406\u8def\u5f84\u591a\u6837\u6027\u6709\u9650\u3001\u7f3a\u4e4f\u4e2d\u95f4\u63a8\u7406\u6b65\u9aa4\u8d28\u91cf\u8bc4\u4f30\u3001\u4ee5\u53ca'\u8fc7\u5ea6\u601d\u8003'\u53ef\u80fd\u5bfc\u81f4\u7684\u8d1f\u9762\u5f71\u54cd\u3002", "method": "SEER\u5305\u542b\u4e09\u4e2a\u6838\u5fc3\u7ec4\u4ef6\uff1a\u591a\u6837\u5316\u63a8\u7406\u8def\u5f84\u63a2\u7d22\uff08\u65e0\u9700\u4e13\u5bb6\u6216\u95ed\u6e90\u6a21\u578b\uff09\u3001\u63a8\u7406\u8d28\u91cf\u611f\u77e5\u6a21\u578b\u8bad\u7ec3\uff08\u7b56\u7565\u6a21\u578b\u751f\u6210\u63a8\u7406\u6b65\u9aa4\uff0c\u4ef7\u503c\u6a21\u578b\u8bc4\u4f30\u8d28\u91cf\uff09\u3001\u81ea\u9002\u5e94\u601d\u7ef4\u94fe\u63a8\u7406\uff08\u6839\u636e\u95ee\u9898\u52a8\u6001\u5207\u6362\u76f4\u63a5\u751f\u6210\u4e0e\u9010\u6b65\u63a8\u7406\uff09\u3002", "result": "\u8be5\u6846\u67b6\u80fd\u591f\u5b9e\u73b0\u51c6\u786e\u4e14\u81ea\u9002\u5e94\u7684\u4ee3\u7801\u751f\u6210\u63a8\u7406\uff0c\u89e3\u51b3\u4e86\u73b0\u6709\u65b9\u6cd5\u7684\u5c40\u9650\u6027\u3002", "conclusion": "SEER\u901a\u8fc7\u5c06\u601d\u7ef4\u94fe\u4ee3\u7801\u751f\u6210\u6784\u5efa\u4e3a\u51b3\u7b56\u95ee\u9898\uff0c\u63d0\u4f9b\u4e86\u4e00\u79cd\u66f4\u53ef\u9760\u548c\u7075\u6d3b\u7684\u63a8\u7406\u6846\u67b6\uff0c\u80fd\u591f\u9002\u5e94\u4e0d\u540c\u7684\u7f16\u7a0b\u573a\u666f\u3002"}}
{"id": "2510.17142", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.17142", "abs": "https://arxiv.org/abs/2510.17142", "authors": ["Xiaoxue Ren", "Jun Wan", "Yun Peng", "Zhongxin Liu", "Ming Liang", "Dajun Chen", "Wei Jiang", "Yong Li"], "title": "PEACE: Towards Efficient Project-Level Efficiency Optimization via Hybrid Code Editing", "comment": null, "summary": "Large Language Models (LLMs) have demonstrated significant capability in code\ngeneration, but their potential in code efficiency optimization remains\nunderexplored. Previous LLM-based code efficiency optimization approaches\nexclusively focus on function-level optimization and overlook interaction\nbetween functions, failing to generalize to real-world development scenarios.\nCode editing techniques show great potential for conducting project-level\noptimization, yet they face challenges associated with invalid edits and\nsuboptimal internal functions. To address these gaps, we propose Peace, a novel\nhybrid framework for Project-level code Efficiency optimization through\nAutomatic Code Editing, which also ensures the overall correctness and\nintegrity of the project. Peace integrates three key phases: dependency-aware\noptimizing function sequence construction, valid associated edits\nidentification, and efficiency optimization editing iteration. To rigorously\nevaluate the effectiveness of Peace, we construct PeacExec, the first benchmark\ncomprising 146 real-world optimization tasks from 47 high-impact GitHub Python\nprojects, along with highly qualified test cases and executable environments.\nExtensive experiments demonstrate Peace's superiority over the state-of-the-art\nbaselines, achieving a 69.2% correctness rate (pass@1), +46.9% opt rate, and\n0.840 speedup in execution efficiency. Notably, our Peace outperforms all\nbaselines by significant margins, particularly in complex optimization tasks\nwith multiple functions. Moreover, extensive experiments are also conducted to\nvalidate the contributions of each component in Peace, as well as the rationale\nand effectiveness of our hybrid framework design.", "AI": {"tldr": "Peace\u662f\u4e00\u4e2a\u7528\u4e8e\u9879\u76ee\u7ea7\u4ee3\u7801\u6548\u7387\u4f18\u5316\u7684\u6df7\u5408\u6846\u67b6\uff0c\u901a\u8fc7\u81ea\u52a8\u4ee3\u7801\u7f16\u8f91\u5b9e\u73b0\u51fd\u6570\u95f4\u4ea4\u4e92\u4f18\u5316\uff0c\u5728\u771f\u5b9e\u9879\u76ee\u4e2d\u663e\u8457\u63d0\u5347\u6267\u884c\u6548\u7387\u3002", "motivation": "\u73b0\u6709LLM\u4ee3\u7801\u4f18\u5316\u65b9\u6cd5\u4ec5\u5173\u6ce8\u51fd\u6570\u7ea7\u4f18\u5316\uff0c\u5ffd\u89c6\u4e86\u51fd\u6570\u95f4\u4ea4\u4e92\uff0c\u65e0\u6cd5\u9002\u5e94\u771f\u5b9e\u5f00\u53d1\u573a\u666f\uff1b\u4ee3\u7801\u7f16\u8f91\u6280\u672f\u867d\u5177\u6f5c\u529b\u4f46\u9762\u4e34\u65e0\u6548\u7f16\u8f91\u548c\u6b21\u4f18\u5185\u90e8\u51fd\u6570\u7684\u6311\u6218\u3002", "method": "Peace\u6846\u67b6\u5305\u542b\u4e09\u4e2a\u5173\u952e\u9636\u6bb5\uff1a\u4f9d\u8d56\u611f\u77e5\u7684\u4f18\u5316\u51fd\u6570\u5e8f\u5217\u6784\u5efa\u3001\u6709\u6548\u5173\u8054\u7f16\u8f91\u8bc6\u522b\u3001\u6548\u7387\u4f18\u5316\u7f16\u8f91\u8fed\u4ee3\uff0c\u786e\u4fdd\u9879\u76ee\u6574\u4f53\u6b63\u786e\u6027\u548c\u5b8c\u6574\u6027\u3002", "result": "\u5728PeacExec\u57fa\u51c6\u6d4b\u8bd5\u4e2d\uff0cPeace\u8fbe\u523069.2%\u6b63\u786e\u7387\u3001+46.9%\u4f18\u5316\u7387\u548c0.840\u6267\u884c\u6548\u7387\u52a0\u901f\uff0c\u5728\u590d\u6742\u591a\u51fd\u6570\u4f18\u5316\u4efb\u52a1\u4e2d\u663e\u8457\u4f18\u4e8e\u73b0\u6709\u65b9\u6cd5\u3002", "conclusion": "Peace\u8bc1\u660e\u4e86\u9879\u76ee\u7ea7\u4ee3\u7801\u6548\u7387\u4f18\u5316\u7684\u53ef\u884c\u6027\uff0c\u5176\u6df7\u5408\u6846\u67b6\u8bbe\u8ba1\u6709\u6548\u89e3\u51b3\u4e86\u73b0\u6709\u65b9\u6cd5\u7684\u5c40\u9650\u6027\uff0c\u4e3aLLM\u5728\u4ee3\u7801\u4f18\u5316\u9886\u57df\u7684\u5e94\u7528\u5f00\u8f9f\u4e86\u65b0\u65b9\u5411\u3002"}}
{"id": "2510.17163", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.17163", "abs": "https://arxiv.org/abs/2510.17163", "authors": ["Shuzheng Gao", "Eric John Li", "Man Ho Lam", "Jingyu Xiao", "Yuxuan Wan", "Chaozheng Wang", "Ng Man Tik", "Michael R. Lyu"], "title": "TREAT: A Code LLMs Trustworthiness / Reliability Evaluation and Testing Framework", "comment": null, "summary": "Large foundation models are fundamentally transforming the software\nengineering landscape, demonstrating exceptional capabilities across diverse\ntasks such as code generation, debugging, and testing. Despite this rapid\nprogress, a significant gap remains in how to comprehensively evaluate these\nmodels' trustworthiness in real-world software engineering scenarios. Existing\nbenchmarks suffer from limited task scope and fail to incorporate critical\nevaluation aspects such as the robustness and reliability of models. To bridge\nthis gap, we present an evaluation framework called TREAT (Code LLMs\nTrustworthiness / Reliability Evaluation And Testing) that provides a holistic\nassessment of model performance in code intelligence tasks. Our evaluation\nframework addresses key limitations in existing approaches with four main\nimprovements: (1) Multi-Task Holistic Evaluation that spans diverse software\nengineering activities rather than limited coding tasks; (2) Multi-Language and\nMulti-Modality Assessment that extends beyond traditional single-language,\ntext-only benchmarks to include multi-modality coding tasks; (3) Robustness\nAssessment that evaluates model reliability under semantically-preserving code\ntransformations; and (4) Rigorous Evaluation Methodology that enhances the\ntrustworthiness of evaluation results through diverse evaluation prompts and\nadaptive solution extraction. Based on this evaluation framework, we assess 26\nstate-of-the-art models and uncover both their strengths and limitations,\nyielding several key insights:(1) Current models show substantial performance\nvariation across programming tasks; (2) Multi-modal language models demonstrate\nspecific performance limitations in UI code generation and edit;", "AI": {"tldr": "TREAT\u662f\u4e00\u4e2a\u8bc4\u4f30\u4ee3\u7801\u5927\u6a21\u578b\u53ef\u4fe1\u5ea6\u7684\u6846\u67b6\uff0c\u901a\u8fc7\u591a\u4efb\u52a1\u3001\u591a\u8bed\u8a00\u3001\u591a\u6a21\u6001\u548c\u9c81\u68d2\u6027\u8bc4\u4f30\u6765\u5168\u9762\u6d4b\u8bd5\u6a21\u578b\u5728\u8f6f\u4ef6\u5de5\u7a0b\u4efb\u52a1\u4e2d\u7684\u8868\u73b0\u3002", "motivation": "\u73b0\u6709\u57fa\u51c6\u6d4b\u8bd5\u5728\u8bc4\u4f30\u4ee3\u7801\u5927\u6a21\u578b\u53ef\u4fe1\u5ea6\u65b9\u9762\u5b58\u5728\u5c40\u9650\uff0c\u4efb\u52a1\u8303\u56f4\u6709\u9650\u4e14\u7f3a\u4e4f\u5bf9\u6a21\u578b\u9c81\u68d2\u6027\u548c\u53ef\u9760\u6027\u7684\u8bc4\u4f30\u3002", "method": "\u63d0\u51faTREAT\u8bc4\u4f30\u6846\u67b6\uff0c\u5305\u542b\u56db\u4e2a\u4e3b\u8981\u6539\u8fdb\uff1a\u591a\u4efb\u52a1\u7efc\u5408\u8bc4\u4f30\u3001\u591a\u8bed\u8a00\u591a\u6a21\u6001\u8bc4\u4f30\u3001\u9c81\u68d2\u6027\u8bc4\u4f30\u548c\u4e25\u8c28\u8bc4\u4f30\u65b9\u6cd5\u3002", "result": "\u8bc4\u4f30\u4e8626\u4e2a\u6700\u5148\u8fdb\u6a21\u578b\uff0c\u53d1\u73b0\u6a21\u578b\u5728\u4e0d\u540c\u7f16\u7a0b\u4efb\u52a1\u4e2d\u6027\u80fd\u5dee\u5f02\u663e\u8457\uff0c\u591a\u6a21\u6001\u6a21\u578b\u5728UI\u4ee3\u7801\u751f\u6210\u548c\u7f16\u8f91\u65b9\u9762\u5b58\u5728\u7279\u5b9a\u5c40\u9650\u6027\u3002", "conclusion": "TREAT\u6846\u67b6\u4e3a\u4ee3\u7801\u5927\u6a21\u578b\u7684\u53ef\u4fe1\u5ea6\u8bc4\u4f30\u63d0\u4f9b\u4e86\u66f4\u5168\u9762\u7684\u65b9\u6cd5\uff0c\u63ed\u793a\u4e86\u5f53\u524d\u6a21\u578b\u7684\u4f18\u52bf\u548c\u4e0d\u8db3\u3002"}}
{"id": "2510.17164", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.17164", "abs": "https://arxiv.org/abs/2510.17164", "authors": ["Maria Deolinda Santana", "Cleyton Magalhaes", "Ronnie de Souza Santos"], "title": "Software Testing with Large Language Models: An Interview Study with Practitioners", "comment": null, "summary": "\\textit{Background:} The use of large language models in software testing is\ngrowing fast as they support numerous tasks, from test case generation to\nautomation, and documentation. However, their adoption often relies on informal\nexperimentation rather than structured guidance. \\textit{Aims:} This study\ninvestigates how software testing professionals use LLMs in practice to propose\na preliminary, practitioner-informed guideline to support their integration\ninto testing workflows. \\textit{Method:} We conducted a qualitative study with\n15 software testers from diverse roles and domains. Data were collected through\nsemi-structured interviews and analyzed using grounded theory-based processes\nfocused on thematic analysis. \\textit{Results:} Testers described an iterative\nand reflective process that included defining testing objectives, applying\nprompt engineering strategies, refining prompts, evaluating outputs, and\nlearning over time. They emphasized the need for human oversight and careful\nvalidation, especially due to known limitations of LLMs such as hallucinations\nand inconsistent reasoning. \\textit{Conclusions:} LLM adoption in software\ntesting is growing, but remains shaped by evolving practices and caution around\nrisks. This study offers a starting point for structuring LLM use in testing\ncontexts and invites future research to refine these practices across teams,\ntools, and tasks.", "AI": {"tldr": "\u672c\u7814\u7a76\u901a\u8fc7\u5b9a\u6027\u8bbf\u8c08\u63d0\u51fa\u4e86\u8f6f\u4ef6\u6d4b\u8bd5\u4e2dLLM\u4f7f\u7528\u7684\u521d\u6b65\u6307\u5357\uff0c\u5f3a\u8c03\u8fed\u4ee3\u5f0f\u63d0\u793a\u5de5\u7a0b\u3001\u4eba\u5de5\u76d1\u7763\u548c\u9a8c\u8bc1\u7684\u91cd\u8981\u6027\u3002", "motivation": "\u968f\u7740\u5927\u8bed\u8a00\u6a21\u578b\u5728\u8f6f\u4ef6\u6d4b\u8bd5\u4e2d\u7684\u5feb\u901f\u5e94\u7528\uff0c\u76ee\u524d\u7f3a\u4e4f\u7ed3\u6784\u5316\u6307\u5bfc\uff0c\u4e3b\u8981\u4f9d\u8d56\u975e\u6b63\u5f0f\u5b9e\u9a8c\u3002\u672c\u7814\u7a76\u65e8\u5728\u4e86\u89e3\u6d4b\u8bd5\u4e13\u4e1a\u4eba\u5458\u5982\u4f55\u5b9e\u9645\u4f7f\u7528LLM\uff0c\u4e3a\u96c6\u6210\u5230\u6d4b\u8bd5\u5de5\u4f5c\u6d41\u63d0\u4f9b\u5b9e\u8df5\u6307\u5bfc\u3002", "method": "\u5bf915\u540d\u6765\u81ea\u4e0d\u540c\u89d2\u8272\u548c\u9886\u57df\u7684\u8f6f\u4ef6\u6d4b\u8bd5\u4eba\u5458\u8fdb\u884c\u534a\u7ed3\u6784\u5316\u8bbf\u8c08\uff0c\u4f7f\u7528\u57fa\u4e8e\u624e\u6839\u7406\u8bba\u7684\u4e3b\u9898\u5206\u6790\u65b9\u6cd5\u3002", "result": "\u6d4b\u8bd5\u4eba\u5458\u63cf\u8ff0\u4e86\u5305\u62ec\u5b9a\u4e49\u6d4b\u8bd5\u76ee\u6807\u3001\u5e94\u7528\u63d0\u793a\u5de5\u7a0b\u7b56\u7565\u3001\u4f18\u5316\u63d0\u793a\u3001\u8bc4\u4f30\u8f93\u51fa\u548c\u6301\u7eed\u5b66\u4e60\u7684\u8fed\u4ee3\u53cd\u601d\u8fc7\u7a0b\uff0c\u5f3a\u8c03\u9700\u8981\u4eba\u5de5\u76d1\u7763\u548c\u4ed4\u7ec6\u9a8c\u8bc1\u3002", "conclusion": "LLM\u5728\u8f6f\u4ef6\u6d4b\u8bd5\u4e2d\u7684\u5e94\u7528\u6b63\u5728\u589e\u957f\uff0c\u4f46\u4ecd\u53d7\u5230\u5b9e\u8df5\u6f14\u53d8\u548c\u5bf9\u98ce\u9669\u8c28\u614e\u6001\u5ea6\u7684\u5f71\u54cd\u3002\u672c\u7814\u7a76\u4e3a\u7ed3\u6784\u5316\u4f7f\u7528LLM\u63d0\u4f9b\u4e86\u8d77\u70b9\uff0c\u5e76\u9080\u8bf7\u672a\u6765\u7814\u7a76\u8fdb\u4e00\u6b65\u5b8c\u5584\u5b9e\u8df5\u3002"}}
{"id": "2510.17184", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.17184", "abs": "https://arxiv.org/abs/2510.17184", "authors": ["Nicolas Robert", "Fabien Gandon", "Maxime Lefran\u00e7ois"], "title": "OLIVAW: ACIMOV's GitHub robot assisting agile collaborative ontology development", "comment": null, "summary": "Agile and collaborative approaches to ontologies design are crucial because\nthey contribute to making them userdriven, up-to-date, and able to evolve\nalongside the systems they support, hence proper continuous validation tooling\nis required to ensure ontologies match developers' requirements all along their\ndevelopment. We propose OLIVAW (Ontology Long-lived Integration Via ACIMOV\nWorkflow), a tool supporting the ACIMOV methodology on GitHub. It relies on W3C\nStandards to assist the development of modular ontologies through GitHub\nComposite Actions, pre-commit hooks, or a command line interface. OLIVAW was\ntested on several ontology projects to ensure its usefulness, genericity and\nreusability. A template repository is available for a quick start. OLIVAW is", "AI": {"tldr": "OLIVAW\u662f\u4e00\u4e2a\u652f\u6301ACIMOV\u65b9\u6cd5\u8bba\u7684GitHub\u5de5\u5177\uff0c\u7528\u4e8e\u654f\u6377\u534f\u4f5c\u5f0f\u672c\u4f53\u5f00\u53d1\uff0c\u901a\u8fc7W3C\u6807\u51c6\u5e2e\u52a9\u5f00\u53d1\u6a21\u5757\u5316\u672c\u4f53\u3002", "motivation": "\u654f\u6377\u534f\u4f5c\u7684\u672c\u4f53\u8bbe\u8ba1\u65b9\u6cd5\u5bf9\u4e8e\u786e\u4fdd\u672c\u4f53\u7528\u6237\u9a71\u52a8\u3001\u4fdd\u6301\u66f4\u65b0\u5e76\u968f\u7cfb\u7edf\u6f14\u8fdb\u81f3\u5173\u91cd\u8981\uff0c\u56e0\u6b64\u9700\u8981\u6301\u7eed\u9a8c\u8bc1\u5de5\u5177\u6765\u4fdd\u8bc1\u672c\u4f53\u59cb\u7ec8\u7b26\u5408\u5f00\u53d1\u8005\u9700\u6c42\u3002", "method": "OLIVAW\u57fa\u4e8eW3C\u6807\u51c6\uff0c\u901a\u8fc7GitHub Composite Actions\u3001\u9884\u63d0\u4ea4\u94a9\u5b50\u6216\u547d\u4ee4\u884c\u754c\u9762\u6765\u652f\u6301\u6a21\u5757\u5316\u672c\u4f53\u7684\u5f00\u53d1\u3002", "result": "OLIVAW\u5728\u591a\u4e2a\u672c\u4f53\u9879\u76ee\u4e2d\u8fdb\u884c\u4e86\u6d4b\u8bd5\uff0c\u8bc1\u660e\u4e86\u5176\u6709\u7528\u6027\u3001\u901a\u7528\u6027\u548c\u53ef\u91cd\u7528\u6027\uff0c\u5e76\u63d0\u4f9b\u4e86\u6a21\u677f\u4ed3\u5e93\u4ee5\u4fbf\u5feb\u901f\u4e0a\u624b\u3002", "conclusion": "OLIVAW\u662f\u4e00\u4e2a\u6709\u6548\u7684\u5de5\u5177\uff0c\u652f\u6301\u5728GitHub\u4e0a\u8fdb\u884c\u654f\u6377\u534f\u4f5c\u7684\u672c\u4f53\u5f00\u53d1\uff0c\u786e\u4fdd\u672c\u4f53\u8d28\u91cf\u5e76\u4fc3\u8fdb\u5176\u6301\u7eed\u6f14\u8fdb\u3002"}}
{"id": "2510.17376", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.17376", "abs": "https://arxiv.org/abs/2510.17376", "authors": ["Yongmin Li", "Jia Li", "Ge Li", "Zhi Jin"], "title": "AdapTrack: Constrained Decoding without Distorting LLM's Output Intent", "comment": "to be published in ICSE 2026", "summary": "Language model-based code generation and completion tools have been widely\nadopted, but they may sometimes produce code that does not meet necessary\nconstraints, such as syntactic correctness or API existence. Constrained\ndecoding techniques are developed to help the model generate code adhering to\nthe constraints by greedily eliminating generation options that violate\nconstraints at each step of the generation process. However, there is a severe\nlimitation of constrained decoding, that it distorts the model's output intent,\nforcing it to produce code that may satisfy the constraint but does not match\nthe development intent and is therefore incorrect. In response to this\nchallenge, we propose AdapTrack. By incorporating backtracking into the\ngeneration process, AdapTrack avoids distorting the output intent of the model,\nthereby producing results that are not only constraint-compliant but also more\nsemantically aligned with model's output intent. On our synthetic API\ncompletion dataset, AdapTrack can achieve up to 360.87% improvement compared to\nconstrained decoding; on the real-world API completion dataset we collect that\nexhibits similar issues, AdapTrack can achieve up to 38.93% improvement over\nconstrained decoding; in general code genration benchmarks, compared to\nconstrained decoding, AdapTrack can achieve up to 7.84% improvement on\nHumanEval, and up to 6.42% improvement on MBPP. This indicates that, simply by\nbetter adhering to the model's output intent, AdapTrack can achieve significant\nimprovements. We provide a theoretical proof that the distribution produced by\nAdapTrack aligns with the model's distribution given the generated tokens,\nthereby ensuring that the model's output intent is not distorted. Experiments\non DSL problems show that, compared to existing methods, our approach can\nprovide generation results that are more consistent with the language model's\ndistribution.", "AI": {"tldr": "AdapTrack\u662f\u4e00\u79cd\u6539\u8fdb\u7684\u7ea6\u675f\u89e3\u7801\u65b9\u6cd5\uff0c\u901a\u8fc7\u5f15\u5165\u56de\u6eaf\u673a\u5236\u907f\u514d\u626d\u66f2\u8bed\u8a00\u6a21\u578b\u7684\u8f93\u51fa\u610f\u56fe\uff0c\u5728\u4fdd\u6301\u7ea6\u675f\u5408\u89c4\u7684\u540c\u65f6\u66f4\u597d\u5730\u4e0e\u6a21\u578b\u8bed\u4e49\u5bf9\u9f50\u3002", "motivation": "\u4f20\u7edf\u7684\u7ea6\u675f\u89e3\u7801\u6280\u672f\u867d\u7136\u80fd\u786e\u4fdd\u751f\u6210\u7684\u4ee3\u7801\u6ee1\u8db3\u7ea6\u675f\u6761\u4ef6\uff0c\u4f46\u4f1a\u626d\u66f2\u6a21\u578b\u7684\u8f93\u51fa\u610f\u56fe\uff0c\u5bfc\u81f4\u751f\u6210\u7684\u4ee3\u7801\u867d\u7136\u7b26\u5408\u7ea6\u675f\u4f46\u4e0d\u6b63\u786e\u3002", "method": "AdapTrack\u5728\u751f\u6210\u8fc7\u7a0b\u4e2d\u5f15\u5165\u56de\u6eaf\u673a\u5236\uff0c\u907f\u514d\u5f3a\u5236\u6a21\u578b\u9009\u62e9\u8fdd\u53cd\u5176\u610f\u56fe\u7684\u9009\u9879\uff0c\u786e\u4fdd\u751f\u6210\u7684\u4ee3\u7801\u65e2\u6ee1\u8db3\u7ea6\u675f\u53c8\u7b26\u5408\u6a21\u578b\u8bed\u4e49\u3002", "result": "\u5728API\u8865\u5168\u6570\u636e\u96c6\u4e0a\uff0cAdapTrack\u76f8\u6bd4\u7ea6\u675f\u89e3\u7801\u63d0\u5347360.87%\uff1b\u5728\u771f\u5b9eAPI\u8865\u5168\u6570\u636e\u96c6\u4e0a\u63d0\u534738.93%\uff1b\u5728HumanEval\u548cMBPP\u57fa\u51c6\u6d4b\u8bd5\u4e2d\u5206\u522b\u63d0\u53477.84%\u548c6.42%\u3002", "conclusion": "AdapTrack\u901a\u8fc7\u66f4\u597d\u5730\u9075\u5faa\u6a21\u578b\u8f93\u51fa\u610f\u56fe\uff0c\u5728\u4fdd\u6301\u7ea6\u675f\u5408\u89c4\u7684\u540c\u65f6\u663e\u8457\u63d0\u5347\u4ee3\u7801\u751f\u6210\u8d28\u91cf\uff0c\u7406\u8bba\u8bc1\u660e\u5176\u5206\u5e03\u4e0e\u6a21\u578b\u5206\u5e03\u4e00\u81f4\u3002"}}
{"id": "2510.17430", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.17430", "abs": "https://arxiv.org/abs/2510.17430", "authors": ["Kuniaki Kudo", "Sherine Devi"], "title": "Scalable CI/CD for Legacy Modernization: An Industrial Experience Addressing Internal Challenges Related to the 2025 Japan Cliff", "comment": null, "summary": "We have developed a Scalable CI/CD Pipeline to address internal challenges\nrelated to Japan 2025 cliff problem, a critical issue where the mass end of\nservice life of legacy core IT systems threatens to significantly increase the\nmaintenance cost and black box nature of these system also leads to difficult\nupdate moreover replace, which leads to lack of progress in Digital\nTransformation (DX). If not addressed, Japan could potentially lose up to 12\ntrillion yen per year after 2025, which is 3 times more than the cost in\nprevious years. Asahi also faced the same internal challenges regarding legacy\nsystem, where manual maintenance workflows and limited QA environment have left\ncritical systems outdated and difficult to update. Middleware and OS version\nhave remained unchanged for years, leading to now its nearing end of service\nlife which require huge maintenance cost and effort to continue its operation.\nTo address this problem, we have developed and implemented a Scalable CI/CD\nPipeline where isolated development environments can be created and deleted\ndynamically and is scalable as needed. This Scalable CI/CD Pipeline incorporate\nGitHub for source code control and branching, Jenkins for pipeline automation,\nAmazon Web Services for scalable environment, and Docker for environment\ncontainerization. This paper presents the design and architecture of the\nScalable CI/CD Pipeline, with the implementation along with some use cases.\nThrough Scalable CI/CD, developers can freely and safely test maintenance\nprocedures and do experiments with new technology in their own environment,\nreducing maintenance cost and drive Digital Transformation (DX).\n  key words: 2025 Japan Cliff, Scalable CI/CD, DevOps, Legacy IT Modernization.", "AI": {"tldr": "\u5f00\u53d1\u4e86\u53ef\u6269\u5c55\u7684CI/CD\u6d41\u6c34\u7ebf\u6765\u89e3\u51b3\u65e5\u672c2025\u5e74\u60ac\u5d16\u95ee\u9898\uff0c\u901a\u8fc7\u52a8\u6001\u521b\u5efa\u9694\u79bb\u5f00\u53d1\u73af\u5883\u6765\u964d\u4f4e\u9057\u7559IT\u7cfb\u7edf\u7684\u7ef4\u62a4\u6210\u672c\u5e76\u63a8\u52a8\u6570\u5b57\u5316\u8f6c\u578b\u3002", "motivation": "\u65e5\u672c\u9762\u4e342025\u5e74\u60ac\u5d16\u95ee\u9898\uff0c\u5927\u91cf\u9057\u7559\u6838\u5fc3IT\u7cfb\u7edf\u5373\u5c06\u8fbe\u5230\u670d\u52a1\u5bff\u547d\u7ec8\u70b9\uff0c\u5bfc\u81f4\u7ef4\u62a4\u6210\u672c\u6fc0\u589e\u548c\u6570\u5b57\u5316\u8f6c\u578b\u53d7\u963b\u3002\u671d\u65e5\u516c\u53f8\u4e5f\u9762\u4e34\u7c7b\u4f3c\u6311\u6218\uff0c\u624b\u52a8\u7ef4\u62a4\u6d41\u7a0b\u548c\u6709\u9650\u7684QA\u73af\u5883\u4f7f\u5173\u952e\u7cfb\u7edf\u96be\u4ee5\u66f4\u65b0\u3002", "method": "\u8bbe\u8ba1\u5e76\u5b9e\u65bd\u4e86\u53ef\u6269\u5c55\u7684CI/CD\u6d41\u6c34\u7ebf\uff0c\u6574\u5408GitHub\u8fdb\u884c\u6e90\u4ee3\u7801\u63a7\u5236\u3001Jenkins\u5b9e\u73b0\u6d41\u6c34\u7ebf\u81ea\u52a8\u5316\u3001AWS\u63d0\u4f9b\u53ef\u6269\u5c55\u73af\u5883\u3001Docker\u5b9e\u73b0\u73af\u5883\u5bb9\u5668\u5316\uff0c\u652f\u6301\u52a8\u6001\u521b\u5efa\u548c\u5220\u9664\u9694\u79bb\u5f00\u53d1\u73af\u5883\u3002", "result": "\u901a\u8fc7\u53ef\u6269\u5c55CI/CD\u6d41\u6c34\u7ebf\uff0c\u5f00\u53d1\u4eba\u5458\u53ef\u4ee5\u5728\u81ea\u5df1\u7684\u73af\u5883\u4e2d\u81ea\u7531\u5b89\u5168\u5730\u6d4b\u8bd5\u7ef4\u62a4\u7a0b\u5e8f\u548c\u5b9e\u9a8c\u65b0\u6280\u672f\uff0c\u663e\u8457\u964d\u4f4e\u4e86\u7ef4\u62a4\u6210\u672c\u3002", "conclusion": "\u53ef\u6269\u5c55CI/CD\u6d41\u6c34\u7ebf\u6709\u6548\u89e3\u51b3\u4e86\u9057\u7559IT\u7cfb\u7edf\u73b0\u4ee3\u5316\u95ee\u9898\uff0c\u4e3a\u5e94\u5bf9\u65e5\u672c2025\u5e74\u60ac\u5d16\u95ee\u9898\u63d0\u4f9b\u4e86\u53ef\u884c\u65b9\u6848\uff0c\u63a8\u52a8\u4e86\u6570\u5b57\u5316\u8f6c\u578b\u8fdb\u7a0b\u3002"}}

{"id": "2601.15455", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2601.15455", "abs": "https://arxiv.org/abs/2601.15455", "authors": ["Patrycja Balik", "Szymon J\u0119dras", "Piotr Polesiuk"], "title": "Remarks on Algebraic Reconstruction of Types and Effects", "comment": null, "summary": "In their 1991 paper \"Algebraic Reconstruction of Types and Effects,\" Pierre Jouvelot and David Gifford presented a type-and-effect reconstruction algorithm based on an algebraic structure of effects. Their work is considered a milestone in the development of type-and-effect systems, and has inspired numerous subsequent works in the area of static analysis. However, unlike the later research it spawned, the original algorithm considered a language with higher-rank polymorphism, a feature which is challenging to implement correctly. In this note, we identify subtle bugs related to variable binding in their approach to this feature. We revisit their type system and reconstruction algorithm, and describe the discovered issues.", "AI": {"tldr": "\u8be5\u8bba\u6587\u6307\u51faJouvelot\u548cGifford 1991\u5e74\u5f00\u521b\u6027\u7c7b\u578b\u4e0e\u6548\u5e94\u91cd\u5efa\u7b97\u6cd5\u4e2d\u5b58\u5728\u4e0e\u9ad8\u9636\u591a\u6001\u6027\u76f8\u5173\u7684\u53d8\u91cf\u7ed1\u5b9a\u9519\u8bef\uff0c\u5e76\u91cd\u65b0\u5ba1\u89c6\u4e86\u5176\u7c7b\u578b\u7cfb\u7edf\u548c\u91cd\u5efa\u7b97\u6cd5\u3002", "motivation": "Jouvelot\u548cGifford 1991\u5e74\u7684\u8bba\u6587\u300aAlgebraic Reconstruction of Types and Effects\u300b\u662f\u7c7b\u578b\u4e0e\u6548\u5e94\u7cfb\u7edf\u53d1\u5c55\u7684\u91cd\u8981\u91cc\u7a0b\u7891\uff0c\u542f\u53d1\u4e86\u540e\u7eed\u5927\u91cf\u9759\u6001\u5206\u6790\u7814\u7a76\u3002\u7136\u800c\uff0c\u4e0e\u540e\u6765\u7814\u7a76\u4e0d\u540c\uff0c\u539f\u59cb\u7b97\u6cd5\u8003\u8651\u4e86\u5177\u6709\u9ad8\u9636\u591a\u6001\u6027\u7684\u8bed\u8a00\uff0c\u8fd9\u4e00\u7279\u6027\u5b9e\u73b0\u6b63\u786e\u6027\u5177\u6709\u6311\u6218\u6027\u3002\u4f5c\u8005\u53d1\u73b0\u539f\u59cb\u65b9\u6cd5\u5728\u8be5\u7279\u6027\u5904\u7406\u4e0a\u5b58\u5728\u5fae\u5999\u7684\u53d8\u91cf\u7ed1\u5b9a\u9519\u8bef\u3002", "method": "\u91cd\u65b0\u5ba1\u89c6Jouvelot\u548cGifford\u7684\u7c7b\u578b\u7cfb\u7edf\u548c\u91cd\u5efa\u7b97\u6cd5\uff0c\u8bc6\u522b\u5e76\u63cf\u8ff0\u4e0e\u9ad8\u9636\u591a\u6001\u6027\u76f8\u5173\u7684\u53d8\u91cf\u7ed1\u5b9a\u95ee\u9898\u3002\u5177\u4f53\u5206\u6790\u4e86\u539f\u59cb\u7b97\u6cd5\u5728\u5904\u7406\u9ad8\u9636\u591a\u6001\u6027\u65f6\u5b58\u5728\u7684\u5fae\u5999\u9519\u8bef\u3002", "result": "\u53d1\u73b0\u4e86\u539f\u59cb\u7c7b\u578b\u4e0e\u6548\u5e94\u91cd\u5efa\u7b97\u6cd5\u4e2d\u4e0e\u9ad8\u9636\u591a\u6001\u6027\u76f8\u5173\u7684\u53d8\u91cf\u7ed1\u5b9a\u9519\u8bef\u3002\u8fd9\u4e9b\u9519\u8bef\u5728\u539f\u59cb\u8bba\u6587\u4e2d\u672a\u88ab\u8bc6\u522b\uff0c\u53ef\u80fd\u5f71\u54cd\u7b97\u6cd5\u7684\u6b63\u786e\u5b9e\u73b0\u3002", "conclusion": "\u867d\u7136Jouvelot\u548cGifford\u7684\u5f00\u521b\u6027\u5de5\u4f5c\u4e3a\u7c7b\u578b\u4e0e\u6548\u5e94\u7cfb\u7edf\u5960\u5b9a\u4e86\u57fa\u7840\uff0c\u4f46\u539f\u59cb\u7b97\u6cd5\u5728\u5904\u7406\u9ad8\u9636\u591a\u6001\u6027\u65f6\u5b58\u5728\u5fae\u5999\u7684\u53d8\u91cf\u7ed1\u5b9a\u9519\u8bef\u3002\u8fd9\u4e9b\u53d1\u73b0\u6709\u52a9\u4e8e\u66f4\u51c6\u786e\u5730\u7406\u89e3\u548c\u5b9e\u73b0\u7c7b\u578b\u4e0e\u6548\u5e94\u91cd\u5efa\u7b97\u6cd5\uff0c\u7279\u522b\u662f\u5bf9\u4e8e\u5177\u6709\u9ad8\u9636\u591a\u6001\u6027\u7684\u8bed\u8a00\u3002"}}
{"id": "2601.16008", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2601.16008", "abs": "https://arxiv.org/abs/2601.16008", "authors": ["Federico Bruzzone", "Walter Cazzola", "Luca Favini"], "title": "Prioritizing Configuration Relevance via Compiler-Based Refined Feature Ranking", "comment": "29 pages 4 figures", "summary": "Modern programming languages, most notably Rust, offer advanced linguistic constructs for building highly configurable software systems as aggregation of features -- identified by a configuration. However, they pose substantial challenges for program analysis, optimization, and testing, as the combinatorial explosion of configurations often makes exhaustive exploration infeasible. In this manuscript, we present the first compiler-based method for prioritizing configurations. Our approach consists of four main steps: 1. extracting a tailored intermediate representation from the Rust compiler, 2. constructing two complementary graph-based data structures, 3. using centrality measures to rank features, and 4. refining the ranking by considering the extent of code they impact. A fixed number of most relevant configurations are generated based on the achieved feature ranking. The validity of the generated configurations is guaranteed by using a SAT solver that takes a representation of this graph in conjunctive normal form. We formalized this approach and implemented it in a prototype, RustyEx, by instrumenting the Rust compiler. An empirical evaluation on higher-ranked open source Rust projects shows that RustyEx efficiently generates user-specified sets of configurations within bounded resources, while ensuring soundness by construction. The results demonstrate that centrality-guided configuration prioritization enables effective and practical exploration of large configuration spaces, paving the way for future research in configuration-aware analysis and optimization.", "AI": {"tldr": "\u63d0\u51fa\u9996\u4e2a\u57fa\u4e8e\u7f16\u8bd1\u5668\u7684Rust\u914d\u7f6e\u4f18\u5148\u7ea7\u6392\u5e8f\u65b9\u6cd5\uff0c\u901a\u8fc7\u56fe\u4e2d\u5fc3\u6027\u5ea6\u91cf\u5bf9\u7279\u5f81\u6392\u5e8f\uff0c\u751f\u6210\u6709\u9650\u6570\u91cf\u7684\u76f8\u5173\u914d\u7f6e\uff0c\u89e3\u51b3\u914d\u7f6e\u7a7a\u95f4\u7ec4\u5408\u7206\u70b8\u95ee\u9898\u3002", "motivation": "\u73b0\u4ee3\u7f16\u7a0b\u8bed\u8a00\uff08\u7279\u522b\u662fRust\uff09\u63d0\u4f9b\u4e86\u6784\u5efa\u9ad8\u5ea6\u53ef\u914d\u7f6e\u8f6f\u4ef6\u7cfb\u7edf\u7684\u8bed\u8a00\u6784\u9020\uff0c\u4f46\u914d\u7f6e\u7684\u7ec4\u5408\u7206\u70b8\u4f7f\u5f97\u7a0b\u5e8f\u5206\u6790\u3001\u4f18\u5316\u548c\u6d4b\u8bd5\u7684\u7a77\u4e3e\u63a2\u7d22\u4e0d\u53ef\u884c\uff0c\u9700\u8981\u6709\u6548\u7684\u914d\u7f6e\u4f18\u5148\u7ea7\u6392\u5e8f\u65b9\u6cd5\u3002", "method": "\u65b9\u6cd5\u5305\u62ec\u56db\u4e2a\u4e3b\u8981\u6b65\u9aa4\uff1a1.\u4eceRust\u7f16\u8bd1\u5668\u63d0\u53d6\u5b9a\u5236\u7684\u4e2d\u95f4\u8868\u793a\uff1b2.\u6784\u5efa\u4e24\u4e2a\u4e92\u8865\u7684\u57fa\u4e8e\u56fe\u7684\u6570\u636e\u7ed3\u6784\uff1b3.\u4f7f\u7528\u4e2d\u5fc3\u6027\u5ea6\u91cf\u5bf9\u7279\u5f81\u8fdb\u884c\u6392\u5e8f\uff1b4.\u901a\u8fc7\u8003\u8651\u7279\u5f81\u5f71\u54cd\u7684\u4ee3\u7801\u8303\u56f4\u6765\u7ec6\u5316\u6392\u5e8f\u3002\u4f7f\u7528SAT\u6c42\u89e3\u5668\u4fdd\u8bc1\u751f\u6210\u914d\u7f6e\u7684\u6709\u6548\u6027\uff0c\u5e76\u5728\u539f\u578bRustyEx\u4e2d\u5b9e\u73b0\u3002", "result": "\u5728\u5f00\u6e90Rust\u9879\u76ee\u4e0a\u7684\u5b9e\u8bc1\u8bc4\u4f30\u8868\u660e\uff0cRustyEx\u80fd\u591f\u5728\u6709\u9650\u8d44\u6e90\u5185\u9ad8\u6548\u751f\u6210\u7528\u6237\u6307\u5b9a\u7684\u914d\u7f6e\u96c6\uff0c\u540c\u65f6\u901a\u8fc7\u6784\u9020\u4fdd\u8bc1\u6b63\u786e\u6027\u3002\u4e2d\u5fc3\u6027\u5f15\u5bfc\u7684\u914d\u7f6e\u4f18\u5148\u7ea7\u6392\u5e8f\u5b9e\u73b0\u4e86\u5927\u578b\u914d\u7f6e\u7a7a\u95f4\u7684\u6709\u6548\u5b9e\u7528\u63a2\u7d22\u3002", "conclusion": "\u8be5\u65b9\u6cd5\u4e3a\u914d\u7f6e\u611f\u77e5\u5206\u6790\u548c\u4f18\u5316\u94fa\u5e73\u4e86\u9053\u8def\uff0c\u8bc1\u660e\u4e86\u57fa\u4e8e\u56fe\u4e2d\u5fc3\u6027\u7684\u914d\u7f6e\u4f18\u5148\u7ea7\u6392\u5e8f\u5728\u5b9e\u8df5\u4e2d\u7684\u6709\u6548\u6027\uff0c\u80fd\u591f\u5904\u7406Rust\u7b49\u8bed\u8a00\u4e2d\u914d\u7f6e\u7a7a\u95f4\u7684\u7ec4\u5408\u7206\u70b8\u95ee\u9898\u3002"}}

<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 1]
- [cs.SE](#cs.SE) [Total: 22]
- [cs.LO](#cs.LO) [Total: 1]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Sharing State Between Prompts and Programs](https://arxiv.org/abs/2512.14805)
*Ellie Y. Cheng,Logan Weber,Tian Jin,Michael Carbin*

Main category: cs.PL

TL;DR: Nightjar编程系统引入共享程序状态抽象，让自然语言代码能直接操作Python程序变量，实现自然语言编程与形式语言的互操作性，减少代码量但可能增加运行时开销。


<details>
  <summary>Details</summary>
Motivation: 大型语言模型兴起带来了自然语言编程，但自然语言代码与形式语言（如Python）之间的互操作性需要大量手动工作。研究者希望消除这种障碍，让自然语言代码能直接操作程序状态。

Method: 提出共享程序状态编程抽象，通过自然函数接口模式扩展编程系统以支持自然代码。在Nightjar系统中实现该抽象，使Python程序能包含直接共享Python程序状态的自然语言代码。

Result: Nightjar程序相比手动实现的任务准确率相当或更高（+4-19%），平均减少39.6%的代码行数。代价是可能产生运行时开销（手动实现的0.4-4.3倍）。

Conclusion: 共享程序状态抽象有效实现了自然语言代码与形式语言的互操作性，显著减少编程工作量，为自然语言编程提供了实用框架，尽管存在运行时开销的权衡。

Abstract: The rise of large language models (LLMs) has introduced a new type of programming: natural language programming. By writing prompts that direct LLMs to perform natural language processing, code generation, reasoning, etc., users are writing code in natural language -- natural language code -- for the LLM to execute.
  An emerging area of research enables interoperability between natural language code and formal languages such as Python. We present a novel programming abstraction, shared program state, that removes the manual work required to enable interoperability between natural language code and program state. With shared program state, programmers can write natural code that directly writes program variables, computes with program objects, and implements control flow in the program. We present a schema for specifying natural function interfaces that extend programming systems to support natural code and leverage this schema to specify shared program state as a natural function interface.
  We implement shared program state in the Nightjar programming system. Nightjar enables programmers to write Python programs that contain natural code that shares the Python program state. We show that Nightjar programs achieve comparable or higher task accuracy than manually written implementations (+4-19%), while decreasing the lines of code by 39.6% on average. The tradeoff to using Nightjar is that it may incur runtime overhead (0.4-4.3x runtime of manual implementations).

</details>


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [2] [How Deep Does Your Dependency Tree Go? An Empirical Study of Dependency Amplification Across 10 Package Ecosystems](https://arxiv.org/abs/2512.14739)
*Jahidul Arafat*

Main category: cs.SE

TL;DR: 对10个主流软件包生态系统的依赖放大效应进行大规模实证研究，发现Maven的依赖放大效应最高（平均24.7倍），远高于其他生态系统，挑战了npm依赖放大最高的传统认知。


<details>
  <summary>Details</summary>
Motivation: 软件包生态系统中的依赖放大（传递依赖与直接依赖的比率）对软件供应链安全有重大影响，但不同生态系统间的放大模式尚未进行大规模比较研究。

Method: 对10个主要生态系统（Maven、npm、Cargo、PyPI、NuGet、RubyGems、Go Modules、Packagist、CocoaPods、Pub）的500个项目进行实证分析，比较依赖放大效应。

Result: Maven平均放大24.70倍，Go Modules 4.48倍，npm 4.32倍，CocoaPods仅0.32倍。45对比较中有22对存在显著差异且效应量大。28%的Maven项目放大超过10倍，而Cargo、PyPI等生态系统为零。

Conclusion: 依赖放大差异源于生态系统设计选择（依赖解析行为、标准库完备性、平台约束）。建议采用生态系统特定的安全策略：Maven需要系统审计，npm和RubyGems需要针对性异常检测，放大受控的生态系统可延续当前实践。

Abstract: Modern software development relies on package ecosystems where a single declared dependency can pull in many additional transitive packages. This dependency amplification, defined as the ratio of transitive to direct dependencies, has major implications for software supply chain security, yet amplification patterns across ecosystems have not been compared at scale. We present an empirical study of 500 projects across ten major ecosystems, including Maven Central for Java, npm Registry for JavaScript, crates io for Rust, PyPI for Python, NuGet Gallery for dot NET, RubyGems for Ruby, Go Modules for Go, Packagist for PHP, CocoaPods for Swift and Objective C, and Pub for Dart. Our analysis shows that Maven exhibits mean amplification of 24.70 times, compared to 4.48 times for Go Modules, 4.32 times for npm, and 0.32 times for CocoaPods. We find significant differences with large effect sizes in 22 of 45 pairwise comparisons, challenging the assumption that npm has the highest amplification due to its many small purpose packages. We observe that 28 percent of Maven projects exceed 10 times amplification, indicating a systematic pattern rather than isolated outliers, compared to 14 percent for RubyGems, 12 percent for npm, and zero percent for Cargo, PyPI, Packagist, CocoaPods, and Pub. We attribute these differences to ecosystem design choices such as dependency resolution behavior, standard library completeness, and platform constraints. Our findings suggest adopting ecosystem specific security strategies, including systematic auditing for Maven environments, targeted outlier detection for npm and RubyGems, and continuation of current practices for ecosystems with controlled amplification. We provide a full replication package with data and analysis scripts.

</details>


### [3] [A High-level Synthesis Toolchain for the Julia Language](https://arxiv.org/abs/2512.15679)
*Benedict Short,Ian McInerney,John Wickerson*

Main category: cs.SE

TL;DR: 提出基于MLIR的Julia到SystemVerilog编译器工具链，解决FPGA特定加速器开发中的"双语言问题"，让领域专家能用Julia编写计算内核并自动生成FPGA代码。


<details>
  <summary>Details</summary>
Motivation: 随着Exascale计算和数据驱动方法的发展，问题规模急剧增加，需要将计算卸载到GPU/TPU等硬件加速器，或使用FPGA设计特定问题加速器。但当前特定加速器开发存在"双语言问题"：算法用高级语言开发，内核却需要用完全不同抽象级别的语言实现，需要不同专业知识。

Method: 提出基于MLIR的编译器工具链，自动将Julia编程语言编写的内核编译为SystemVerilog，无需额外指令或语言定制。支持动态和静态调度，直接集成AXI4-Stream协议与子系统接口，生成供应商无关的RTL。

Result: 原型工具链能够合成一组信号处理/数学基准测试，在实际FPGA设备上以100MHz运行，达到仅从C/C++等低级语言编译的最先进工具链生成的设计的59.71%至82.6%吞吐量。

Conclusion: 该工具链允许领域专家像平常一样用Julia编写计算内核，然后将其重定向到FPGA，无需额外pragma或修改，解决了特定问题加速器开发的"双语言问题"。

Abstract: With the push towards Exascale computing and data-driven methods, problem sizes have increased dramatically, increasing the computational requirements of the underlying algorithms. This has led to a push to offload computations to general purpose hardware accelerators such as GPUs and TPUs, and a renewed interest in designing problem-specific accelerators using FPGAs. However, the development process of these problem-specific accelerators currently suffers from the "two-language problem": algorithms are developed in one (usually higher-level) language, but the kernels are implemented in another language at a completely different level of abstraction and requiring fundamentally different expertise. To address this problem, we propose a new MLIR-based compiler toolchain that unifies the development process by automatically compiling kernels written in the Julia programming language into SystemVerilog without the need for any additional directives or language customisations. Our toolchain supports both dynamic and static scheduling, directly integrates with the AXI4-Stream protocol to interface with subsystems like on- and off-chip memory, and generates vendor-agnostic RTL. This prototype toolchain is able to synthesize a set of signal processing/mathematical benchmarks that can operate at 100MHz on real FPGA devices, achieving between 59.71% and 82.6% of the throughput of designs generated by state-of-the-art toolchains that only compile from low-level languages like C or C++. Overall, this toolchain allows domain experts to write compute kernels in Julia as they normally would, and then retarget them to an FPGA without additional pragmas or modifications.

</details>


### [4] [VDMN: A Graphical Notation for Modelling Value Driver Trees](https://arxiv.org/abs/2512.14740)
*Benjamin Matthies*

Main category: cs.SE

TL;DR: 本文提出了价值驱动建模符号（VDMN），一种用于系统化价值驱动树建模的图形化符号，填补了该领域缺乏系统建模指南的空白。


<details>
  <summary>Details</summary>
Motivation: 价值驱动树（VDTs）是用于说明和分析关键绩效指标与业务结果之间因果关系的概念模型，但缺乏系统化的建模指南。本研究旨在填补这一空白。

Method: 开发了价值驱动建模符号（VDMN），包含全面的语义构造和直观的图形语法。通过两个案例研究和专家访谈来评估其实用性。

Result: VDMN支持一致且易于理解的价值驱动树建模。专家评估表明该符号在实践中有用，是VDT建模系统化和标准化的重要进展。

Conclusion: VDMN为价值驱动树建模提供了系统化的图形符号，推动了该领域的标准化进程，有助于支持管理决策和价值管理。

Abstract: Value Driver Trees (VDTs) are conceptual models used to illustrate and analyse the causal relationships between key performance indicators and business outcomes, thereby supporting managerial decision-making and value-based management. Despite their increasing application, there are still no systematic guidelines for the modelling of such conceptual models. To fill this gap, this study introduces the Value Driver Modelling Notation (VDMN), a graphical notation developed to systematically guide VDT modelling. This notation includes a comprehensive set of semantic constructs and an intuitive graphical syntax. To evaluate its practical utility, the VDMN was applied in two case studies and assessed through expert interviews. The results show that the notation supports a consistent and comprehensible modelling of VDTs. The VDMN thus represents a significant step towards the systematisation and standardisation of VDT modelling.

</details>


### [5] [Revisiting the Reliability of Language Models in Instruction-Following](https://arxiv.org/abs/2512.14754)
*Jianshuo Dong,Yutong Zhang,Yan Liu,Zhenyu Zhong,Tao Wei,Chao Zhang,Han Qiu*

Main category: cs.SE

TL;DR: 论文提出"细微差别导向的可靠性"概念，发现当前LLMs在面对表达相同意图但存在细微差别的提示词时性能显著下降，并开发了IFEval++基准和reliable@k指标来量化这一问题。


<details>
  <summary>Details</summary>
Motivation: 现有LLMs在IFEval等基准上取得了接近天花板的指令跟随准确率，但这些高分在真实使用场景中不一定能转化为可靠服务，因为用户会以不同措辞、语境框架和任务表述来表达相同意图。需要研究模型在面对细微差别提示时的可靠性。

Method: 提出reliable@k新指标，开发自动化流水线通过数据增强生成高质量的"cousin prompts"（表达相同意图但存在细微差别的提示词），构建IFEval++进行系统评估，分析20个专有模型和26个开源模型。

Result: 当前模型在细微差别导向的可靠性方面存在严重不足，性能可能因细微提示修改而下降高达61.8%。研究还描述了这一问题特征并探索了三种潜在的改进方法。

Conclusion: 细微差别导向的可靠性是实现更可靠、更可信LLM行为的关键但尚未充分探索的下一步，IFEval++基准和发现为此方向提供了重要基础。

Abstract: Advanced LLMs have achieved near-ceiling instruction-following accuracy on benchmarks such as IFEval. However, these impressive scores do not necessarily translate to reliable services in real-world use, where users often vary their phrasing, contextual framing, and task formulations. In this paper, we study nuance-oriented reliability: whether models exhibit consistent competence across cousin prompts that convey analogous user intents but with subtle nuances. To quantify this, we introduce a new metric, reliable@k, and develop an automated pipeline that generates high-quality cousin prompts via data augmentation. Building upon this, we construct IFEval++ for systematic evaluation. Across 20 proprietary and 26 open-source LLMs, we find that current models exhibit substantial insufficiency in nuance-oriented reliability -- their performance can drop by up to 61.8% with nuanced prompt modifications. What's more, we characterize it and explore three potential improvement recipes. Our findings highlight nuance-oriented reliability as a crucial yet underexplored next step toward more dependable and trustworthy LLM behavior. Our code and benchmark are accessible: https://github.com/jianshuod/IFEval-pp.

</details>


### [6] [Examining Software Developers' Needs for Privacy Enforcing Techniques: A survey](https://arxiv.org/abs/2512.14756)
*Ioanna Theophilou,Georgia M. Kapitsaki*

Main category: cs.SE

TL;DR: 调查显示开发者需要更多自动化工具来满足数据隐私法规合规要求，隐私经验越丰富的开发者对隐私工具的需求越迫切


<details>
  <summary>Details</summary>
Motivation: GDPR、CCPA/CPRA等数据隐私法规要求软件系统必须合规，但开发者缺乏法律知识，难以在开发过程中有效集成隐私保护功能。现有研究关注开发者对隐私原则的理解，但尚未系统研究开发者在隐私法规合规方面的具体需求

Method: 通过问卷调查收集了68名开发者的反馈，分析影响开发者需求的因素，特别关注自动化工具需求与隐私经验的关系

Result: 大多数开发者表达了对更多自动化工具的需求，隐私经验越丰富的开发者对隐私工具的担忧越强烈。研究识别了影响从业者需求的关键因素

Conclusion: 研究结果可帮助开发者更好地定位隐私法规合规工作，并指出迫切需要开发隐私辅助工具，特别是生成式AI等自动化工具，以使合规过程更加顺畅

Abstract: Data privacy legislation, such as GDPR and CCPA/CPRA, has rendered data privacy law compliance a requirement of all software systems. Developers need to implement various kinds of functionalities to cover law needs, including user rights and law principles. As data compliance is tightly coupled with legal knowledge, it is not always easy to perform such integrations in software systems. Prior studies have focused on developers' understanding of privacy principles, such as Privacy by Design, and have examined privacy techniques used in the software industry. Nevertheless, emerging developer needs that can assist in privacy law compliance have not been examined but are useful in understanding what development automation tools, such as Generative AI, need to cover to make the compliance process more straightforward and seamless within the development process. In this work, we present a survey that examines the above needs with the participation of 68 developers, while we have examined which factors affect practitioners' needs. Most developers express a need for more automated tools, while privacy experience increases practitioners' concerns for privacy tools. Our results can assist practitioners in better positioning their development activities within privacy law compliance and point to an urgent need for privacy facilitators.

</details>


### [7] [CAPE: Capability Achievement via Policy Execution](https://arxiv.org/abs/2512.14761)
*David Ball*

Main category: cs.SE

TL;DR: CAPE协议通过将需求转化为可执行规范并训练模型来满足这些规范，将违规率降低了81%，成本降低了5-20倍，时间从数月缩短到数周。


<details>
  <summary>Details</summary>
Motivation: 现代AI系统缺乏表达和执行需求的方式。预训练产生智能，后训练优化偏好，但都不能保证模型可靠地满足明确的、上下文相关的约束。这解释了为什么高度智能的模型在部署中经常失败，尽管基准测试表现良好。

Method: 引入能力工程（Capability Engineering）实践，通过CAPE协议实现"指定->验证->纠正->训练"循环。基于两个实证发现：(1)上下文客观性：一旦上下文固定，主观属性变得客观；(2)验证-保真度缩放：验证准确性随模型规模提高，而偏好一致性则停滞不前。

Result: 在六个领域的109,500个示例中，CAPE相对于DPO将违规率降低了81%（标准差小于0.3%）。通过用可重用规范替代逐示例标注，成本降低了5-20倍，时间从数月缩短到数周。

Conclusion: CAPE协议、PredicateGraph模式、CPL规范语言和政策包已发布。同时推出CapabilityBench公共注册表，将评估从智能基准转向能力测量，为AI系统提供更可靠的需求满足保证。

Abstract: Modern AI systems lack a way to express and enforce requirements. Pre-training produces intelligence, and post-training optimizes preferences, but neither guarantees that models reliably satisfy explicit, context-dependent constraints. This missing abstraction explains why highly intelligent models routinely fail in deployment despite strong benchmark performance.
  We introduce Capability Engineering, the systematic practice of converting requirements into executable specifications and training models to satisfy them by default. We operationalize this practice through CAPE (Capability Achievement via Policy Execution), a protocol implementing a Specify -> Verify -> Correct -> Train loop.
  CAPE is grounded in two empirical findings: (1) contextual objectivity, where properties appearing subjective become objective once context is fixed (inter-annotator agreement rises from kappa = 0.42 to kappa = 0.98), and (2) verification-fidelity scaling, where verification accuracy improves with model scale (r = 0.94), unlike preference agreement which plateaus at 30 to 50 percent disagreement regardless of compute. Across 109,500 examples in six domains, CAPE reduces violation rates by 81 percent relative to DPO (standard deviation less than 0.3 percent). By replacing per-example annotation with reusable specifications, CAPE reduces costs by 5 to 20 times and shortens timelines from months to weeks.
  We release the CAPE protocol, PredicateGraph schema, CPL specification language, and policy packs under Apache 2.0. We also launch CapabilityBench, a public registry of model evaluations against community-contributed policies, shifting evaluation from intelligence benchmarks toward capability measurement.

</details>


### [8] [Workflows vs Agents for Code Translation](https://arxiv.org/abs/2512.14762)
*Henry Gray,Tom Yotam,Octavian Udrea*

Main category: cs.SE

TL;DR: 比较两种基于大语言模型的MATLAB到HDL语法修复方法：结构化流程与自主代理方法，后者使用MCP动态选择工具，在中小规模模型上效果更好。


<details>
  <summary>Details</summary>
Motivation: 将MATLAB算法转换为硬件描述语言（HDL）是FPGA和ASIC部署的必要步骤，但大语言模型在HDL代码训练有限，导致端到端转译容易产生语法错误，需要有效的语法修复方法。

Method: 比较两种LLM驱动的语法修复方法：1）结构化专家设计流程，遵循固定操作序列；2）自主代理方法，使用模型上下文协议（MCP）动态选择工具。研究42个MATLAB信号处理函数，隔离语法修复阶段，在三种模型规模上进行测试。

Result: 自主代理方法在解决初始语法错误方面更有效，能解锁更多候选代码进入流水线。上游改进带来下游可测量的提升，特别是在中型模型上，模拟成功率提高超过20个百分点。条件检索在8B和30B模型上有帮助，在235B模型上最终成功增益较小。

Conclusion: 适当设计的代理框架能有效补偿中小规模模型的容量限制，在语法修复任务中表现优于结构化方法，特别是在模型能力有限的情况下。

Abstract: Translating algorithms from high-level languages like MATLAB to hardware description languages (HDLs) is a resource-intensive but necessary step for deployment on FPGAs and ASICs. While large language models (LLMs) offer a path to automation, their limited training on HDL code makes end-to-end transpilation brittle and prone to syntax errors. We compare two LLM-driven methods for syntax repair in a MATLAB-to-HDL pipeline: a structured, expert-designed flow that follows a fixed sequence of operations, and a more autonomous agentic approach that uses the Model Context Protocol (MCP) \cite{anthropic2024mcp} to dynamically select its own tools. We study 42 MATLAB signal-processing functions and isolate the syntax-repair stage. Across three model scales, the agentic approach is more effective at resolving initial syntax errors, unblocking a greater number of candidates to proceed through the pipeline. This upstream improvement yields measurable downstream improvements, most notably on mid-sized models, where it increases the simulation reach rate by over 20 percentage points. We hypothesize the gains come from short prompts, aggressive context management, and conditional tool use. Conditional retrieval helps at 8B and 30B; at 235B final-success gains are small and a naive RAG variant attains the highest final success. Our findings suggest that these agentic frameworks, when properly designed, are most effective at compensating for the capacity limits of small and mid-sized models.

</details>


### [9] [Let the Barbarians In: How AI Can Accelerate Systems Performance Research](https://arxiv.org/abs/2512.14806)
*Audrey Cheng,Shu Liu,Melissa Pan,Zhifei Li,Shubham Agarwal,Mert Cemri,Bowen Wang,Alexander Krentsel,Tian Xia,Jongseok Park,Shuo Yang,Jeff Chen,Lakshya Agrawal,Ashwin Naren,Shulu Li,Ruiying Ma,Aditya Desai,Jiarong Xing,Koushik Sen,Matei Zaharia,Ion Stoica*

Main category: cs.SE

TL;DR: 论文提出AI驱动的系统研究（ADRS）范式，通过AI自动生成、评估和优化系统设计方案，在多个案例中达到或超越人工设计的性能。


<details>
  <summary>Details</summary>
Motivation: AI正在改变研究过程，系统性能研究特别适合AI驱动，因为系统问题天然具备验证器（可通过实现和模拟评估），但需要可靠的验证机制来支持AI驱动的解决方案发现。

Method: 提出AI驱动的系统研究（ADRS）范式，包含生成、评估、优化的迭代循环。使用多个开源ADRS实例（OpenEvolve、GEPA、ShinkaEvolve），在十个案例研究中进行验证。

Result: ADRS生成的解决方案在多个案例（多云区域调度、专家混合负载均衡、LLM-based SQL、事务调度等）中能够匹配甚至超越人类设计的最先进方案。

Conclusion: 虽然还没有适用于所有系统研究的通用ADRS方法，但初步发现和最佳实践为未来研究提供了指导，研究者的角色将更多转向问题制定和战略监督。

Abstract: Artificial Intelligence (AI) is beginning to transform the research process by automating the discovery of new solutions. This shift depends on the availability of reliable verifiers, which AI-driven approaches require to validate candidate solutions. Research focused on improving systems performance is especially well-suited to this paradigm because system performance problems naturally admit such verifiers: candidates can be implemented in real systems or simulators and evaluated against predefined workloads. We term this iterative cycle of generation, evaluation, and refinement AI-Driven Research for Systems (ADRS). Using several open-source ADRS instances (i.e., OpenEvolve, GEPA, and ShinkaEvolve), we demonstrate across ten case studies (e.g., multi-region cloud scheduling, mixture-of-experts load balancing, LLM-based SQL, transaction scheduling) that ADRS-generated solutions can match or even outperform human state-of-the-art designs. Based on these findings, we outline best practices (e.g., level of prompt specification, amount of feedback, robust evaluation) for effectively using ADRS, and we discuss future research directions and their implications. Although we do not yet have a universal recipe for applying ADRS across all of systems research, we hope our preliminary findings, together with the challenges we identify, offer meaningful guidance for future work as researcher effort shifts increasingly toward problem formulation and strategic oversight. Note: This paper is an extension of our prior work [14]. It adds extensive evaluation across multiple ADRS frameworks and provides deeper analysis and insights into best practices.

</details>


### [10] [Industry Expectations and Skill Demands in Quantum Software Testing](https://arxiv.org/abs/2512.14861)
*Ronnie de Souza Santos,Teresa Baldassarre,Cesar França*

Main category: cs.SE

TL;DR: 量子软件测试结合传统软件质量保证与实验验证，强调校准、控制和混合量子-经典验证，需要编程自动化与量子专业知识及跨学科协作能力。


<details>
  <summary>Details</summary>
Motivation: 量子软件测试面临与经典软件工程根本不同的新挑战，需要了解量子软件行业如何定义测试角色以及对这些职位专业人员的能力期望。

Method: 分析了110份来自量子软件和硬件开发组织的招聘信息，识别与测试相关的活动、能力和技能要求。

Result: 量子测试结合传统软件质量保证与实验验证，强调校准、控制和混合量子-经典验证。雇主寻求具备编程自动化、量子专业知识及跨学科协作能力的专业人员。

Conclusion: 量子软件测试仍处于早期但快速发展的阶段，连接软件工程与实验物理学，需要教育和研究工作使测试实践与工业现实保持一致。

Abstract: Quantum software testing introduces new challenges that differ fundamentally from those in classical software engineering. Aims: This study investigates how the quantum software industry defines testing roles and what skills are expected from professionals in these positions. Method: We analyzed 110 job postings from organizations involved in quantum software and hardware development, identifying activities, competencies, and skill requirements related to testing. Results: The findings show that testing in quantum contexts combines traditional software quality assurance with experimental validation, emphasizing calibration, control, and hybrid quantum-classical verification. Employers seek professionals who integrate programming and automation expertise with quantum-specific technical knowledge and interdisciplinary collaboration skills. Conclusions: Quantum software testing remains at an early but rapidly evolving stage that bridges software engineering and experimental physics, highlighting the need for educational and research efforts that align testing practices with industrial realities.

</details>


### [11] [Evaluating Code Reasoning Abilities of Large Language Models Under Real-World Settings](https://arxiv.org/abs/2512.14917)
*Changshu Liu,Alireza Ghazanfari,Yang Chen,Reyhaneh Jabbarvand*

Main category: cs.SE

TL;DR: RE2-Bench是一个包含1101个代码推理问题的基准测试，其中195个来自成熟的实际项目，旨在更真实地评估LLM的代码推理能力，超越了现有基准的简单程序限制。


<details>
  <summary>Details</summary>
Motivation: 现有代码推理基准测试主要使用简单程序，无法反映真实世界的复杂性（如过程间/内依赖、API调用、嵌套结构、复杂类型等），导致对LLM泛化能力的评估存在偏差。

Method: 通过静态和动态程序分析自动序列化和反序列化实际代码中的复合、复杂和自定义类型；使用九种可解释的代码复杂度指标，通过多数投票机制将问题分类为简单或困难。

Result: 对6个通用和推理导向的LLM在两个代码推理任务（输入预测和输出预测）上的评估显示，从简单到困难问题的性能显著下降（输入预测下降51.50%，输出预测下降42.15%）。

Conclusion: 现有评估显著高估了LLM的推理能力，RE2-Bench提供了更真实的评估框架，揭示了LLM在实际复杂代码推理中的局限性。

Abstract: Code reasoning tasks are becoming prevalent in large language model (LLM) assessments. Existing benchmarks involve simple programs, failing to represent real-world complexities such as inter- or intra-procedural dependencies, core or third-party API calls, highly nested constructs, and non-primitive complex types. Evaluating LLMs under such a simplistic setting poses a significant threat to assumptions about their generalizability in practice. To enable a more realistic evaluation of code reasoning, this paper proposes RE2-Bench, a benchmark of 1,101 reasoning problems, including 195 drawn from mature real-world projects. RE2-Bench leverages static and dynamic program analysis to automatically serialize and deserialize compound, complex, and custom types in real-world code, going far beyond the primitive-only settings used in prior work.
  A key feature of RE2-Bench is categorizing each reasoning problem as Easy or Hard via a principled majority-vote mechanism over nine interpretable code complexity metrics, resulting in two well-separated and semantically meaningful difficulty categories suitable for precise calibration of LLM reasoning ability. A comprehensive evaluation of six general-purpose and reasoning-oriented LLMs on two widely used code reasoning tasks -- input prediction and output prediction -- using RE2-Bench reveals a significant performance drop from Easy to Hard problems (51.50\% for input prediction and 42.15\% for output prediction), confirming that prior evaluations substantially overestimate the reasoning capabilities of LLMs.

</details>


### [12] [Imitation Game: Reproducing Deep Learning Bugs Leveraging an Intelligent Agent](https://arxiv.org/abs/2512.14990)
*Mehil B Shah,Mohammad Masudur Rahman,Foutse Khomh*

Main category: cs.SE

TL;DR: RepGen：一种基于LLM的自动化方法，用于复现深度学习bug，相比现有方法提升19.81%的复现率


<details>
  <summary>Details</summary>
Motivation: 深度学习应用存在大量bug、故障和漏洞，但由于DL模型的非确定性和软硬件环境的紧密耦合，手动复现这些bug极其困难，仅有约3%的DL bug可以通过手动方法可靠复现

Method: RepGen构建项目的学习增强上下文，制定全面的bug复现计划，采用迭代的生成-验证-优化机制，并使用LLM生成能够复现目标bug的代码

Result: 在106个真实世界深度学习bug上评估，达到80.19%的复现率，比现有最佳方法提升19.81%。开发者研究显示，RepGen将DL bug复现成功率提高23.35%，复现时间减少56.8%，并降低参与者的认知负荷

Conclusion: RepGen是一种有效且高效的自动化深度学习bug复现方法，显著提升了bug复现的成功率和效率，为DL系统的调试和维护提供了有力工具

Abstract: Despite their wide adoption in various domains (e.g., healthcare, finance, software engineering), Deep Learning (DL)-based applications suffer from many bugs, failures, and vulnerabilities. Reproducing these bugs is essential for their resolution, but it is extremely challenging due to the inherent nondeterminism of DL models and their tight coupling with hardware and software environments. According to recent studies, only about 3% of DL bugs can be reliably reproduced using manual approaches. To address these challenges, we present RepGen, a novel, automated, and intelligent approach for reproducing deep learning bugs. RepGen constructs a learning-enhanced context from a project, develops a comprehensive plan for bug reproduction, employs an iterative generate-validate-refine mechanism, and thus generates such code using an LLM that reproduces the bug at hand. We evaluate RepGen on 106 real-world deep learning bugs and achieve a reproduction rate of 80.19%, a 19.81% improvement over the state-of-the-art measure. A developer study involving 27 participants shows that RepGen improves the success rate of DL bug reproduction by 23.35%, reduces the time to reproduce by 56.8%, and lowers participants' cognitive load.

</details>


### [13] [Toxicity Ahead: Forecasting Conversational Derailment on GitHub](https://arxiv.org/abs/2512.15031)
*Mia Mohammad Imran,Robert Zita,Rahat Rizvi Rahman,Preetha Chatterjee,Kostadin Damevski*

Main category: cs.SE

TL;DR: 论文提出基于LLM的两步提示框架，用于预测开源软件社区GitHub讨论中的对话脱轨（毒性互动），通过生成对话动态摘要来早期检测毒性对话。


<details>
  <summary>Details</summary>
Motivation: 开源软件社区中的毒性互动会降低贡献者参与度并威胁项目可持续性。现有预防策略多为手动方式，需要维护者投入大量时间和精力，缺乏可扩展的自动化解决方案。

Method: 构建了包含159个毒性线程和207个非毒性线程的GitHub讨论数据集。提出基于LLM的两步提示框架：1) 使用Least-to-Most提示生成对话动态摘要；2) 基于摘要预测对话脱轨可能性。使用Qwen和Llama模型进行评估。

Result: LtM策略在Qwen和Llama模型上分别达到0.901和0.852的F1分数（决策阈值为0.3），优于现有NLP基线。在308个GitHub问题线程的外部验证中，F1分数最高达0.797。

Conclusion: 结构化LLM提示能有效早期检测开源软件社区中的对话脱轨，实现主动且可解释的审核，为可扩展的社区管理提供支持。

Abstract: Toxic interactions in Open Source Software (OSS) communities reduce contributor engagement and threaten project sustainability. Preventing such toxicity before it emerges requires a clear understanding of how harmful conversations unfold. However, most proactive moderation strategies are manual, requiring significant time and effort from community maintainers. To support more scalable approaches, we curate a dataset of 159 derailed toxic threads and 207 non-toxic threads from GitHub discussions. Our analysis reveals that toxicity can be forecast by tension triggers, sentiment shifts, and specific conversational patterns.
  We present a novel Large Language Model (LLM)-based framework for predicting conversational derailment on GitHub using a two-step prompting pipeline. First, we generate \textit{Summaries of Conversation Dynamics} (SCDs) via Least-to-Most (LtM) prompting; then we use these summaries to estimate the \textit{likelihood of derailment}. Evaluated on Qwen and Llama models, our LtM strategy achieves F1-scores of 0.901 and 0.852, respectively, at a decision threshold of 0.3, outperforming established NLP baselines on conversation derailment. External validation on a dataset of 308 GitHub issue threads (65 toxic, 243 non-toxic) yields an F1-score up to 0.797. Our findings demonstrate the effectiveness of structured LLM prompting for early detection of conversational derailment in OSS, enabling proactive and explainable moderation.

</details>


### [14] [An Exploratory Study of Bayesian Prompt Optimization for Test-Driven Code Generation with Large Language Models](https://arxiv.org/abs/2512.15076)
*Shlok Tomar,Aryan Deshwal,Ethan Villalovoz,Mattia Fazzini,Haipeng Cai,Janardhan Rao Doppa*

Main category: cs.SE

TL;DR: BODE-GEN：使用贝叶斯优化在连续嵌入空间中搜索最佳提示，以提高LLM代码生成的功能正确性


<details>
  <summary>Details</summary>
Motivation: LLM生成的代码正确性受提示影响，手动设计提示耗时且效果有限，需要自动化的方法来寻找最优提示

Method: 提出BODE-GEN框架：1）使用辅助LLM将离散提示空间映射到连续嵌入空间；2）采用随机投影和维度缩放先验构建高斯过程代理模型；3）通过贝叶斯优化在嵌入空间中自适应搜索最佳提示

Result: 在HumanEval+基准测试中，BODE-GEN相比固定提示和手动提示工程能提高代码生成准确率，且样本效率高，只需较少迭代次数就能改善代码准确性

Conclusion: BODE-GEN通过将提示搜索问题转化为连续嵌入空间中的贝叶斯优化问题，有效提高了LLM代码生成的功能正确性，为自动化提示优化提供了新方法

Abstract: We consider the task of generating functionally correct code using large language models (LLMs). The correctness of generated code is influenced by the prompt used to query the given base LLM. We formulate the problem of finding the appropriate prompt as combinatorial search process and propose a Bayesian optimization (BO) approach referred to as {\em BO for Code GENeration (BODE-GEN)}. BODE-GEN performs an adaptive data-driven search over prompts guided by training data in the form of prompts tried and the functional accuracy of the generated code over a set of given test cases. The key insight is to perform BO in continuous embedding space by using an auxiliary LLM to bridge the gap between discrete prompt space and continuous embedding space. We leverage two synergistic ideas, namely, random projections and dimensionality scaled priors, to build effective Gaussian process based surrogate models over the high-dimensional embedding space. Our experiments on the HumanEval+ benchmark using multiple base LLMs show that BODE-GEN can improve performance in terms of code generation accuracy compared to fixed prompts and manual prompt engineering. Additionally, we demonstrate that BODE-GEN is sample-efficient, requiring relatively few iterations of BO to demonstrate improvements in code accuracy.

</details>


### [15] [Aligning Academia with Industry: An Empirical Study of Industrial Needs and Academic Capabilities in AI-Driven Software Engineering](https://arxiv.org/abs/2512.15148)
*Hang Yu,Yuzhou Lai,Li Zhang,Xiaoli Lian,Fang Liu,Yanrui Dong,Ting Zhang,Zhi Jin,David Lo*

Main category: cs.SE

TL;DR: 该论文通过系统分析1367篇顶级软件工程会议论文和282份工业界调查，揭示了学术界与工业界在LLM驱动的软件工程研究上的差距，提出了七个关键启示以引导未来研究方向。


<details>
  <summary>Details</summary>
Motivation: 大型语言模型正在重塑软件工程领域，但学术界的研究进展与工业界的实际需求之间存在明显脱节。为了弥合这一差距，作者需要系统分析学术研究现状并收集工业界反馈。

Method: 1. 对2022-2025年间FSE、ASE、ICSE三个顶级软件工程会议的1367篇论文进行系统分析，识别研究主题、常用基准、工业相关性和开源可用性；2. 在17个组织中通过结构化问卷收集282份反馈，涵盖程序分析、自动化测试、代码生成/补全、问题解决、预训练代码模型和依赖管理等六个主题。

Result: 通过对比学术能力和工业反馈，发现了七个关键启示：1) 软件需求和架构方面的挑战被忽视；2) 智能软件工程方法的可靠性和可解释性问题；3) 学术研究中的输入假设限制；4) 实际评估的紧张关系；5) 伦理考虑不足；6) 学术与工业需求不匹配；7) 需要更实用的评估方法。

Conclusion: 研究旨在重新聚焦学术界对这些重要但未充分探索问题的关注，并引导未来软件工程研究朝着更具工业影响力的方向发展，弥合学术研究与工业实践之间的鸿沟。

Abstract: The rapid advancement of large language models (LLMs) is fundamentally reshaping software engineering (SE), driving a paradigm shift in both academic research and industrial practice. While top-tier SE venues continue to show sustained or emerging focus on areas like automated testing and program repair, with researchers worldwide reporting continuous performance gains, the alignment of these academic advances with real industrial needs remains unclear. To bridge this gap, we first conduct a systematic analysis of 1,367 papers published in FSE, ASE, and ICSE between 2022 and 2025, identifying key research topics, commonly used benchmarks, industrial relevance, and open-source availability. We then carry out an empirical survey across 17 organizations, collecting 282 responses on six prominent topics, i.e., program analysis, automated testing, code generation/completion, issue resolution, pre-trained code models, and dependency management, through structured questionnaires. By contrasting academic capabilities with industrial feedback, we derive seven critical implications, highlighting under-addressed challenges in software requirements and architecture, the reliability and explainability of intelligent SE approaches, input assumptions in academic research, practical evaluation tensions, and ethical considerations. This study aims to refocus academic attention on these important yet under-explored problems and to guide future SE research toward greater industrial impact.

</details>


### [16] [Automating Execution and Verification of BPMN+DMN Business Processes](https://arxiv.org/abs/2512.15214)
*Giuseppe Della Penna,Igor Melatti*

Main category: cs.SE

TL;DR: 开发BDTransTest工具，将BPMN+DMN业务流程转换为Java程序，生成测试计划并分析覆盖率，解决现有工具只能检测语法错误而忽略语义行为故障的问题。


<details>
  <summary>Details</summary>
Motivation: 当前BPMN+DMN建模框架大多只能检测语法错误，无法发现语义行为故障，设计师需要手动运行流程来检测问题，且专有工具的转换机制不透明。

Method: 设计BDTransTest工具，提供：1) BPMN+DMN流程到Java程序的转换；2) 测试计划的合成与执行，需要设计师澄清输入域歧义；3) 基于流程节点和边的覆盖率分析。

Result: 在文献中的BPMN+DMN流程上进行实验评估，展示了工具的有效性。

Conclusion: BDTransTest工具能够自动验证BPMN+DMN流程的正确性，通过程序转换和测试覆盖分析解决了现有工具在语义验证方面的不足。

Abstract: The increasing and widespread use of BPMN business processes, also embodying DMN tables, requires tools and methodologies to verify their correctness. However, most commonly used frameworks to build BPMN+DMN models only allow designers to detect syntactical errors, thus ignoring semantic (behavioural) faults. This forces business processes designers to manually run single executions of their BPMN+DMN processes using proprietary tools in order to detect failures. Furthermore, how proprietary tools translate a BPMN+DMN process to a computer simulation is left unspecified. In this paper, we advance this state of the art by designing a tool, named BDTransTest providing: i) a translation from a BPMN + DMN process B to a Java program P ; ii) the synthesis and execution of a testing plan for B, that may require the business designer to disambiguate some input domain; iii) the analysis of the coverage achieved by the testing plan in terms of nodes and edges of B. Finally, we provide an experimental evaluation of our methodology on BPMN+DMN processes from the literature.

</details>


### [17] [Heterogeneous Model Alignment in Digital Twin](https://arxiv.org/abs/2512.15281)
*Faima Abbasi,Jean-Sébastien Sottet,Cedric Pruski*

Main category: cs.SE

TL;DR: 提出一种用于多层模型驱动数字孪生的异构模型对齐框架，通过自适应一致性机制和LLM验证的对齐过程，自动发现语义对应关系，减少手动映射，提高可扩展性。


<details>
  <summary>Details</summary>
Motivation: 数字孪生技术中，多层模型驱动的异构模型对齐存在语义不匹配、不一致性和同步问题。现有方法依赖静态映射和手动更新，不够灵活且容易出错，可能损害数据完整性。

Method: 提出异构模型对齐框架，包含：1）允许元模型自适应和互连的灵活性机制；2）将元模型与演化模型连接的自适应一致性机制；3）基于大语言模型验证的对齐过程，将元模型锚定在领域知识中，确保结构保真度和概念一致性。

Result: 使用空气质量用例说明方法，并通过OAEI（本体对齐评估倡议）的不同测试案例验证性能。该方法能自动发现语义对应关系，最小化手动映射，并增强跨不同模型类型的可扩展性。

Conclusion: 提出的框架解决了数字孪生中多层异构模型对齐的关键挑战，通过自动化语义对应发现和LLM验证的对齐过程，提高了模型对齐的灵活性、准确性和可扩展性。

Abstract: Digital twin (DT) technology integrates heterogeneous data and models, along with semantic technologies to create multi-layered digital representation of physical systems. DTs enable monitoring, simulation, prediction, and optimization to enhance decision making and operational efficiency. A key challenge in multi-layered, model-driven DTs is aligning heterogeneous models across abstraction layers, which can lead to semantic mismatches, inconsistencies, and synchronization issues. Existing methods, relying on static mappings and manual updates, are often inflexible, error-prone, and risk compromising data integrity. To address these limitations, we present a heterogeneous model alignment approach for multi-layered, model-driven DTs. The framework incorporates a flexibility mechanism that allows metamodels to adapt and interconnect seamlessly while maintaining semantic coherence across abstraction layers. It integrates: (i) adaptive conformance mechanisms that link metamodels with evolving models and (ii) a large language model (LLM) validated alignment process that grounds metamodels in domain knowledge, ensuring structural fidelity and conceptual consistency throughout the DT lifecycle. This approach automates semantic correspondences discovery, minimizes manual mapping, and enhances scalability across diverse model types. We illustrate the approach using air quality use case and validate its performance using different test cases from Ontology Alignment Evaluation Initiative (OAEI) tracks.

</details>


### [18] [Can AI Generate more Comprehensive Test Scenarios? Review on Automated Driving Systems Test Scenario Generation Methods](https://arxiv.org/abs/2512.15422)
*Ji Zhou,Yongqi Zhao,Yixian Hu,Hexuan Li,Zhengguo Gu,Nan Xu,Arno Eichberger*

Main category: cs.SE

TL;DR: 这篇综述系统分析了2015-2025年自动驾驶系统场景测试方法，重点关注2023-2025年AI辅助和多模态方法的发展，提出了改进的分类法、伦理检查清单和场景难度评估框架。


<details>
  <summary>Details</summary>
Motivation: 传统自动驾驶系统验证方法（如大规模道路测试）成本高、耗时长，而现有场景测试综述未能全面覆盖最新的方法和技术进展，需要系统梳理近年来的AI辅助和多模态方法发展。

Method: 通过全面检索2015-2025年的文献，系统分析了31篇主要研究和10篇综述，重点关注2023-2025年的最新框架。传统方法依赖专家知识、本体论和自然驾驶数据，而新方法利用生成模型（大语言模型、生成对抗网络、扩散模型、强化学习）来合成多样化和安全关键场景。

Result: 识别出三个持续存在的差距：缺乏标准化评估指标、伦理和人为因素整合不足、多模态和特定运行设计域场景覆盖不足。为此提出了改进的分类法、伦理安全检查清单、ODD覆盖图和场景难度评估方案。

Conclusion: 该综述为研究人员提供了方法学清晰度，为行业提供了实践指导，支持可重复的评估，加速更高级别自动驾驶系统的安全部署。

Abstract: Ensuring the safety and reliability of Automated Driving Systems (ADS) remains a critical challenge, as traditional verification methods such as large-scale on-road testing are prohibitively costly and time-consuming.To address this,scenario-based testing has emerged as a scalable and efficient alternative,yet existing surveys provide only partial coverage of recent methodological and technological advances.This review systematically analyzes 31 primary studies,and 10 surveys identified through a comprehensive search spanning 2015~2025;however,the in-depth methodological synthesis and comparative evaluation focus primarily on recent frameworks(2023~2025),reflecting the surge of Artificial Intelligent(AI)-assisted and multimodal approaches in this period.Traditional approaches rely on expert knowledge,ontologies,and naturalistic driving or accident data,while recent developments leverage generative models,including large language models,generative adversarial networks,diffusion models,and reinforcement learning frameworks,to synthesize diverse and safety-critical scenarios.Our synthesis identifies three persistent gaps:the absence of standardized evaluation metrics,limited integration of ethical and human factors,and insufficient coverage of multimodal and Operational Design Domain (ODD)-specific scenarios.To address these challenges,this review contributes a refined taxonomy that incorporates multimodal extensions,an ethical and safety checklist for responsible scenario design,and an ODD coverage map with a scenario-difficulty schema to enable transparent benchmarking.Collectively,these contributions provide methodological clarity for researchers and practical guidance for industry,supporting reproducible evaluation and accelerating the safe deployment of higher-level ADS.

</details>


### [19] [Insecure Ingredients? Exploring Dependency Update Patterns of Bundled JavaScript Packages on the Web](https://arxiv.org/abs/2512.15447)
*Ben Swierzy,Marc Ohm,Michael Meier*

Main category: cs.SE

TL;DR: Aletheia：一种通过抄袭检测算法从JavaScript包中识别软件包版本的包无关方法，显著优于现有方法，并揭示生产网站依赖更新行为


<details>
  <summary>Details</summary>
Motivation: JavaScript生态系统中数百万个软件包的使用被推广为惯用做法，但npm下载统计显示易受攻击包版本的高流行度，而它们在生产网站上的实际流行度未知。现有包版本检测机制要么针对捆绑包中的手动选择流行包，要么针对使用全局命名空间的单文件资源，无法大规模分析现代Web应用程序的依赖更新行为。

Method: 提出Aletheia方法，这是一种包无关的方法，通过源自抄袭检测领域的算法剖析JavaScript捆绑包来识别包版本。该方法不依赖特定包的特征，而是使用通用算法从捆绑包中提取包版本信息。

Result: Aletheia在实践环境中明显优于现有方法。通过对Tranco前10万个域的爬取发现：5%-20%的域在16周内更新其依赖；从纵向角度看，捆绑包比CDN包含的包更新速度显著更快，因此包含的已知易受攻击包版本最多减少10倍；但少数广泛供应商似乎是及时更新的主要推动力。

Conclusion: 虽然捆绑包依赖更新速度更快且安全性更好，但定量测量并不能完全反映实际情况，因为少数广泛供应商似乎是及时更新的主要推动力，这表明生态系统中的更新行为可能受到少数关键参与者的影响。

Abstract: Reusable software components, typically distributed as packages, are a central paradigm of modern software development. The JavaScript ecosystem serves as a prime example, offering millions of packages with their use being promoted as idiomatic. However, download statistics on npm raise security concerns as they indicate a high popularity of vulnerable package versions while their real prevalence on production websites remains unknown. Package version detection mechanisms fill this gap by extracting utilized packages and versions from observed artifacts on the web. Prior research focuses on mechanisms for either hand-selected popular packages in bundles or for single-file resources utilizing the global namespace. This does not allow for a thorough analysis of modern web applications' dependency update behavior at scale. In this work, we improve upon this by presenting Aletheia, a package-agnostic method which dissects JavaScript bundles to identify package versions through algorithms originating from the field of plagiarism detection. We show that this method clearly outperforms the existing approaches in practical settings. Furthermore, we crawl the Tranco top 100,000 domains to reveal that 5% - 20% of domains update their dependencies within 16 weeks. Surprisingly, from a longitudinal perspective, bundled packages are updated significantly faster than their CDN-included counterparts, with consequently up to 10 times fewer known vulnerable package versions included. Still, we observe indicators that few widespread vendors seem to be a major driving force behind timely updates, implying that quantitative measures are not painting a complete picture.

</details>


### [20] [A Container-based Approach For Proactive Asset Administration Shell Digital Twins](https://arxiv.org/abs/2512.15452)
*Carsten Ellwein,Jingxi Zhang,Andreas Wortmann,Antony Ayman Alfy Meckhael*

Main category: cs.SE

TL;DR: 提出基于子模型的AAS架构，通过容器化服务集成实现数字孪生的动态行为执行，使AAS从被动数据存储变为主动服务接口


<details>
  <summary>Details</summary>
Motivation: 当前AAS作为静态信息模型，缺乏动态服务集成和系统适应能力，无法支持可执行行为的集成，限制了数字孪生的主动功能实现

Method: 提出基于子模型的架构，通过扩展子模型包含行为定义，创建模块化事件驱动架构，基于嵌入式触发条件部署容器化服务

Result: 在三轴铣床案例研究中验证了该方法的可行性，使AAS能够作为主动接口执行增值服务

Conclusion: 该研究使AAS从被动数字表示转变为主动服务执行接口，为未来AI驱动的适应和系统级智能奠定了基础

Abstract: In manufacturing, digital twins, realized as Asset Administration Shells (AAS), have emerged as a prevalent practice. These digital replicas, often utilized as structured repositories of asset-related data, facilitate interoperability across diverse systems. However, extant approaches treat the AAS as a static information model, lacking support for dynamic service integration and system adaptation. The existing body of literature has not yet thoroughly explored the potential for integrating executable behavior, particularly in the form of containerized services, into or from the AAS. This integration could serve to enable proactive functionality. In this paper, we propose a submodel-based architecture that introduces a structured service notion to the AAS, enabling services to dynamically interact with and adapt AAS instances at runtime. This concept is implemented through the extension of a submodel with behavioral definitions, resulting in a modular event-driven architecture capable of deploying containerized services based on embedded trigger conditions. The approach is illustrated through a case study on a 3-axis milling machine. Our contribution enables the AAS to serve not only as a passive digital representation but also as an active interface for executing added-value services.%, thereby laying the foundation for future AI-driven adaptation and system-level intelligence in digital twin environments.

</details>


### [21] [On Assessing the Relevance of Code Reviews Authored by Generative Models](https://arxiv.org/abs/2512.15466)
*Robert Heumüller,Frank Ortmeier*

Main category: cs.SE

TL;DR: 提出基于多主观排名的代码审查生成评估方法，发现ChatGPT生成的评论质量显著优于人类评论


<details>
  <summary>Details</summary>
Motivation: 现有代码审查生成评估方法存在局限：要么依赖与单一标准答案的自动比较（无法捕捉人类观点的多样性），要么依赖主观的"有用性"评估（概念模糊）。需要更有效的评估方法。

Method: 提出多主观排名评估方法，使用CodeReview StackExchange的280个独立代码审查请求及相应评论数据集，让多位人类评审对ChatGPT生成的评论与平台上的最佳人类回答进行质量排名。

Result: ChatGPT生成的评论在排名上显著优于人类评论，甚至超过了StackExchange上被接受的答案。

Conclusion: 提出的方法能够更有效地评估生成式AI在代码审查中的表现，同时提醒人们注意将AI不加检查地集成到审查流程中的潜在风险。

Abstract: The use of large language models like ChatGPT in code review offers promising efficiency gains but also raises concerns about correctness and safety. Existing evaluation methods for code review generation either rely on automatic comparisons to a single ground truth, which fails to capture the variability of human perspectives, or on subjective assessments of "usefulness", a highly ambiguous concept. We propose a novel evaluation approach based on what we call multi-subjective ranking. Using a dataset of 280 self-contained code review requests and corresponding comments from CodeReview StackExchange, multiple human judges ranked the quality of ChatGPT-generated comments alongside the top human responses from the platform. Results show that ChatGPT's comments were ranked significantly better than human ones, even surpassing StackExchange's accepted answers. Going further, our proposed method motivates and enables more meaningful assessments of generative AI's performance in code review, while also raising awareness of potential risks of unchecked integration into review processes.

</details>


### [22] [How Do Semantically Equivalent Code Transformations Impact Membership Inference on LLMs for Code?](https://arxiv.org/abs/2512.15468)
*Hua Yang,Alejandro Velasco,Thanh Le-Cong,Md Nazmul Haque,Bowen Xu,Denys Poshyvanyk*

Main category: cs.SE

TL;DR: 研究表明，语义等价的代码转换技术可以显著削弱成员推断检测的效果，特别是变量重命名规则能降低10.19%的检测成功率，暴露了代码LLM许可合规执行中的关键漏洞。


<details>
  <summary>Details</summary>
Motivation: 大型代码语言模型训练依赖大量代码数据，包括开源和私有代码，这引发了知识产权合规和未经授权使用许可受限代码的担忧。虽然已有成员推断技术来检测此类未经授权使用，但其效果可能被语义等价代码转换技术削弱。

Method: 系统研究语义等价代码转换规则是否可用于规避成员推断检测，包括分析不同转换规则对模型准确性的影响，评估转换数据集作为微调替代品的有效性，并进行因果分析验证变量重命名对破坏成员推断检测的因果效应。

Result: 每个转换规则在最坏情况下仅使模型准确性下降1.5%，表明转换数据集可有效替代原始数据进行微调。变量重命名规则能降低成员推断成功率10.19%，因果分析确认变量重命名对破坏成员推断检测具有最强因果效应。有趣的是，组合多个转换不会进一步降低成员推断效果。

Conclusion: 研究揭示了代码语言模型许可合规执行中的关键漏洞，表明基于转换的混淆技术可以显著削弱成员推断检测，这对保护知识产权和确保代码LLM训练合规性提出了重要挑战。

Abstract: The success of large language models for code relies on vast amounts of code data, including public open-source repositories, such as GitHub, and private, confidential code from companies. This raises concerns about intellectual property compliance and the potential unauthorized use of license-restricted code. While membership inference (MI) techniques have been proposed to detect such unauthorized usage, their effectiveness can be undermined by semantically equivalent code transformation techniques, which modify code syntax while preserving semantic.
  In this work, we systematically investigate whether semantically equivalent code transformation rules might be leveraged to evade MI detection. The results reveal that model accuracy drops by only 1.5% in the worst case for each rule, demonstrating that transformed datasets can effectively serve as substitutes for fine-tuning. Additionally, we find that one of the rules (RenameVariable) reduces MI success by 10.19%, highlighting its potential to obscure the presence of restricted code. To validate these findings, we conduct a causal analysis confirming that variable renaming has the strongest causal effect in disrupting MI detection. Notably, we find that combining multiple transformations does not further reduce MI effectiveness. Our results expose a critical loophole in license compliance enforcement for training large language models for code, showing that MI detection can be substantially weakened by transformation-based obfuscation techniques.

</details>


### [23] [WuppieFuzz: Coverage-Guided, Stateful REST API Fuzzing](https://arxiv.org/abs/2512.15554)
*Thomas Rooijakkers,Anne Nijsten,Cristian Daniele,Erieke Weitenberg,Ringo Groenewegen,Arthur Melissen*

Main category: cs.SE

TL;DR: WuppieFuzz是一个基于LibAFL的开源REST API模糊测试工具，支持白盒、灰盒和黑盒测试，通过OpenAPI规范生成初始请求序列，利用REST特定和LibAFL提供的变异器探索代码路径，并自动化创建测试框架以减少手动工作。


<details>
  <summary>Details</summary>
Motivation: REST API广泛用于商业流程，暴露的端点带来安全风险。由于端点数量庞大，需要自动化测试技术（如模糊测试）来全面测试API安全性。

Method: 基于LibAFL构建的REST API模糊测试工具，使用OpenAPI规范生成初始请求序列，通过REST特定和LibAFL变异器进行变异，利用覆盖率指导选择请求序列以到达复杂状态，并自动化创建测试框架。

Result: 在Petstore API上评估了白盒方法的鲁棒性和不同功率调度策略的有效性，监控了端点和代码覆盖率随时间的变化以衡量方法效果。

Conclusion: WuppieFuzz是一个有效的REST API模糊测试工具，支持多种测试模式，自动化程度高，能帮助发现和修复安全漏洞。

Abstract: Many business processes currently depend on web services, often using REST APIs for communication. REST APIs expose web service functionality through endpoints, allowing easy client interaction over the Internet. To reduce the security risk resulting from exposed endpoints, thorough testing is desired. Due to the generally vast number of endpoints, automated testing techniques, like fuzzing, are of interest.
  This paper introduces WuppieFuzz, an open-source REST API fuzzer built on LibAFL, supporting white-box, grey-box and black-box fuzzing. Using an OpenAPI specification, it can generate an initial input corpus consisting of sequences of requests. These are mutated with REST-specific and LibAFL-provided mutators to explore different code paths in the software under test. Guided by the measured coverage, WuppieFuzz then selects which request sequences to send next to reach complex states in the software under test. In this process, it automates harness creation to reduce manual efforts often required in fuzzing. Different kinds of reporting are provided by the fuzzer to help fixing bugs.
  We evaluated our tool on the Petstore API to assess the robustness of the white-box approach and the effectiveness of different power schedules. We further monitored endpoint and code coverage over time to measure the efficacy of the approach.

</details>


<div id='cs.LO'></div>

# cs.LO [[Back]](#toc)

### [24] [A study of cut-elimination for a non-labelled cyclic proof system for propositional dynamic logics](https://arxiv.org/abs/2512.15075)
*Yukihiro Oda*

Main category: cs.LO

TL;DR: 本文为带有向后模态算子的命题动态逻辑扩展引入了一个矢列演算和一个非标记循环证明系统，证明了系统的可靠性和完全性，但两者都缺乏消去规则，同时展示了限制版本（标准命题动态逻辑）的循环证明系统具有消去性质。


<details>
  <summary>Details</summary>
Motivation: 动态逻辑是用于推理程序的逻辑，循环证明系统是允许包含循环的证明系统，可作为包含（共）归纳的证明系统的替代方案。本文旨在为扩展的命题动态逻辑（添加了向后模态算子）建立合适的证明系统。

Method: 为带有向后模态算子的命题动态逻辑扩展引入了一个矢列演算和一个非标记循环证明系统。通过形式化分析证明了这些系统的可靠性和完全性，并研究了消去规则的性质。

Result: 证明了所提出的矢列演算和循环证明系统对于扩展逻辑是可靠且完全的，但两者都缺乏消去规则。同时展示了限制到标准命题动态逻辑的循环证明系统具有消去性质。

Conclusion: 成功为带有向后模态算子的命题动态逻辑扩展建立了矢列演算和循环证明系统，虽然这些系统缺乏消去规则，但为标准的命题动态逻辑保留了消去性质，为动态逻辑的证明理论提供了新的工具。

Abstract: Dynamic logic is a logic for reasoning about programs. A cyclic proof system is a proof system that allows proofs containing cycles and is an alternative to a proof system containing (co-)induction. This paper introduces a sequent calculus and a non-labelled cyclic proof system for an extension of propositional dynamic logic obtained by adding backwards modal operators. We prove the soundness and completeness of these systems and show that cut-elimination fails in both. Moreover, we show the cut-elimination property of the cyclic proof system for propositional dynamic logic obtained by restricting ours.

</details>

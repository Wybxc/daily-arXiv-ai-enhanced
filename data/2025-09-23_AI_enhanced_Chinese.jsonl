{"id": "2509.16268", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2509.16268", "abs": "https://arxiv.org/abs/2509.16268", "authors": ["Zhenlan Ji", "Daoyuan Wu", "Wenxuan Wang", "Pingchuan Ma", "Shuai Wang", "Lei Ma"], "title": "Digging Into the Internal: Causality-Based Analysis of LLM Function Calling", "comment": null, "summary": "Function calling (FC) has emerged as a powerful technique for facilitating\nlarge language models (LLMs) to interact with external systems and perform\nstructured tasks. However, the mechanisms through which it influences model\nbehavior remain largely under-explored. Besides, we discover that in addition\nto the regular usage of FC, this technique can substantially enhance the\ncompliance of LLMs with user instructions. These observations motivate us to\nleverage causality, a canonical analysis method, to investigate how FC works\nwithin LLMs. In particular, we conduct layer-level and token-level causal\ninterventions to dissect FC's impact on the model's internal computational\nlogic when responding to user queries. Our analysis confirms the substantial\ninfluence of FC and reveals several in-depth insights into its mechanisms. To\nfurther validate our findings, we conduct extensive experiments comparing the\neffectiveness of FC-based instructions against conventional prompting methods.\nWe focus on enhancing LLM safety robustness, a critical LLM application\nscenario, and evaluate four mainstream LLMs across two benchmark datasets. The\nresults are striking: FC shows an average performance improvement of around\n135% over conventional prompting methods in detecting malicious inputs,\ndemonstrating its promising potential to enhance LLM reliability and capability\nin practical applications.", "AI": {"tldr": "\u672c\u6587\u901a\u8fc7\u56e0\u679c\u5206\u6790\u65b9\u6cd5\u7814\u7a76\u51fd\u6570\u8c03\u7528\uff08FC\uff09\u5728\u5927\u578b\u8bed\u8a00\u6a21\u578b\uff08LLMs\uff09\u4e2d\u7684\u5de5\u4f5c\u673a\u5236\uff0c\u53d1\u73b0FC\u4e0d\u4ec5\u80fd\u4fc3\u8fdb\u6a21\u578b\u4e0e\u5916\u90e8\u7cfb\u7edf\u4ea4\u4e92\uff0c\u8fd8\u80fd\u663e\u8457\u589e\u5f3a\u6a21\u578b\u5bf9\u7528\u6237\u6307\u4ee4\u7684\u9075\u4ece\u6027\u3002\u5b9e\u9a8c\u8868\u660eFC\u5728\u6076\u610f\u8f93\u5165\u68c0\u6d4b\u65b9\u9762\u6bd4\u4f20\u7edf\u63d0\u793a\u65b9\u6cd5\u5e73\u5747\u63d0\u5347135%\u7684\u6027\u80fd\u3002", "motivation": "\u51fd\u6570\u8c03\u7528\u6280\u672f\u867d\u7136\u5df2\u88ab\u5e7f\u6cdb\u5e94\u7528\u4e8eLLMs\u4e0e\u5916\u90e8\u7cfb\u7edf\u7684\u4ea4\u4e92\uff0c\u4f46\u5176\u5bf9\u6a21\u578b\u884c\u4e3a\u7684\u5f71\u54cd\u673a\u5236\u5c1a\u672a\u5f97\u5230\u5145\u5206\u7814\u7a76\u3002\u4f5c\u8005\u53d1\u73b0FC\u9664\u4e86\u5e38\u89c4\u7528\u9014\u5916\uff0c\u8fd8\u80fd\u663e\u8457\u63d0\u9ad8LLMs\u5bf9\u7528\u6237\u6307\u4ee4\u7684\u9075\u4ece\u6027\uff0c\u8fd9\u4fc3\u4f7f\u4ed6\u4eec\u91c7\u7528\u56e0\u679c\u5206\u6790\u65b9\u6cd5\u6df1\u5165\u63a2\u7a76FC\u7684\u5de5\u4f5c\u673a\u5236\u3002", "method": "\u91c7\u7528\u5c42\u7ea7\u522b\u548c\u4ee4\u724c\u7ea7\u522b\u7684\u56e0\u679c\u5e72\u9884\u65b9\u6cd5\uff0c\u5256\u6790FC\u5728\u6a21\u578b\u54cd\u5e94\u67e5\u8be2\u65f6\u7684\u5185\u90e8\u8ba1\u7b97\u903b\u8f91\u3002\u901a\u8fc7\u5927\u91cf\u5b9e\u9a8c\u6bd4\u8f83\u57fa\u4e8eFC\u7684\u6307\u4ee4\u4e0e\u4f20\u7edf\u63d0\u793a\u65b9\u6cd5\u7684\u6709\u6548\u6027\uff0c\u91cd\u70b9\u5173\u6ce8LLM\u5b89\u5168\u9c81\u68d2\u6027\u8fd9\u4e00\u5173\u952e\u5e94\u7528\u573a\u666f\u3002", "result": "\u56e0\u679c\u5206\u6790\u786e\u8ba4\u4e86FC\u7684\u663e\u8457\u5f71\u54cd\uff0c\u5e76\u63ed\u793a\u4e86\u5176\u5de5\u4f5c\u673a\u5236\u7684\u591a\u4e2a\u6df1\u5165\u89c1\u89e3\u3002\u5728\u56db\u4e2a\u4e3b\u6d41LLMs\u548c\u4e24\u4e2a\u57fa\u51c6\u6570\u636e\u96c6\u4e0a\u7684\u5b9e\u9a8c\u663e\u793a\uff0cFC\u5728\u68c0\u6d4b\u6076\u610f\u8f93\u5165\u65b9\u9762\u6bd4\u4f20\u7edf\u63d0\u793a\u65b9\u6cd5\u5e73\u5747\u6027\u80fd\u63d0\u5347\u7ea6135%\u3002", "conclusion": "FC\u6280\u672f\u663e\u793a\u51fa\u589e\u5f3aLLMs\u5728\u5b9e\u9645\u5e94\u7528\u4e2d\u53ef\u9760\u6027\u548c\u80fd\u529b\u7684\u5de8\u5927\u6f5c\u529b\uff0c\u7279\u522b\u662f\u5728\u5b89\u5168\u9c81\u68d2\u6027\u65b9\u9762\u8868\u73b0\u7a81\u51fa\uff0c\u4e3a\u7406\u89e3FC\u5de5\u4f5c\u673a\u5236\u63d0\u4f9b\u4e86\u65b0\u7684\u5206\u6790\u89c6\u89d2\u3002"}}
{"id": "2509.16478", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.16478", "abs": "https://arxiv.org/abs/2509.16478", "authors": ["Hossein Yousefizadeh", "Shenghui Gu", "Lionel C. Briand", "Ali Nasr"], "title": "Constrained Co-evolutionary Metamorphic Differential Testing for Autonomous Systems with an Interpretability Approach", "comment": null, "summary": "Autonomous systems, such as autonomous driving systems, evolve rapidly\nthrough frequent updates, risking unintended behavioral degradations. Effective\nsystem-level testing is challenging due to the vast scenario space, the absence\nof reliable test oracles, and the need for practically applicable and\ninterpretable test cases. We present CoCoMagic, a novel automated test case\ngeneration method that combines metamorphic testing, differential testing, and\nadvanced search-based techniques to identify behavioral divergences between\nversions of autonomous systems. CoCoMagic formulates test generation as a\nconstrained cooperative co-evolutionary search, evolving both source scenarios\nand metamorphic perturbations to maximize differences in violations of\npredefined metamorphic relations across versions. Constraints and population\ninitialization strategies guide the search toward realistic, relevant\nscenarios. An integrated interpretability approach aids in diagnosing the root\ncauses of divergences. We evaluate CoCoMagic on an end-to-end ADS, InterFuser,\nwithin the Carla virtual simulator. Results show significant improvements over\nbaseline search methods, identifying up to 287\\% more distinct high-severity\nbehavioral differences while maintaining scenario realism. The interpretability\napproach provides actionable insights for developers, supporting targeted\ndebugging and safety assessment. CoCoMagic offers an efficient, effective, and\ninterpretable way for the differential testing of evolving autonomous systems\nacross versions.", "AI": {"tldr": "CoCoMagic\u662f\u4e00\u79cd\u7ed3\u5408\u8715\u53d8\u6d4b\u8bd5\u3001\u5dee\u5f02\u6d4b\u8bd5\u548c\u641c\u7d22\u6280\u672f\u7684\u81ea\u52a8\u5316\u6d4b\u8bd5\u7528\u4f8b\u751f\u6210\u65b9\u6cd5\uff0c\u7528\u4e8e\u68c0\u6d4b\u81ea\u52a8\u9a7e\u9a76\u7cfb\u7edf\u4e0d\u540c\u7248\u672c\u95f4\u7684\u884c\u4e3a\u5dee\u5f02\u3002", "motivation": "\u81ea\u52a8\u9a7e\u9a76\u7cfb\u7edf\u9891\u7e41\u66f4\u65b0\u53ef\u80fd\u5bfc\u81f4\u610f\u5916\u884c\u4e3a\u9000\u5316\uff0c\u4f46\u7cfb\u7edf\u7ea7\u6d4b\u8bd5\u9762\u4e34\u573a\u666f\u7a7a\u95f4\u5927\u3001\u7f3a\u4e4f\u53ef\u9760\u6d4b\u8bd5\u9884\u8a00\u7b49\u6311\u6218\u3002", "method": "\u5c06\u6d4b\u8bd5\u751f\u6210\u5efa\u6a21\u4e3a\u7ea6\u675f\u534f\u540c\u534f\u540c\u8fdb\u5316\u641c\u7d22\uff0c\u540c\u65f6\u8fdb\u5316\u6e90\u573a\u666f\u548c\u8715\u53d8\u6270\u52a8\uff0c\u6700\u5927\u5316\u7248\u672c\u95f4\u8715\u53d8\u5173\u7cfb\u8fdd\u53cd\u5dee\u5f02\u3002\u4f7f\u7528\u7ea6\u675f\u548c\u79cd\u7fa4\u521d\u59cb\u5316\u7b56\u7565\u786e\u4fdd\u573a\u666f\u771f\u5b9e\u6027\u548c\u76f8\u5173\u6027\u3002", "result": "\u5728Carla\u6a21\u62df\u5668\u4e2d\u6d4b\u8bd5InterFuser\u7cfb\u7edf\uff0c\u76f8\u6bd4\u57fa\u7ebf\u65b9\u6cd5\u8bc6\u522b\u51fa287%\u66f4\u591a\u7684\u9ad8\u4e25\u91cd\u6027\u884c\u4e3a\u5dee\u5f02\uff0c\u540c\u65f6\u4fdd\u6301\u573a\u666f\u771f\u5b9e\u6027\u3002", "conclusion": "CoCoMagic\u4e3a\u8fdb\u5316\u4e2d\u7684\u81ea\u4e3b\u7cfb\u7edf\u63d0\u4f9b\u9ad8\u6548\u3001\u6709\u6548\u4e14\u53ef\u89e3\u91ca\u7684\u5dee\u5f02\u6d4b\u8bd5\u65b9\u6cd5\uff0c\u652f\u6301\u9488\u5bf9\u6027\u8c03\u8bd5\u548c\u5b89\u5168\u8bc4\u4f30\u3002"}}
{"id": "2509.16525", "categories": ["cs.SE", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.16525", "abs": "https://arxiv.org/abs/2509.16525", "authors": ["Anna Mazhar", "Sainyam Galhotra"], "title": "Causal Fuzzing for Verifying Machine Unlearning", "comment": null, "summary": "As machine learning models become increasingly embedded in decision-making\nsystems, the ability to \"unlearn\" targeted data or features is crucial for\nenhancing model adaptability, fairness, and privacy in models which involves\nexpensive training. To effectively guide machine unlearning, a thorough testing\nis essential. Existing methods for verification of machine unlearning provide\nlimited insights, often failing in scenarios where the influence is indirect.\nIn this work, we propose CAF\\'E, a new causality based framework that unifies\ndatapoint- and feature-level unlearning for verification of black-box ML\nmodels. CAF\\'E evaluates both direct and indirect effects of unlearning targets\nthrough causal dependencies, providing actionable insights with fine-grained\nanalysis. Our evaluation across five datasets and three model architectures\ndemonstrates that CAF\\'E successfully detects residual influence missed by\nbaselines while maintaining computational efficiency.", "AI": {"tldr": "\u63d0\u51fa\u4e86CAF\u00c9\u6846\u67b6\uff0c\u57fa\u4e8e\u56e0\u679c\u5173\u7cfb\u7684\u9ed1\u76d2\u673a\u5668\u5b66\u4e60\u6a21\u578b\u9a8c\u8bc1\u65b9\u6cd5\uff0c\u7528\u4e8e\u6570\u636e\u70b9\u548c\u7279\u5f81\u7ea7\u522b\u7684\u9057\u5fd8\u9a8c\u8bc1\uff0c\u80fd\u591f\u68c0\u6d4b\u57fa\u7ebf\u65b9\u6cd5\u9057\u6f0f\u7684\u6b8b\u4f59\u5f71\u54cd", "motivation": "\u968f\u7740\u673a\u5668\u5b66\u4e60\u6a21\u578b\u8d8a\u6765\u8d8a\u591a\u5730\u5d4c\u5165\u51b3\u7b56\u7cfb\u7edf\uff0c\u9488\u5bf9\u7279\u5b9a\u6570\u636e\u6216\u7279\u5f81\u7684'\u9057\u5fd8'\u80fd\u529b\u5bf9\u4e8e\u63d0\u9ad8\u6a21\u578b\u9002\u5e94\u6027\u3001\u516c\u5e73\u6027\u548c\u9690\u79c1\u4fdd\u62a4\u81f3\u5173\u91cd\u8981\uff0c\u800c\u73b0\u6709\u9a8c\u8bc1\u65b9\u6cd5\u5728\u95f4\u63a5\u5f71\u54cd\u573a\u666f\u4e0b\u6548\u679c\u6709\u9650", "method": "CAF\u00c9\u6846\u67b6\u901a\u8fc7\u56e0\u679c\u4f9d\u8d56\u5173\u7cfb\u8bc4\u4f30\u9057\u5fd8\u76ee\u6807\u7684\u76f4\u63a5\u548c\u95f4\u63a5\u5f71\u54cd\uff0c\u4e3a\u9ed1\u76d2ML\u6a21\u578b\u63d0\u4f9b\u7ec6\u7c92\u5ea6\u5206\u6790\u548c\u53ef\u64cd\u4f5c\u7684\u89c1\u89e3", "result": "\u5728\u4e94\u4e2a\u6570\u636e\u96c6\u548c\u4e09\u79cd\u6a21\u578b\u67b6\u6784\u4e0a\u7684\u8bc4\u4f30\u8868\u660e\uff0cCAF\u00c9\u6210\u529f\u68c0\u6d4b\u51fa\u57fa\u7ebf\u65b9\u6cd5\u9057\u6f0f\u7684\u6b8b\u4f59\u5f71\u54cd\uff0c\u540c\u65f6\u4fdd\u6301\u8ba1\u7b97\u6548\u7387", "conclusion": "CAF\u00c9\u6846\u67b6\u4e3a\u673a\u5668\u9057\u5fd8\u9a8c\u8bc1\u63d0\u4f9b\u4e86\u66f4\u5168\u9762\u7684\u56e0\u679c\u5206\u6790\u65b9\u6cd5\uff0c\u80fd\u591f\u6709\u6548\u8bc6\u522b\u76f4\u63a5\u548c\u95f4\u63a5\u5f71\u54cd\uff0c\u5177\u6709\u5b9e\u9645\u5e94\u7528\u4ef7\u503c"}}
{"id": "2509.16595", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.16595", "abs": "https://arxiv.org/abs/2509.16595", "authors": ["Jiaming Ye", "Xiongfei Wu", "Shangzhou Xia", "Fuyuan Zhang", "Jianjun Zhao"], "title": "Is Measurement Enough? Rethinking Output Validation in Quantum Program Testing", "comment": "This paper will be appeared in the proceedings of the 40th IEEE/ACM\n  International Conference on Automated Software Engineering (ASE 2025), NIER\n  track, Seoul, South Korea, November 16 -20, 2025", "summary": "As quantum computing continues to emerge, ensuring the quality of quantum\nprograms has become increasingly critical. Quantum program testing has emerged\nas a prominent research area within the scope of quantum software engineering.\nWhile numerous approaches have been proposed to address quantum program quality\nassurance, our analysis reveals that most existing methods rely on\nmeasurement-based validation in practice. However, due to the inherently\nprobabilistic nature of quantum programs, measurement-based validation methods\nface significant limitations.\n  To investigate these limitations, we conducted an empirical study of recent\nresearch on quantum program testing, analyzing measurement-based validation\nmethods in the literature. Our analysis categorizes existing measurement-based\nvalidation methods into two groups: distribution-level validation and\noutput-value-level validation. We then compare measurement-based validation\nwith statevector-based validation methods to evaluate their pros and cons. Our\nfindings demonstrate that measurement-based validation is suitable for\nstraightforward assessments, such as verifying the existence of specific output\nvalues, while statevector-based validation proves more effective for\ncomplicated tasks such as assessing the program behaviors.", "AI": {"tldr": "\u672c\u6587\u5206\u6790\u4e86\u91cf\u5b50\u7a0b\u5e8f\u6d4b\u8bd5\u4e2d\u57fa\u4e8e\u6d4b\u91cf\u7684\u9a8c\u8bc1\u65b9\u6cd5\u7684\u5c40\u9650\u6027\uff0c\u5e76\u5c06\u5176\u4e0e\u57fa\u4e8e\u72b6\u6001\u5411\u91cf\u7684\u9a8c\u8bc1\u65b9\u6cd5\u8fdb\u884c\u6bd4\u8f83\uff0c\u53d1\u73b0\u524d\u8005\u9002\u7528\u4e8e\u7b80\u5355\u9a8c\u8bc1\uff0c\u540e\u8005\u66f4\u9002\u5408\u590d\u6742\u4efb\u52a1\u3002", "motivation": "\u968f\u7740\u91cf\u5b50\u8ba1\u7b97\u7684\u53d1\u5c55\uff0c\u786e\u4fdd\u91cf\u5b50\u7a0b\u5e8f\u8d28\u91cf\u53d8\u5f97\u81f3\u5173\u91cd\u8981\u3002\u73b0\u6709\u7684\u5927\u591a\u6570\u91cf\u5b50\u7a0b\u5e8f\u6d4b\u8bd5\u65b9\u6cd5\u4f9d\u8d56\u57fa\u4e8e\u6d4b\u91cf\u7684\u9a8c\u8bc1\uff0c\u4f46\u7531\u4e8e\u91cf\u5b50\u7a0b\u5e8f\u7684\u6982\u7387\u7279\u6027\uff0c\u8fd9\u4e9b\u65b9\u6cd5\u5b58\u5728\u663e\u8457\u5c40\u9650\u6027\u3002", "method": "\u901a\u8fc7\u5bf9\u8fd1\u671f\u91cf\u5b50\u7a0b\u5e8f\u6d4b\u8bd5\u7814\u7a76\u8fdb\u884c\u5b9e\u8bc1\u5206\u6790\uff0c\u5c06\u57fa\u4e8e\u6d4b\u91cf\u7684\u9a8c\u8bc1\u65b9\u6cd5\u5206\u4e3a\u5206\u5e03\u7ea7\u9a8c\u8bc1\u548c\u8f93\u51fa\u503c\u7ea7\u9a8c\u8bc1\u4e24\u7c7b\uff0c\u5e76\u4e0e\u57fa\u4e8e\u72b6\u6001\u5411\u91cf\u7684\u9a8c\u8bc1\u65b9\u6cd5\u8fdb\u884c\u6bd4\u8f83\u3002", "result": "\u7814\u7a76\u53d1\u73b0\u57fa\u4e8e\u6d4b\u91cf\u7684\u9a8c\u8bc1\u9002\u7528\u4e8e\u7b80\u5355\u8bc4\u4f30\uff08\u5982\u9a8c\u8bc1\u7279\u5b9a\u8f93\u51fa\u503c\u7684\u5b58\u5728\uff09\uff0c\u800c\u57fa\u4e8e\u72b6\u6001\u5411\u91cf\u7684\u9a8c\u8bc1\u5728\u8bc4\u4f30\u590d\u6742\u7a0b\u5e8f\u884c\u4e3a\u65b9\u9762\u66f4\u6709\u6548\u3002", "conclusion": "\u91cf\u5b50\u7a0b\u5e8f\u6d4b\u8bd5\u9700\u8981\u6839\u636e\u4efb\u52a1\u590d\u6742\u5ea6\u9009\u62e9\u5408\u9002\u7684\u9a8c\u8bc1\u65b9\u6cd5\uff0c\u57fa\u4e8e\u6d4b\u91cf\u7684\u9a8c\u8bc1\u9002\u5408\u7b80\u5355\u4efb\u52a1\uff0c\u800c\u57fa\u4e8e\u72b6\u6001\u5411\u91cf\u7684\u9a8c\u8bc1\u66f4\u9002\u5408\u590d\u6742\u884c\u4e3a\u8bc4\u4f30\u3002"}}
{"id": "2509.16246", "categories": ["cs.PL", "cs.AR"], "pdf": "https://arxiv.org/pdf/2509.16246", "abs": "https://arxiv.org/abs/2509.16246", "authors": ["Juxin Niu", "Yuxin Du", "Dan Niu", "Xi Wang", "Zhe Jiang", "Nan Guan"], "title": "VerilogMonkey: Exploring Parallel Scaling for Automated Verilog Code Generation with LLMs", "comment": null, "summary": "We present VerilogMonkey, an empirical study of parallel scaling for the\nunder-explored task of automated Verilog generation. Parallel scaling improves\nLLM performance by sampling many outputs in parallel. Across multiple\nbenchmarks and mainstream LLMs, we find that scaling to hundreds of samples is\ncost-effective in both time and money and, even without any additional\nenhancements such as post-training or agentic methods, surpasses prior results\non LLM-based Verilog generation. We further dissect why parallel scaling\ndelivers these gains and show how output randomness in LLMs affects its\neffectiveness.", "AI": {"tldr": "VerilogMonkey\u662f\u4e00\u4e2a\u5173\u4e8eVerilog\u81ea\u52a8\u751f\u6210\u4efb\u52a1\u4e2d\u5e76\u884c\u6269\u5c55\u7684\u5b9e\u8bc1\u7814\u7a76\uff0c\u53d1\u73b0\u6269\u5c55\u5230\u6570\u767e\u4e2a\u6837\u672c\u5728\u65f6\u95f4\u548c\u6210\u672c\u4e0a\u90fd\u662f\u9ad8\u6548\u7684\uff0c\u4e14\u65e0\u9700\u989d\u5916\u589e\u5f3a\u65b9\u6cd5\u5c31\u80fd\u8d85\u8d8a\u5148\u524d\u57fa\u4e8eLLM\u7684Verilog\u751f\u6210\u7ed3\u679c\u3002", "motivation": "\u7814\u7a76\u5e76\u884c\u6269\u5c55\u5728\u81ea\u52a8\u5316Verilog\u751f\u6210\u8fd9\u4e00\u7814\u7a76\u4e0d\u8db3\u7684\u4efb\u52a1\u4e2d\u7684\u6548\u679c\uff0c\u63a2\u7d22\u5982\u4f55\u901a\u8fc7\u5e76\u884c\u91c7\u6837\u591a\u4e2a\u8f93\u51fa\u6765\u63d0\u5347LLM\u6027\u80fd\u3002", "method": "\u5728\u591a\u4e2a\u57fa\u51c6\u6d4b\u8bd5\u548c\u4e3b\u6d41LLM\u4e0a\u8fdb\u884c\u5b9e\u9a8c\uff0c\u901a\u8fc7\u5e76\u884c\u91c7\u6837\u6570\u767e\u4e2a\u6837\u672c\u6765\u8bc4\u4f30\u5e76\u884c\u6269\u5c55\u7684\u6548\u679c\uff0c\u5e76\u5206\u6790LLM\u8f93\u51fa\u968f\u673a\u6027\u5bf9\u5176\u6709\u6548\u6027\u7684\u5f71\u54cd\u3002", "result": "\u7814\u7a76\u53d1\u73b0\u6269\u5c55\u5230\u6570\u767e\u4e2a\u6837\u672c\u5728\u65f6\u95f4\u548c\u91d1\u94b1\u4e0a\u90fd\u662f\u6210\u672c\u6548\u76ca\u9ad8\u7684\uff0c\u5373\u4f7f\u6ca1\u6709\u4efb\u4f55\u989d\u5916\u7684\u540e\u8bad\u7ec3\u6216\u4ee3\u7406\u65b9\u6cd5\uff0c\u4e5f\u80fd\u8d85\u8d8a\u5148\u524d\u57fa\u4e8eLLM\u7684Verilog\u751f\u6210\u7ed3\u679c\u3002", "conclusion": "\u5e76\u884c\u6269\u5c55\u662f\u63d0\u5347LLM\u5728Verilog\u751f\u6210\u4efb\u52a1\u4e2d\u6027\u80fd\u7684\u6709\u6548\u65b9\u6cd5\uff0cLLM\u8f93\u51fa\u968f\u673a\u6027\u5bf9\u5e76\u884c\u6269\u5c55\u6548\u679c\u6709\u91cd\u8981\u5f71\u54cd\u3002"}}
{"id": "2509.17992", "categories": ["cs.FL", "math.CO", "68Q70, 68Q45, 20M35, 20M30, 06A15, 16D60, 05E99"], "pdf": "https://arxiv.org/pdf/2509.17992", "abs": "https://arxiv.org/abs/2509.17992", "authors": ["Emanuele Rodaro", "Riccardo Venturi"], "title": "The hereditariness problem for the \u010cern\u00fd conjecture", "comment": "24 pages", "summary": "This paper addresses the lifting problem for the \\v{C}ern\\'y conjecture:\nnamely, whether the validity of the conjecture for a quotient automaton can\nalways be transferred (or \"lifted\") to the original automaton. Although a\ncomplete solution remains open, we show that it is sufficient to verify the\n\\v{C}ern\\'y conjecture for three specific subclasses of reset automata:\nradical, simple, and quasi-simple. Our approach relies on establishing a Galois\nconnection between the lattices of congruences and ideals of the transition\nmonoid. This connection not only serves as the main tool in our proofs but also\nprovides a systematic method for computing the radical ideal and for deriving\nstructural insights about these classes. In particular, we show that for every\nsimple or quasi-simple automaton $\\mathcal{A}$, the transition monoid\n$\\text{M}(\\mathcal{A})$ possesses a unique ideal covering the minimal ideal of\nconstant (reset) maps; a result of similar flavor holds for the class of\nradical automata.", "AI": {"tldr": "\u672c\u6587\u7814\u7a76\u4e86\u010cern\u00fd\u731c\u60f3\u7684\u63d0\u5347\u95ee\u9898\uff0c\u8bc1\u660e\u4e86\u53ea\u9700\u9a8c\u8bc1\u4e09\u7c7b\u7279\u5b9a\u91cd\u7f6e\u81ea\u52a8\u673a\uff08\u6839\u5f0f\u3001\u7b80\u5355\u548c\u62df\u7b80\u5355\uff09\u5373\u53ef\u5c06\u731c\u60f3\u7684\u6709\u6548\u6027\u4ece\u5546\u81ea\u52a8\u673a\u8f6c\u79fb\u5230\u539f\u81ea\u52a8\u673a\u3002", "motivation": "\u89e3\u51b3\u010cern\u00fd\u731c\u60f3\u5728\u81ea\u52a8\u673a\u4e4b\u95f4\u7684\u63d0\u5347\u95ee\u9898\uff0c\u5373\u9a8c\u8bc1\u5546\u81ea\u52a8\u673a\u6ee1\u8db3\u731c\u60f3\u65f6\u539f\u81ea\u52a8\u673a\u662f\u5426\u4e5f\u6ee1\u8db3\u3002", "method": "\u901a\u8fc7\u5728\u8f6c\u79fb\u5e7a\u534a\u7fa4\u7684\u540c\u4f59\u683c\u548c\u7406\u60f3\u683c\u4e4b\u95f4\u5efa\u7acbGalois\u8fde\u63a5\uff0c\u8ba1\u7b97\u6839\u5f0f\u7406\u60f3\u5e76\u83b7\u5f97\u7ed3\u6784\u6d1e\u5bdf\u3002", "result": "\u8bc1\u660e\u4e86\u5bf9\u4e8e\u7b80\u5355\u6216\u62df\u7b80\u5355\u81ea\u52a8\u673a\uff0c\u8f6c\u79fb\u5e7a\u534a\u7fa4\u5177\u6709\u8986\u76d6\u5e38\u6570\u6620\u5c04\u6700\u5c0f\u7406\u60f3\u7684\u552f\u4e00\u7406\u60f3\uff1b\u7c7b\u4f3c\u7ed3\u679c\u5bf9\u6839\u5f0f\u81ea\u52a8\u673a\u4e5f\u6210\u7acb\u3002", "conclusion": "\u867d\u7136\u5b8c\u5168\u89e3\u4ecd\u5f00\u653e\uff0c\u4f46\u8bc1\u660e\u4e86\u53ea\u9700\u9a8c\u8bc1\u4e09\u7c7b\u7279\u5b9a\u81ea\u52a8\u673a\u5373\u53ef\u89e3\u51b3\u63d0\u5347\u95ee\u9898\uff0c\u4e3a\u010cern\u00fd\u731c\u60f3\u7814\u7a76\u63d0\u4f9b\u4e86\u65b0\u9014\u5f84\u3002"}}
{"id": "2509.16228", "categories": ["cs.LO"], "pdf": "https://arxiv.org/pdf/2509.16228", "abs": "https://arxiv.org/abs/2509.16228", "authors": ["Paula Blechschmidt"], "title": "Compositional Interface Refinement Through Subtyping in Probabilistic Session Types", "comment": "79 pages, master thesis at Technische Universit\\\"at Berlin", "summary": "Multiparty session types (MPST) are a robust typing framework that ensures\nsafe and deadlock-free communication within distributed protocols. As these\nprotocols grow in complexity, compositional modelling becomes increasingly\nimportant to scalably verify their behaviour. Therefore, we propose using a\nrefinement-based subtyping approach to facilitate the modularity needed for\ncompositional verification. Subtyping in classic MPST systems inherently\nrepresents a notion of refinement: A larger type may be safely substituted by a\nsmaller, refined type. The aim of this thesis is to significantly extend this\nconcept and discover just how flexible and expressive subtyping relations can\nbe. We present a probabilistic extension for MPST, the probabilistic mixed\nchoice multiparty session pi-calculus, with a novel, flexible subtyping system\nwhich allows one channel (the interface) to be substituted by several channels\n(the refinement). Our subtyping is remarkably expressive; any selection of\nwell-typed channels as the refinement has a corresponding interface in a single\nchannel type. To facilitate this generality, we base our system on a powerful\nvariant of MPST, mixed choice multiparty session types (MCMP), which offers\ngreater flexibility in communication choices. We establish soundness of the\nprobabilistic mixed choice multiparty session system through several key\nresults. In particular, we prove subject reduction, error-freedom and\ndeadlock-freedom, ensuring that well-typed processes are well-behaved. This\nwork demonstrates subtyping to possess great previously untapped potential for\nstepwise refinement and compositional verification. The presented framework\nenables highly expressive, compositional, and verifiable modelling of\nprobabilistic distributed communication.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e86\u591a\u6982\u7387\u6df7\u5408\u9009\u62e9\u591a\u65b9\u4f1a\u8bdd\u7c7b\u578b\uff08MCMP\uff09\u7684\u6269\u5c55\u6846\u67b6\uff0c\u5f15\u5165\u4e86\u4e00\u79cd\u65b0\u9896\u7684\u7075\u6d3b\u5b50\u7c7b\u578b\u7cfb\u7edf\uff0c\u5141\u8bb8\u4e00\u4e2a\u901a\u9053\u88ab\u591a\u4e2a\u901a\u9053\u66ff\u4ee3\uff0c\u4ece\u800c\u652f\u6301\u9010\u6b65\u7ec6\u5316\u548c\u7ec4\u5408\u9a8c\u8bc1\u3002", "motivation": "\u968f\u7740\u5206\u5e03\u5f0f\u534f\u8bae\u590d\u6742\u5ea6\u7684\u589e\u52a0\uff0c\u9700\u8981\u7ec4\u5408\u5efa\u6a21\u6765\u53ef\u6269\u5c55\u5730\u9a8c\u8bc1\u5176\u884c\u4e3a\u3002\u7ecf\u5178MPST\u7cfb\u7edf\u4e2d\u7684\u5b50\u7c7b\u578b\u672c\u8d28\u4e0a\u8868\u793a\u4e00\u79cd\u7ec6\u5316\u6982\u5ff5\uff0c\u672c\u6587\u65e8\u5728\u663e\u8457\u6269\u5c55\u8fd9\u4e00\u6982\u5ff5\uff0c\u63a2\u7d22\u5b50\u7c7b\u578b\u5173\u7cfb\u7684\u7075\u6d3b\u6027\u548c\u8868\u8fbe\u80fd\u529b\u3002", "method": "\u63d0\u51fa\u4e86\u6982\u7387\u6df7\u5408\u9009\u62e9\u591a\u65b9\u4f1a\u8bdd\u03c0\u6f14\u7b97\u7684\u6269\u5c55\uff0c\u57fa\u4e8e\u5f3a\u5927\u7684MCMP\u53d8\u4f53\u6784\u5efa\u7cfb\u7edf\uff0c\u5efa\u7acb\u4e86\u6982\u7387\u6df7\u5408\u9009\u62e9\u591a\u65b9\u4f1a\u8bdd\u7cfb\u7edf\u7684\u53ef\u9760\u6027\uff0c\u8bc1\u660e\u4e86\u4e3b\u9898\u7ea6\u7b80\u3001\u65e0\u9519\u8bef\u548c\u65e0\u6b7b\u9501\u7b49\u5173\u952e\u7ed3\u679c\u3002", "result": "\u5f00\u53d1\u51fa\u7684\u5b50\u7c7b\u578b\u7cfb\u7edf\u5177\u6709\u663e\u8457\u8868\u8fbe\u80fd\u529b\uff0c\u4efb\u4f55\u826f\u597d\u7c7b\u578b\u7684\u901a\u9053\u9009\u62e9\u4f5c\u4e3a\u7ec6\u5316\u90fd\u6709\u5bf9\u5e94\u7684\u5355\u901a\u9053\u7c7b\u578b\u63a5\u53e3\u3002\u786e\u4fdd\u4e86\u826f\u597d\u7c7b\u578b\u8fdb\u7a0b\u7684\u826f\u597d\u884c\u4e3a\u3002", "conclusion": "\u8fd9\u9879\u5de5\u4f5c\u5c55\u793a\u4e86\u5b50\u7c7b\u578b\u5728\u9010\u6b65\u7ec6\u5316\u548c\u7ec4\u5408\u9a8c\u8bc1\u65b9\u9762\u5177\u6709\u5de8\u5927\u6f5c\u529b\uff0c\u63d0\u51fa\u7684\u6846\u67b6\u80fd\u591f\u5b9e\u73b0\u9ad8\u5ea6\u8868\u8fbe\u6027\u3001\u7ec4\u5408\u6027\u548c\u53ef\u9a8c\u8bc1\u7684\u6982\u7387\u5206\u5e03\u5f0f\u901a\u4fe1\u5efa\u6a21\u3002"}}
{"id": "2509.16655", "categories": ["cs.SE", "cs.CR", "econ.GN", "q-fin.EC"], "pdf": "https://arxiv.org/pdf/2509.16655", "abs": "https://arxiv.org/abs/2509.16655", "authors": ["Serena Wang", "Martino Banchio", "Krzysztof Kotowicz", "Katrina Ligett", "R. Preston McAfee", "Eduardo' Vela'' Nava"], "title": "Incentives and Outcomes in Bug Bounties", "comment": null, "summary": "Bug bounty programs have contributed significantly to security in technology\nfirms in the last decade, but little is known about the role of reward\nincentives in producing useful outcomes. We analyze incentives and outcomes in\nGoogle's Vulnerability Rewards Program (VRP), one of the world's largest bug\nbounty programs. We analyze the responsiveness of the quality and quantity of\nbugs received to changes in payments, focusing on a change in Google's reward\namounts posted in July, 2024, in which reward amounts increased by up to 200%\nfor the highest impact tier. Our empirical results show an increase in the\nvolume of high-value bugs received after the reward increase, for which we also\ncompute elasticities. We further break down the sources of this increase\nbetween veteran researchers and new researchers, showing that the reward\nincrease both redirected the attention of veteran researchers and attracted new\ntop security researchers into the program.", "AI": {"tldr": "\u8be5\u7814\u7a76\u5206\u6790\u4e86\u8c37\u6b4c\u6f0f\u6d1e\u5956\u52b1\u8ba1\u5212\u4e2d\u5956\u52b1\u6fc0\u52b1\u5bf9\u6f0f\u6d1e\u62a5\u544a\u8d28\u91cf\u548c\u6570\u91cf\u7684\u5f71\u54cd\uff0c\u53d1\u73b0\u5956\u52b1\u91d1\u989d\u589e\u52a0200%\u540e\uff0c\u9ad8\u4ef7\u503c\u6f0f\u6d1e\u62a5\u544a\u91cf\u663e\u8457\u589e\u52a0\uff0c\u4e3b\u8981\u6765\u81ea\u8d44\u6df1\u7814\u7a76\u4eba\u5458\u7684\u5173\u6ce8\u8f6c\u79fb\u548c\u65b0\u7814\u7a76\u4eba\u5458\u7684\u52a0\u5165\u3002", "motivation": "\u7814\u7a76\u52a8\u673a\u662f\u4e86\u89e3\u5956\u52b1\u6fc0\u52b1\u5728\u6f0f\u6d1e\u5956\u52b1\u8ba1\u5212\u4e2d\u7684\u4f5c\u7528\uff0c\u7279\u522b\u662f\u5728\u8c37\u6b4cVRP\u8fd9\u6837\u7684\u5927\u578b\u9879\u76ee\u4e2d\uff0c\u5956\u52b1\u53d8\u5316\u5982\u4f55\u5f71\u54cd\u5b89\u5168\u7814\u7a76\u4eba\u5458\u7684\u884c\u4e3a\u548c\u6f0f\u6d1e\u62a5\u544a\u7684\u8d28\u91cf\u4e0e\u6570\u91cf\u3002", "method": "\u7814\u7a76\u65b9\u6cd5\u5305\u62ec\u5206\u6790\u8c37\u6b4cVRP\u57282024\u5e747\u6708\u5956\u52b1\u91d1\u989d\u589e\u52a0200%\u524d\u540e\u7684\u6570\u636e\uff0c\u8ba1\u7b97\u6f0f\u6d1e\u62a5\u544a\u7684\u5f39\u6027\u7cfb\u6570\uff0c\u5e76\u533a\u5206\u8d44\u6df1\u7814\u7a76\u4eba\u5458\u548c\u65b0\u7814\u7a76\u4eba\u5458\u7684\u5f71\u54cd\u3002", "result": "\u5b9e\u8bc1\u7ed3\u679c\u663e\u793a\uff0c\u5956\u52b1\u589e\u52a0\u540e\u9ad8\u4ef7\u503c\u6f0f\u6d1e\u62a5\u544a\u91cf\u663e\u8457\u4e0a\u5347\uff0c\u5f39\u6027\u7cfb\u6570\u8868\u660e\u5956\u52b1\u5bf9\u6f0f\u6d1e\u62a5\u544a\u6709\u79ef\u6781\u5f71\u54cd\uff0c\u4e14\u8fd9\u79cd\u589e\u957f\u65e2\u6765\u81ea\u8d44\u6df1\u7814\u7a76\u4eba\u5458\u7684\u5173\u6ce8\u8f6c\u79fb\uff0c\u4e5f\u6765\u81ea\u65b0\u9876\u7ea7\u5b89\u5168\u7814\u7a76\u4eba\u5458\u7684\u52a0\u5165\u3002", "conclusion": "\u7ed3\u8bba\u662f\u5956\u52b1\u6fc0\u52b1\u5728\u6f0f\u6d1e\u5956\u52b1\u8ba1\u5212\u4e2d\u5177\u6709\u91cd\u8981\u4f5c\u7528\uff0c\u63d0\u9ad8\u5956\u52b1\u91d1\u989d\u53ef\u4ee5\u6709\u6548\u63d0\u5347\u9ad8\u4ef7\u503c\u6f0f\u6d1e\u7684\u62a5\u544a\u91cf\uff0c\u540c\u65f6\u5438\u5f15\u66f4\u591a\u4f18\u79c0\u5b89\u5168\u7814\u7a76\u4eba\u5458\u53c2\u4e0e\u3002"}}
{"id": "2509.16248", "categories": ["cs.PL", "cs.LG", "cs.SE"], "pdf": "https://arxiv.org/pdf/2509.16248", "abs": "https://arxiv.org/abs/2509.16248", "authors": ["Savini Kashmira", "Jayanaka Dantanarayana", "Thamirawaran Sathiyalogeswaran", "Yichao Yuan", "Nishil Talati", "Krisztian Flautner", "Lingjia Tang", "Jason Mars"], "title": "GraphMend: Code Transformations for Fixing Graph Breaks in PyTorch 2", "comment": null, "summary": "This paper presents GraphMend, a high-level compiler that eliminates FX graph\nbreaks in PyTorch 2 programs. Although PyTorch 2 introduced TorchDynamo and\nTorchInductor to enable just-in-time graph compilation, unresolved dynamic\ncontrol flow and unsupported Python constructs often fragment models into\nmultiple FX graphs. These fragments force frequent fallbacks to eager mode,\nincur costly CPU-to-GPU synchronizations, and reduce optimization\nopportunities. GraphMend addresses this limitation by analyzing and\ntransforming source code before execution. Built on the Jac compilation\nframework, GraphMend introduces two code transformations that remove graph\nbreaks due to dynamic control flow and Python I/O functions. This design allows\nPyTorch's compilation pipeline to capture larger, uninterrupted FX graphs\nwithout requiring manual refactoring by developers. Evaluation across eight\nHugging Face models shows that GraphMend removes all fixable graph breaks due\nto dynamic control flow and Python I/O functions, driving the break count to 0\nin 6 models and reducing it from 5 to 2 in another model. On NVIDIA RTX 3090\nand A40 GPUs, GraphMend achieves up to 75% latency reductions and up to 8%\nhigher end-to-end throughput. These results demonstrate that high-level code\ntransformation is an effective complement to PyTorch's dynamic JIT compilation\npipeline, substantially improving both usability and performance.", "AI": {"tldr": "GraphMend\u662f\u4e00\u4e2a\u9ad8\u7ea7\u7f16\u8bd1\u5668\uff0c\u901a\u8fc7\u4ee3\u7801\u8f6c\u6362\u6d88\u9664PyTorch 2\u7a0b\u5e8f\u4e2d\u7684FX\u56fe\u4e2d\u65ad\u95ee\u9898\uff0c\u63d0\u5347\u7f16\u8bd1\u4f18\u5316\u6548\u679c\u548c\u6027\u80fd", "motivation": "PyTorch 2\u7684TorchDynamo\u548cTorchInductor\u867d\u7136\u652f\u6301\u5373\u65f6\u56fe\u7f16\u8bd1\uff0c\u4f46\u52a8\u6001\u63a7\u5236\u6d41\u548c\u4e0d\u652f\u6301\u7684Python\u6784\u9020\u4f1a\u5bfc\u81f4\u6a21\u578b\u88ab\u5206\u5272\u6210\u591a\u4e2aFX\u56fe\uff0c\u9020\u6210\u9891\u7e41\u56de\u9000\u5230eager\u6a21\u5f0f\u3001CPU-GPU\u540c\u6b65\u5f00\u9500\u548c\u4f18\u5316\u673a\u4f1a\u51cf\u5c11", "method": "\u57fa\u4e8eJac\u7f16\u8bd1\u6846\u67b6\uff0cGraphMend\u5728\u4ee3\u7801\u6267\u884c\u524d\u8fdb\u884c\u5206\u6790\u548c\u8f6c\u6362\uff0c\u5f15\u5165\u4e24\u79cd\u4ee3\u7801\u8f6c\u6362\u6280\u672f\u6765\u6d88\u9664\u52a8\u6001\u63a7\u5236\u6d41\u548cPython I/O\u51fd\u6570\u5bfc\u81f4\u7684\u56fe\u4e2d\u65ad", "result": "\u57288\u4e2aHugging Face\u6a21\u578b\u4e0a\u8bc4\u4f30\uff0cGraphMend\u6d88\u9664\u4e86\u6240\u6709\u53ef\u4fee\u590d\u7684\u56fe\u4e2d\u65ad\uff0c6\u4e2a\u6a21\u578b\u4e2d\u65ad\u6570\u964d\u4e3a0\uff0c\u53e6\u4e00\u4e2a\u6a21\u578b\u4ece5\u964d\u81f32\u3002\u5728RTX 3090\u548cA40 GPU\u4e0a\u5b9e\u73b0\u6700\u9ad875%\u5ef6\u8fdf\u964d\u4f4e\u548c8%\u7aef\u5230\u7aef\u541e\u5410\u91cf\u63d0\u5347", "conclusion": "\u9ad8\u7ea7\u4ee3\u7801\u8f6c\u6362\u662fPyTorch\u52a8\u6001JIT\u7f16\u8bd1\u7ba1\u9053\u7684\u6709\u6548\u8865\u5145\uff0c\u663e\u8457\u63d0\u5347\u4e86\u53ef\u7528\u6027\u548c\u6027\u80fd"}}
{"id": "2509.16237", "categories": ["cs.LO"], "pdf": "https://arxiv.org/pdf/2509.16237", "abs": "https://arxiv.org/abs/2509.16237", "authors": ["Markus Krahl", "Matthias G\u00fcdemann", "Stefan Wallentowitz"], "title": "parSAT: Parallel Solving of Floating-Point Satisfiability", "comment": "In Proceedings FROM 2025, arXiv:2509.11877", "summary": "Satisfiability-based verification techniques, leveraging modern Boolean\nsatisfiability (SAT) and Satisfiability Modulo Theories (SMT) solvers, have\ndemonstrated efficacy in addressing practical problem instances within program\nanalysis. However, current SMT solver implementations often encounter\nlimitations when addressing non-linear arithmetic problems, particularly those\ninvolving floating point (FP) operations. This poses a significant challenge\nfor safety critical applications, where accurate and reliable calculations\nbased on FP numbers and elementary mathematical functions are essential.\n  This paper shows how an alternative formulation of the satisfiability problem\nfor FP calculations allows for exploiting parallelism for FP constraint\nsolving. By combining global optimization approaches with parallel execution on\nmodern multi-core CPUs, we construct a portfolio-based semi-decision procedure\nspecifically tailored to handle FP arithmetic. We demonstrate the potential of\nthis approach to complement conventional methods through the evaluation of\nvarious benchmarks.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u57fa\u4e8e\u5e76\u884c\u6267\u884c\u7684\u6d6e\u70b9\u7ea6\u675f\u6c42\u89e3\u65b9\u6cd5\uff0c\u901a\u8fc7\u7ed3\u5408\u5168\u5c40\u4f18\u5316\u548c\u73b0\u4ee3\u591a\u6838CPU\u7684\u5e76\u884c\u5904\u7406\u80fd\u529b\uff0c\u6784\u5efa\u4e86\u4e13\u95e8\u9488\u5bf9\u6d6e\u70b9\u7b97\u672f\u7684\u57fa\u4e8e\u7ec4\u5408\u7684\u534a\u51b3\u7b56\u7a0b\u5e8f\u3002", "motivation": "\u5f53\u524dSMT\u6c42\u89e3\u5668\u5728\u5904\u7406\u975e\u7ebf\u6027\u7b97\u672f\u95ee\u9898\uff0c\u7279\u522b\u662f\u6d89\u53ca\u6d6e\u70b9\u8fd0\u7b97\u7684\u95ee\u9898\u65f6\u5b58\u5728\u5c40\u9650\u6027\uff0c\u8fd9\u5bf9\u9700\u8981\u7cbe\u786e\u53ef\u9760\u6d6e\u70b9\u8ba1\u7b97\u7684\u5b89\u5168\u5173\u952e\u5e94\u7528\u6784\u6210\u4e86\u91cd\u5927\u6311\u6218\u3002", "method": "\u91c7\u7528\u6d6e\u70b9\u8ba1\u7b97\u7684\u66ff\u4ee3\u6ee1\u8db3\u6027\u516c\u5f0f\u5316\u65b9\u6cd5\uff0c\u7ed3\u5408\u5168\u5c40\u4f18\u5316\u65b9\u6cd5\u548c\u73b0\u4ee3\u591a\u6838CPU\u7684\u5e76\u884c\u6267\u884c\uff0c\u6784\u5efa\u57fa\u4e8e\u7ec4\u5408\u7684\u534a\u51b3\u7b56\u7a0b\u5e8f\u3002", "result": "\u901a\u8fc7\u5bf9\u5404\u79cd\u57fa\u51c6\u6d4b\u8bd5\u7684\u8bc4\u4f30\uff0c\u8bc1\u660e\u4e86\u8be5\u65b9\u6cd5\u5728\u8865\u5145\u4f20\u7edf\u65b9\u6cd5\u65b9\u9762\u7684\u6f5c\u529b\u3002", "conclusion": "\u63d0\u51fa\u7684\u5e76\u884c\u6d6e\u70b9\u7ea6\u675f\u6c42\u89e3\u65b9\u6cd5\u80fd\u591f\u6709\u6548\u89e3\u51b3\u4f20\u7edfSMT\u6c42\u89e3\u5668\u5728\u5904\u7406\u6d6e\u70b9\u7b97\u672f\u65f6\u7684\u5c40\u9650\u6027\uff0c\u4e3a\u5b89\u5168\u5173\u952e\u5e94\u7528\u63d0\u4f9b\u4e86\u66f4\u53ef\u9760\u7684\u9a8c\u8bc1\u624b\u6bb5\u3002"}}
{"id": "2509.16681", "categories": ["cs.SE", "cs.HC"], "pdf": "https://arxiv.org/pdf/2509.16681", "abs": "https://arxiv.org/abs/2509.16681", "authors": ["Peterson Jean"], "title": "Verifying User Interfaces using SPARK Ada: A Case Study of the T34 Syringe Driver", "comment": "62 pages. Master's dissertation submitted to Swansea University,\n  Department of Computer Science, September 2022. Supervisor Dr Jens Blanck", "summary": "The increase in safety and critical systems improved Healthcare. Due to their\nrisk of harm, such systems are subject to stringent guidelines and compliances.\nThese safety measures ensure a seamless experience and mitigate the risk to\nend-users. Institutions like the Food and Drug Administration and the NHS,\nrespectively, established international standards and competency frameworks to\nensure industry compliance with these safety concerns. Medical device\nmanufacturing is mainly concerned with standards. Consequently, these standards\nnow advocate for better human factors considered in user interaction for\nmedical devices. This forces manufacturers to rely on heavy testing and review\nto cover many of these factors during development. Sadly, many human factor\nrisks will not be caught until proper testing in real life, which might be\ncatastrophic in the case of an ambulatory device like the T34 syringe pump.\nTherefore, effort in formal methods research may propose new solutions in\nanticipating these errors in the early stages of development or even reducing\ntheir occurrence based on the use of standard generic model. These generically\ndeveloped models will provide a common framework for safety integration in\nindustry and may potentially be proven using formal verification mathematical\nproofs. This research uses SPARK Ada's formal verification tool against a\nbehavioural model of the T34 syringe driver. A Generic Infusion Pump model\nrefinement is explored and implemented in SPARK Ada. As a subset of the Ada\nlanguage, the verification level of the end prototype is evaluated using SPARK.\nExploring potential limitations defines the proposed model's implementation\nliability when considering abstraction and components of User Interface design\nin SPARK Ada.", "AI": {"tldr": "\u672c\u6587\u63a2\u8ba8\u4e86\u5728\u533b\u7597\u8bbe\u5907\u5f00\u53d1\u4e2d\u4f7f\u7528\u5f62\u5f0f\u5316\u9a8c\u8bc1\u65b9\u6cd5\uff08\u7279\u522b\u662fSPARK Ada\uff09\u6765\u65e9\u671f\u8bc6\u522b\u548c\u51cf\u5c11\u4eba\u4e3a\u56e0\u7d20\u98ce\u9669\u7684\u5fc5\u8981\u6027\uff0c\u5e76\u4ee5T34\u6ce8\u5c04\u6cf5\u4e3a\u4f8b\u8fdb\u884c\u4e86\u6848\u4f8b\u7814\u7a76\u3002", "motivation": "\u533b\u7597\u8bbe\u5907\u7684\u5b89\u5168\u6027\u548c\u5408\u89c4\u6027\u8981\u6c42\u65e5\u76ca\u4e25\u683c\uff0c\u4f46\u4f20\u7edf\u6d4b\u8bd5\u65b9\u6cd5\u5f80\u5f80\u65e0\u6cd5\u5728\u5f00\u53d1\u65e9\u671f\u53d1\u73b0\u6240\u6709\u4eba\u4e3a\u56e0\u7d20\u98ce\u9669\uff0c\u8fd9\u53ef\u80fd\u5bfc\u81f4\u5728\u771f\u5b9e\u4f7f\u7528\u4e2d\u51fa\u73b0\u707e\u96be\u6027\u540e\u679c\u3002", "method": "\u7814\u7a76\u4f7f\u7528SPARK Ada\u7684\u5f62\u5f0f\u5316\u9a8c\u8bc1\u5de5\u5177\u5bf9T34\u6ce8\u5c04\u6cf5\u7684\u884c\u4e3a\u6a21\u578b\u8fdb\u884c\u9a8c\u8bc1\uff0c\u63a2\u7d22\u5e76\u5b9e\u73b0\u4e86\u901a\u7528\u8f93\u6db2\u6cf5\u6a21\u578b\u7684\u7ec6\u5316\uff0c\u8bc4\u4f30\u4e86\u5728SPARK\u4e2d\u5b9e\u73b0\u7684\u6700\u7ec8\u539f\u578b\u7684\u9a8c\u8bc1\u7ea7\u522b\u3002", "result": "\u901a\u8fc7SPARK Ada\u7684\u5f62\u5f0f\u5316\u9a8c\u8bc1\uff0c\u53ef\u4ee5\u5efa\u7acb\u4e00\u4e2a\u901a\u7528\u7684\u5b89\u5168\u96c6\u6210\u6846\u67b6\uff0c\u8be5\u6846\u67b6\u53ef\u80fd\u901a\u8fc7\u6570\u5b66\u8bc1\u660e\u6765\u9a8c\u8bc1\uff0c\u4ece\u800c\u5728\u5f00\u53d1\u65e9\u671f\u9636\u6bb5\u8bc6\u522b\u548c\u51cf\u5c11\u4eba\u4e3a\u56e0\u7d20\u9519\u8bef\u3002", "conclusion": "\u5f62\u5f0f\u5316\u65b9\u6cd5\u7814\u7a76\u4e3a\u533b\u7597\u8bbe\u5907\u5f00\u53d1\u63d0\u4f9b\u4e86\u65b0\u7684\u89e3\u51b3\u65b9\u6848\uff0c\u80fd\u591f\u5728\u5f00\u53d1\u65e9\u671f\u9636\u6bb5\u9884\u6d4b\u9519\u8bef\u5e76\u51cf\u5c11\u5176\u53d1\u751f\uff0c\u4f46\u9700\u8981\u8003\u8651\u62bd\u8c61\u548c\u7528\u6237\u754c\u9762\u8bbe\u8ba1\u7ec4\u4ef6\u5728SPARK Ada\u4e2d\u5b9e\u73b0\u7684\u6f5c\u5728\u5c40\u9650\u6027\u3002"}}
{"id": "2509.17795", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2509.17795", "abs": "https://arxiv.org/abs/2509.17795", "authors": ["Parosh Aziz Abdulla", "Samuel Grahn", "Bengt Jonsson", "Shankaranarayanan Krishna", "Om Swostik Mishra"], "title": "Efficient Linearizability Monitoring", "comment": null, "summary": "This paper revisits the fundamental problem of monitoring the linearizability\nof concurrent stacks, queues, sets, and multisets. Given a history of a library\nimplementing one of these abstract data types, the monitoring problem is to\nanswer whether the given history is linearizable. For stacks, queues, and\n(multi)sets, we present monitoring algorithms with complexities\n$\\mathcal{O}(n^2)$, $\\mathcal{O}(n\\; log\\, n)$, and $\\mathcal{O}{(n)}$,\nrespectively, where $n$ is the number of operations in the input history. For\nstacks and queues, our results hold under the standard assumption of {\\it\ndata-independence}, i.e., the behavior of the library is not sensitive to the\nactual values stored in the data structure. Past works to solve the same\nproblems have cubic time complexity and (more seriously) have correctness\nissues: they either (i) lack correctness proofs or (ii) the suggested\ncorrectness proofs are erroneous (we present counter-examples), or (iii) have\nincorrect algorithms. Our improved complexity results rely on substantially\ndifferent algorithms for which we provide detailed proofs of correctness. We\nhave implemented our stack and queue algorithms in LiMo (Linearizability\nMonitor). We evaluate LiMo and compare it with the state-of-the-art tool Violin\n-- whose correctness proofs we have found errors in -- which checks for\nlinearizability violations. Our experimental evaluation confirms that LiMo\noutperforms Violin regarding both efficiency and scalability.", "AI": {"tldr": "\u672c\u6587\u91cd\u65b0\u5ba1\u89c6\u4e86\u76d1\u63a7\u5e76\u53d1\u6808\u3001\u961f\u5217\u3001\u96c6\u5408\u548c\u591a\u96c6\u7ebf\u6027\u5316\u6027\u7684\u57fa\u672c\u95ee\u9898\uff0c\u63d0\u51fa\u4e86\u66f4\u9ad8\u6548\u7684\u76d1\u63a7\u7b97\u6cd5\uff0c\u5e76\u53d1\u73b0\u4e86\u73b0\u6709\u5de5\u5177\u7684\u7f3a\u9677\u3002", "motivation": "\u73b0\u6709\u76d1\u63a7\u7ebf\u6027\u5316\u6027\u7684\u65b9\u6cd5\u5b58\u5728\u65f6\u95f4\u590d\u6742\u5ea6\u9ad8\uff08\u7acb\u65b9\u7ea7\uff09\u548c\u6b63\u786e\u6027\u95ee\u9898\uff08\u7f3a\u4e4f\u8bc1\u660e\u3001\u8bc1\u660e\u9519\u8bef\u6216\u7b97\u6cd5\u9519\u8bef\uff09\uff0c\u9700\u8981\u5f00\u53d1\u66f4\u9ad8\u6548\u4e14\u6b63\u786e\u6027\u53ef\u9a8c\u8bc1\u7684\u7b97\u6cd5\u3002", "method": "\u9488\u5bf9\u6808\u3001\u961f\u5217\u548c\uff08\u591a\uff09\u96c6\u5408\u5206\u522b\u8bbe\u8ba1\u4e86\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(n\u00b2)\u3001O(n log n)\u548cO(n)\u7684\u76d1\u63a7\u7b97\u6cd5\uff0c\u5176\u4e2dn\u662f\u64cd\u4f5c\u6570\u91cf\u3002\u7b97\u6cd5\u57fa\u4e8e\u6570\u636e\u72ec\u7acb\u6027\u5047\u8bbe\uff0c\u5e76\u63d0\u4f9b\u4e86\u8be6\u7ec6\u7684\u6b63\u786e\u6027\u8bc1\u660e\u3002", "result": "\u5b9e\u73b0\u4e86\u6808\u548c\u961f\u5217\u7b97\u6cd5\u7684\u5de5\u5177LiMo\uff0c\u5b9e\u9a8c\u8bc4\u4f30\u8868\u660eLiMo\u5728\u6548\u7387\u548c\u53ef\u6269\u5c55\u6027\u4e0a\u90fd\u4f18\u4e8e\u73b0\u6709\u5de5\u5177Violin\u3002", "conclusion": "\u672c\u6587\u63d0\u51fa\u7684\u65b0\u7b97\u6cd5\u5728\u4fdd\u8bc1\u6b63\u786e\u6027\u7684\u540c\u65f6\u663e\u8457\u63d0\u9ad8\u4e86\u76d1\u63a7\u6548\u7387\uff0c\u89e3\u51b3\u4e86\u73b0\u6709\u65b9\u6cd5\u5b58\u5728\u7684\u95ee\u9898\uff0c\u4e3a\u5e76\u53d1\u6570\u636e\u7ed3\u6784\u7684\u7ebf\u6027\u5316\u6027\u9a8c\u8bc1\u63d0\u4f9b\u4e86\u66f4\u53ef\u9760\u7684\u89e3\u51b3\u65b9\u6848\u3002"}}
{"id": "2509.16239", "categories": ["cs.LO", "cs.PL", "03B70, 68Q42", "F.4.1; F.4.2; F.4.3; D.3.1"], "pdf": "https://arxiv.org/pdf/2509.16239", "abs": "https://arxiv.org/abs/2509.16239", "authors": ["Jhet Chan"], "title": "G\u00f6del Mirror: A Formal System For Contradiction-Driven Recursion", "comment": "10 pages. Preprint submitted to Logical Methods in Computer Science\n  (LMCS)", "summary": "We introduce the G\\\"odel Mirror, a formal system defined in Lean 4 that\ntreats contradiction as a control signal for recursive structural evolution.\n  Inspired by G\\\"odelian self-reference, our system's operational semantics\nencode symbolic paradoxes as deterministic transitions. Unlike systems designed\nto guarantee normalization, the G\\\"odel Mirror is a minimal and verifiable\narchitecture that leverages a controlled, non-terminating loop as a productive\nfeature.\n  Our Lean 4 mechanization proves that self-referential paradoxes are\ndeterministically encapsulated and resolved into new structures without leading\nto logical explosion, yielding a paraconsistent inference loop: Paradox ->\nEncapsulate -> Reenter -> Node\n  We argue that this calculus opens a new class of symbolic systems in which\ncontradiction is metabolized into structure, providing a formal basis for\nagents capable of resolving internal inconsistencies.", "AI": {"tldr": "G\u00f6del Mirror\u662f\u4e00\u4e2a\u5728Lean 4\u4e2d\u5b9a\u4e49\u7684\u5f62\u5f0f\u7cfb\u7edf\uff0c\u5c06\u77db\u76fe\u4f5c\u4e3a\u9012\u5f52\u7ed3\u6784\u6f14\u5316\u7684\u63a7\u5236\u4fe1\u53f7\uff0c\u5229\u7528\u81ea\u6307\u6096\u8bba\u4f5c\u4e3a\u786e\u5b9a\u6027\u8f6c\u6362\uff0c\u5b9e\u73b0\u77db\u76fe\u5230\u7ed3\u6784\u7684\u8f6c\u5316\u3002", "motivation": "\u53d7\u54e5\u5fb7\u5c14\u81ea\u6307\u542f\u53d1\uff0c\u65e8\u5728\u6784\u5efa\u4e00\u4e2a\u80fd\u591f\u5c06\u77db\u76fe\u4ee3\u8c22\u4e3a\u7ed3\u6784\u7684\u5f62\u5f0f\u7cfb\u7edf\uff0c\u4e3a\u80fd\u591f\u89e3\u51b3\u5185\u90e8\u4e0d\u4e00\u81f4\u6027\u7684\u667a\u80fd\u4f53\u63d0\u4f9b\u5f62\u5f0f\u57fa\u7840\u3002", "method": "\u5728Lean 4\u4e2d\u5b9e\u73b0\u7684\u64cd\u4f5c\u8bed\u4e49\uff0c\u5c06\u7b26\u53f7\u6096\u8bba\u7f16\u7801\u4e3a\u786e\u5b9a\u6027\u8f6c\u6362\uff0c\u901a\u8fc7\u63a7\u5236\u975e\u7ec8\u6b62\u5faa\u73af\u4f5c\u4e3a\u751f\u4ea7\u6027\u7279\u5f81\uff0c\u5b9e\u73b0\u6096\u8bba\u2192\u5c01\u88c5\u2192\u91cd\u5165\u2192\u8282\u70b9\u7684\u63a8\u7406\u5faa\u73af\u3002", "result": "Lean 4\u673a\u68b0\u5316\u8bc1\u660e\u81ea\u6307\u6096\u8bba\u88ab\u786e\u5b9a\u6027\u5c01\u88c5\u5e76\u89e3\u6790\u4e3a\u65b0\u7ed3\u6784\uff0c\u4e0d\u4f1a\u5bfc\u81f4\u903b\u8f91\u7206\u70b8\uff0c\u5f62\u6210\u51c6\u4e00\u81f4\u6027\u63a8\u7406\u5faa\u73af\u3002", "conclusion": "\u8be5\u6f14\u7b97\u5f00\u542f\u4e86\u4e00\u7c7b\u65b0\u7684\u7b26\u53f7\u7cfb\u7edf\uff0c\u5176\u4e2d\u77db\u76fe\u88ab\u4ee3\u8c22\u4e3a\u7ed3\u6784\uff0c\u4e3a\u5177\u6709\u5185\u90e8\u4e0d\u4e00\u81f4\u6027\u89e3\u51b3\u80fd\u529b\u7684\u667a\u80fd\u4f53\u63d0\u4f9b\u4e86\u5f62\u5f0f\u57fa\u7840\u3002"}}
{"id": "2509.16701", "categories": ["cs.SE", "D.2.5; I.2.2; I.2.7"], "pdf": "https://arxiv.org/pdf/2509.16701", "abs": "https://arxiv.org/abs/2509.16701", "authors": ["Shunyu Liu", "Guangdong Bai", "Mark Utting", "Guowei Yang"], "title": "RelRepair: Enhancing Automated Program Repair by Retrieving Relevant Code", "comment": "11 pages, 5 figures, under review at TSE", "summary": "Automated Program Repair (APR) has emerged as a promising paradigm for\nreducing debugging time and improving the overall efficiency of software\ndevelopment. Recent advances in Large Language Models (LLMs) have demonstrated\ntheir potential for automated bug fixing and other software engineering tasks.\nNevertheless, the general-purpose nature of LLM pre-training means these models\noften lack the capacity to perform project-specific repairs, which require\nunderstanding of domain-specific identifiers, code structures, and contextual\nrelationships within a particular codebase. As a result, LLMs may struggle to\ngenerate correct patches when the repair depends on project-specific\ninformation.\n  To address this limitation, we introduce RelRepair, a novel approach that\nretrieves relevant project-specific code to enhance automated program repair.\nRelRepair first identifies relevant function signatures by analyzing function\nnames and code comments within the project. It then conducts deeper code\nanalysis to retrieve code snippets relevant to the repair context. The\nretrieved relevant information is then incorporated into the LLM's input\nprompt, guiding the model to generate more accurate and informed patches. We\nevaluate RelRepair on two widely studied datasets, Defects4J V1.2 and\nManySStuBs4J, and compare its performance against several state-of-the-art\nLLM-based APR approaches. RelRepair successfully repairs 101 bugs in Defects4J\nV1.2. Furthermore, RelRepair achieves a 17.1\\% improvement in the ManySStuBs4J\ndataset, increasing the overall fix rate to 48.3\\%. These results highlight the\nimportance of providing relevant project-specific information to LLMs, shedding\nlight on effective strategies for leveraging LLMs in APR tasks.", "AI": {"tldr": "RelRepair\u662f\u4e00\u79cd\u901a\u8fc7\u68c0\u7d22\u9879\u76ee\u7279\u5b9a\u4ee3\u7801\u6765\u589e\u5f3a\u5927\u578b\u8bed\u8a00\u6a21\u578b\u81ea\u52a8\u7a0b\u5e8f\u4fee\u590d\u80fd\u529b\u7684\u65b0\u65b9\u6cd5\uff0c\u5728Defects4J\u548cManySStuBs4J\u6570\u636e\u96c6\u4e0a\u663e\u8457\u63d0\u5347\u4e86\u4fee\u590d\u6548\u679c\u3002", "motivation": "\u5927\u578b\u8bed\u8a00\u6a21\u578b\u867d\u7136\u5177\u6709\u81ea\u52a8\u4fee\u590d\u7a0b\u5e8f\u7684\u6f5c\u529b\uff0c\u4f46\u7531\u4e8e\u5176\u901a\u7528\u9884\u8bad\u7ec3\u7279\u6027\uff0c\u7f3a\u4e4f\u5bf9\u7279\u5b9a\u9879\u76ee\u7684\u7406\u89e3\u80fd\u529b\uff0c\u96be\u4ee5\u5904\u7406\u9700\u8981\u9879\u76ee\u7279\u5b9a\u4fe1\u606f\u7684\u4fee\u590d\u4efb\u52a1\u3002", "method": "RelRepair\u9996\u5148\u901a\u8fc7\u5206\u6790\u51fd\u6570\u540d\u548c\u4ee3\u7801\u6ce8\u91ca\u8bc6\u522b\u76f8\u5173\u51fd\u6570\u7b7e\u540d\uff0c\u7136\u540e\u8fdb\u884c\u6df1\u5ea6\u4ee3\u7801\u5206\u6790\u68c0\u7d22\u4e0e\u4fee\u590d\u4e0a\u4e0b\u6587\u76f8\u5173\u7684\u4ee3\u7801\u7247\u6bb5\uff0c\u6700\u540e\u5c06\u8fd9\u4e9b\u76f8\u5173\u4fe1\u606f\u6574\u5408\u5230LLM\u7684\u8f93\u5165\u63d0\u793a\u4e2d\u3002", "result": "\u5728Defects4J V1.2\u4e0a\u6210\u529f\u4fee\u590d101\u4e2abug\uff0c\u5728ManySStuBs4J\u6570\u636e\u96c6\u4e0a\u5b9e\u73b0\u4e8617.1%\u7684\u6027\u80fd\u63d0\u5347\uff0c\u603b\u4f53\u4fee\u590d\u7387\u8fbe\u523048.3%\u3002", "conclusion": "\u7814\u7a76\u7ed3\u679c\u8868\u660e\u5411LLM\u63d0\u4f9b\u9879\u76ee\u7279\u5b9a\u76f8\u5173\u4fe1\u606f\u5bf9\u4e8e\u81ea\u52a8\u7a0b\u5e8f\u4fee\u590d\u81f3\u5173\u91cd\u8981\uff0c\u4e3a\u5728APR\u4efb\u52a1\u4e2d\u6709\u6548\u5229\u7528LLM\u63d0\u4f9b\u4e86\u6709\u6548\u7b56\u7565\u3002"}}
{"id": "2509.16270", "categories": ["cs.LO", "cs.IT", "math.IT", "94-02"], "pdf": "https://arxiv.org/pdf/2509.16270", "abs": "https://arxiv.org/abs/2509.16270", "authors": ["Antonio Joaquim Fernandes"], "title": "Equivalence of Halting Problem to Convergence of Power Series", "comment": null, "summary": "This paper establishes an equivalence between the halting problem in\ncomputability theory and the convergence of power series in mathematical\nanalysis.", "AI": {"tldr": "\u672c\u6587\u5efa\u7acb\u4e86\u53ef\u8ba1\u7b97\u6027\u7406\u8bba\u4e2d\u7684\u505c\u673a\u95ee\u9898\u4e0e\u6570\u5b66\u5206\u6790\u4e2d\u5e42\u7ea7\u6570\u6536\u655b\u6027\u7684\u7b49\u4ef7\u5173\u7cfb", "motivation": "\u63a2\u7d22\u8ba1\u7b97\u7406\u8bba\u4e0e\u5206\u6790\u6570\u5b66\u4e4b\u95f4\u7684\u6df1\u5c42\u8054\u7cfb\uff0c\u5bfb\u627e\u4e0d\u540c\u6570\u5b66\u5206\u652f\u4e4b\u95f4\u7684\u7edf\u4e00\u6027", "method": "\u901a\u8fc7\u5f62\u5f0f\u5316\u8bc1\u660e\u5efa\u7acb\u505c\u673a\u95ee\u9898\u4e0e\u5e42\u7ea7\u6570\u6536\u655b\u6027\u4e4b\u95f4\u7684\u7b49\u4ef7\u5173\u7cfb", "result": "\u6210\u529f\u8bc1\u660e\u4e86\u8fd9\u4e24\u4e2a\u770b\u4f3c\u4e0d\u76f8\u5173\u7684\u6570\u5b66\u6982\u5ff5\u5728\u672c\u8d28\u4e0a\u7b49\u4ef7", "conclusion": "\u8fd9\u4e00\u53d1\u73b0\u63ed\u793a\u4e86\u8ba1\u7b97\u7406\u8bba\u4e0e\u5206\u6790\u6570\u5b66\u4e4b\u95f4\u7684\u6df1\u523b\u8054\u7cfb\uff0c\u4e3a\u8de8\u5b66\u79d1\u7814\u7a76\u63d0\u4f9b\u4e86\u65b0\u7684\u89c6\u89d2"}}
{"id": "2509.16795", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.16795", "abs": "https://arxiv.org/abs/2509.16795", "authors": ["Saikat Mondal", "Chanchal K. Roy", "Hong Wang", "Juan Arguello", "Samantha Mathan"], "title": "Can We Trust the AI Pair Programmer? Copilot for API Misuse Detection and Correction", "comment": "Accepted in the 35th IEEE International Conference on Collaborative\n  Advances in Software Computing", "summary": "API misuse introduces security vulnerabilities, system failures, and\nincreases maintenance costs, all of which remain critical challenges in\nsoftware development. Existing detection approaches rely on static analysis or\nmachine learning-based tools that operate post-development, which delays defect\nresolution. Delayed defect resolution can significantly increase the cost and\ncomplexity of maintenance and negatively impact software reliability and user\ntrust. AI-powered code assistants, such as GitHub Copilot, offer the potential\nfor real-time API misuse detection within development environments. This study\nevaluates GitHub Copilot's effectiveness in identifying and correcting API\nmisuse using MUBench, which provides a curated benchmark of misuse cases. We\nconstruct 740 misuse examples, manually and via AI-assisted variants, using\ncorrect usage patterns and misuse specifications. These examples and 147\ncorrect usage cases are analyzed using Copilot integrated in Visual Studio\nCode. Copilot achieved a detection accuracy of 86.2%, precision of 91.2%, and\nrecall of 92.4%. It performed strongly on common misuse types (e.g.,\nmissing-call, null-check) but struggled with compound or context-sensitive\ncases. Notably, Copilot successfully fixed over 95% of the misuses it\nidentified. These findings highlight both the strengths and limitations of\nAI-driven coding assistants, positioning Copilot as a promising tool for\nreal-time pair programming and detecting and fixing API misuses during software\ndevelopment.", "AI": {"tldr": "\u8be5\u7814\u7a76\u8bc4\u4f30\u4e86GitHub Copilot\u5728\u5b9e\u65f6\u68c0\u6d4b\u548c\u4fee\u590dAPI\u8bef\u7528\u65b9\u9762\u7684\u6709\u6548\u6027\uff0c\u4f7f\u7528MUBench\u57fa\u51c6\u6d4b\u8bd5\uff0c\u7ed3\u679c\u663e\u793aCopilot\u68c0\u6d4b\u51c6\u786e\u7387\u8fbe86.2%\uff0c\u6210\u529f\u4fee\u590d\u8d85\u8fc795%\u7684\u8bef\u7528\u6848\u4f8b\u3002", "motivation": "API\u8bef\u7528\u4f1a\u5bfc\u81f4\u5b89\u5168\u6f0f\u6d1e\u3001\u7cfb\u7edf\u6545\u969c\u548c\u7ef4\u62a4\u6210\u672c\u589e\u52a0\uff0c\u73b0\u6709\u68c0\u6d4b\u65b9\u6cd5\u591a\u4e3a\u5f00\u53d1\u540e\u68c0\u6d4b\uff0c\u5ef6\u8fdf\u4e86\u7f3a\u9677\u4fee\u590d\u3002AI\u4ee3\u7801\u52a9\u624b\u5982GitHub Copilot\u6709\u671b\u5728\u5f00\u53d1\u73af\u5883\u4e2d\u5b9e\u73b0\u5b9e\u65f6API\u8bef\u7528\u68c0\u6d4b\u3002", "method": "\u4f7f\u7528MUBench\u57fa\u51c6\u6784\u5efa740\u4e2a\u8bef\u7528\u6848\u4f8b\u548c147\u4e2a\u6b63\u786e\u4f7f\u7528\u6848\u4f8b\uff0c\u901a\u8fc7Visual Studio Code\u4e2d\u7684Copilot\u8fdb\u884c\u5206\u6790\uff0c\u8bc4\u4f30\u5176\u68c0\u6d4b\u51c6\u786e\u7387\u3001\u7cbe\u786e\u5ea6\u3001\u53ec\u56de\u7387\u548c\u4fee\u590d\u80fd\u529b\u3002", "result": "Copilot\u68c0\u6d4b\u51c6\u786e\u738786.2%\uff0c\u7cbe\u786e\u5ea691.2%\uff0c\u53ec\u56de\u738792.4%\uff0c\u5bf9\u5e38\u89c1\u8bef\u7528\u7c7b\u578b\u8868\u73b0\u826f\u597d\uff0c\u4f46\u5bf9\u590d\u6742\u6216\u4e0a\u4e0b\u6587\u76f8\u5173\u6848\u4f8b\u6709\u56f0\u96be\uff0c\u6210\u529f\u4fee\u590d\u8d85\u8fc795%\u7684\u8bef\u7528\u3002", "conclusion": "AI\u9a71\u52a8\u7684\u4ee3\u7801\u52a9\u624b\u5728\u5b9e\u65f6\u68c0\u6d4b\u548c\u4fee\u590dAPI\u8bef\u7528\u65b9\u9762\u5177\u6709\u6f5c\u529b\uff0cCopilot\u53ef\u4f5c\u4e3a\u6709\u524d\u666f\u7684\u5b9e\u65f6\u7ed3\u5bf9\u7f16\u7a0b\u5de5\u5177\uff0c\u4f46\u4ecd\u9700\u6539\u8fdb\u5bf9\u590d\u6742\u6848\u4f8b\u7684\u5904\u7406\u80fd\u529b\u3002"}}
{"id": "2509.17392", "categories": ["cs.LO"], "pdf": "https://arxiv.org/pdf/2509.17392", "abs": "https://arxiv.org/abs/2509.17392", "authors": ["Samuel Arsac", "Russ Harmer", "Damien Pous"], "title": "Adhesive category theory for graph rewriting in Rocq", "comment": null, "summary": "We design a Rocq library about adhesive categories, using Hierarchy Builder\n(HB). It is built around two hierarchies. The first is for categories, with\nusual categories at the bottom and adhesive categories at the top, with weaker\nvariants of adhesive categories in between. The second is for morphisms\n(notably isomorphisms, monomorphisms and regular monomorphisms). Each level of\nthese hierarchies is equipped with several interfaces to define instances. We\ncover basic categorical concepts such as pullbacks and equalizers, as well as\nresults specific to adhesive categories. Using this library, we formalize two\ncentral theorems of categorical graph rewriting theory: the Church-Rosser\ntheorem and the concurrency theorem. We provide several instances, including\nthe category of types, the category of finite types, the category of simple\ngraphs and categories of presheaves. We detail the implementation choices we\nmade and report on the usage of HB for this formalization work.", "AI": {"tldr": "\u672c\u6587\u8bbe\u8ba1\u4e86\u4e00\u4e2a\u5173\u4e8e\u7c98\u5408\u8303\u7574\u7684Rocq\u5e93\uff0c\u4f7f\u7528Hierarchy Builder\u6784\u5efa\u4e86\u4e24\u4e2a\u5c42\u6b21\u7ed3\u6784\uff1a\u8303\u7574\u5c42\u6b21\u548c\u6001\u5c04\u5c42\u6b21\uff0c\u5e76\u5b9e\u73b0\u4e86\u8303\u7574\u56fe\u91cd\u5199\u7406\u8bba\u4e2d\u7684\u4e24\u4e2a\u6838\u5fc3\u5b9a\u7406\u3002", "motivation": "\u52a8\u673a\u662f\u6784\u5efa\u4e00\u4e2a\u5f62\u5f0f\u5316\u7684\u7c98\u5408\u8303\u7574\u5e93\uff0c\u4e3a\u8303\u7574\u56fe\u91cd\u5199\u7406\u8bba\u63d0\u4f9b\u6570\u5b66\u57fa\u7840\uff0c\u5e76\u9a8c\u8bc1Hierarchy Builder\u5728\u5f62\u5f0f\u5316\u6570\u5b66\u4e2d\u7684\u5b9e\u7528\u6027\u3002", "method": "\u4f7f\u7528Hierarchy Builder\u6784\u5efa\u4e24\u4e2a\u5c42\u6b21\u7ed3\u6784\uff1a\u8303\u7574\u5c42\u6b21\uff08\u4ece\u666e\u901a\u8303\u7574\u5230\u7c98\u5408\u8303\u7574\uff09\u548c\u6001\u5c04\u5c42\u6b21\uff08\u540c\u6784\u3001\u5355\u6001\u5c04\u7b49\uff09\uff0c\u5b9e\u73b0\u57fa\u672c\u8303\u7574\u6982\u5ff5\u548c\u7c98\u5408\u8303\u7574\u7279\u5b9a\u7ed3\u679c\u3002", "result": "\u6210\u529f\u5f62\u5f0f\u5316\u4e86Church-Rosser\u5b9a\u7406\u548c\u5e76\u53d1\u5b9a\u7406\uff0c\u63d0\u4f9b\u4e86\u591a\u4e2a\u5b9e\u4f8b\uff08\u7c7b\u578b\u8303\u7574\u3001\u6709\u9650\u7c7b\u578b\u8303\u7574\u3001\u7b80\u5355\u56fe\u8303\u7574\u7b49\uff09\uff0c\u5e76\u9a8c\u8bc1\u4e86HB\u5728\u5f62\u5f0f\u5316\u5de5\u4f5c\u4e2d\u7684\u6709\u6548\u6027\u3002", "conclusion": "\u8be5\u5e93\u4e3a\u8303\u7574\u56fe\u91cd\u5199\u7406\u8bba\u63d0\u4f9b\u4e86\u575a\u5b9e\u7684\u5f62\u5f0f\u5316\u57fa\u7840\uff0c\u8bc1\u660e\u4e86Hierarchy Builder\u5728\u590d\u6742\u6570\u5b66\u7ed3\u6784\u5f62\u5f0f\u5316\u4e2d\u7684\u5b9e\u7528\u4ef7\u503c\u3002"}}
{"id": "2509.16844", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.16844", "abs": "https://arxiv.org/abs/2509.16844", "authors": ["Rim Zrelli", "Henrique Amaral Misson", "Sorelle Kamkuimo", "Maroua Ben Attia", "Abdo Shabah", "Felipe Gohring de Magalhaes", "Gabriela Nicolescu"], "title": "Implementation of the Collision Avoidance System for DO-178C Compliance", "comment": null, "summary": "This technical report presents the detailed implementation of a Collision\nAvoidance System (CAS) for Unmanned Aerial Vehicles (UAVs), developed as a case\nstudy to demonstrate a rigorous methodology for achieving DO-178C compliance in\nsafety-critical software. The CAS is based on functional requirements inspired\nby NASA's Access 5 project and is designed to autonomously detect, evaluate,\nand avoid potential collision threats in real-time, supporting the safe\nintegration of UAVs into civil airspace.\n  The implementation environment combines formal methods, model-based\ndevelopment, and automated verification tools, including Alloy, SPIN, Simulink\nEmbedded Coder, and the LDRA tool suite. The report documents each phase of the\nsoftware lifecycle: requirements specification and validation, architectural\nand detailed design, coding, verification, and traceability, with a strong\nfocus on compliance with DO-178C Design Assurance Level B objectives.\n  Results demonstrate that formal modelling and automated toolchains enabled\nearly detection and correction of specification defects, robust traceability,\nand strong evidence of verification and validation across all development\nstages. Static and dynamic analyses confirmed code quality and coverage, while\nformal verification methods provided mathematical assurance of correctness for\ncritical components. Although the integration phase was not fully implemented,\nthe approach proved effective in addressing certification challenges for UAV\nsafety-critical systems.\n  \\keywords Collision Avoidance System (CAS), Unmanned Aerial Vehicles (UAVs),\nDO-178C compliance, Safety-critical software, Formal methods, Model-based\ndevelopment, Alloy, SPIN model checker, Simulink Embedded Coder, LDRA tool\nsuite, Software verification and validation, Traceability, Certification.", "AI": {"tldr": "\u672c\u6587\u4ecb\u7ecd\u4e86\u4e00\u4e2a\u65e0\u4eba\u673a\u9632\u649e\u7cfb\u7edf\u7684\u8be6\u7ec6\u5b9e\u73b0\uff0c\u4f5c\u4e3a\u5b9e\u73b0DO-178C\u5408\u89c4\u6027\u7684\u6848\u4f8b\u7814\u7a76\uff0c\u5c55\u793a\u4e86\u5728\u5b89\u5168\u5173\u952e\u8f6f\u4ef6\u4e2d\u5e94\u7528\u5f62\u5f0f\u5316\u65b9\u6cd5\u3001\u6a21\u578b\u9a71\u52a8\u5f00\u53d1\u548c\u81ea\u52a8\u5316\u9a8c\u8bc1\u5de5\u5177\u7684\u6709\u6548\u6027\u3002", "motivation": "\u4e3a\u65e0\u4eba\u673a\u5b89\u5168\u96c6\u6210\u5230\u6c11\u7528\u7a7a\u57df\u63d0\u4f9b\u6280\u672f\u652f\u6491\uff0c\u901a\u8fc7\u4e25\u683c\u7684\u8f6f\u4ef6\u5f00\u53d1\u65b9\u6cd5\u5b9e\u73b0DO-178C Design Assurance Level B\u7684\u5408\u89c4\u6027\u8981\u6c42\u3002", "method": "\u7ed3\u5408\u5f62\u5f0f\u5316\u65b9\u6cd5\u3001\u6a21\u578b\u9a71\u52a8\u5f00\u53d1\u548c\u81ea\u52a8\u5316\u9a8c\u8bc1\u5de5\u5177\uff08Alloy\u3001SPIN\u3001Simulink Embedded Coder\u3001LDRA\u5de5\u5177\u5957\u4ef6\uff09\uff0c\u6309\u7167\u8f6f\u4ef6\u751f\u547d\u5468\u671f\u5404\u9636\u6bb5\u8fdb\u884c\u5f00\u53d1\uff0c\u91cd\u70b9\u5173\u6ce8\u9700\u6c42\u89c4\u8303\u9a8c\u8bc1\u3001\u67b6\u6784\u8bbe\u8ba1\u3001\u7f16\u7801\u548c\u53ef\u8ffd\u6eaf\u6027\u3002", "result": "\u5f62\u5f0f\u5316\u5efa\u6a21\u548c\u81ea\u52a8\u5316\u5de5\u5177\u94fe\u80fd\u591f\u65e9\u671f\u53d1\u73b0\u548c\u7ea0\u6b63\u89c4\u8303\u7f3a\u9677\uff0c\u5b9e\u73b0\u5f3a\u5927\u7684\u53ef\u8ffd\u6eaf\u6027\uff0c\u9759\u6001\u548c\u52a8\u6001\u5206\u6790\u786e\u8ba4\u4e86\u4ee3\u7801\u8d28\u91cf\u548c\u8986\u76d6\u7387\uff0c\u5f62\u5f0f\u5316\u9a8c\u8bc1\u65b9\u6cd5\u4e3a\u5173\u952e\u7ec4\u4ef6\u63d0\u4f9b\u4e86\u6570\u5b66\u6b63\u786e\u6027\u4fdd\u8bc1\u3002", "conclusion": "\u8be5\u65b9\u6cd5\u6709\u6548\u89e3\u51b3\u4e86\u65e0\u4eba\u673a\u5b89\u5168\u5173\u952e\u7cfb\u7edf\u7684\u8ba4\u8bc1\u6311\u6218\uff0c\u867d\u7136\u96c6\u6210\u9636\u6bb5\u672a\u5b8c\u5168\u5b9e\u73b0\uff0c\u4f46\u8bc1\u660e\u4e86\u5176\u5728\u5b9e\u73b0DO-178C\u5408\u89c4\u6027\u65b9\u9762\u7684\u6709\u6548\u6027\u3002"}}
{"id": "2509.17623", "categories": ["cs.LO"], "pdf": "https://arxiv.org/pdf/2509.17623", "abs": "https://arxiv.org/abs/2509.17623", "authors": ["Khashayar Irani"], "title": "The Proof-Theoretic Origin of Double Negation Introduction & Elimination", "comment": "Draft", "summary": "This paper investigates the proof-theoretic foundations of double negation\nintroduction (DNI) and double negation elimination (DNE) in classical logic. By\nexamining both sequent calculus and natural deduction, it is shown that these\nrules originate in reductio ad absurdum. The paper demonstrates that both rules\npossess harmony, ensuring balance between introduction and elimination, and\nnormalisation, which guarantees that derivations reduce to canonical form\nwithout detours. These features reveal double negation not as a redundancy, but\nas a mechanism of proof-theoretic stability, securing the disciplined\nintegration of RAA into classical logic.", "AI": {"tldr": "\u672c\u6587\u63a2\u8ba8\u4e86\u7ecf\u5178\u903b\u8f91\u4e2d\u53cc\u91cd\u5426\u5b9a\u5f15\u5165\uff08DNI\uff09\u548c\u53cc\u91cd\u5426\u5b9a\u6d88\u9664\uff08DNE\uff09\u7684\u8bc1\u660e\u8bba\u57fa\u7840\uff0c\u901a\u8fc7\u5206\u6790\u5e8f\u5217\u6f14\u7b97\u548c\u81ea\u7136\u6f14\u7ece\uff0c\u8868\u660e\u8fd9\u4e9b\u89c4\u5219\u6e90\u4e8e\u5f52\u8c2c\u6cd5\uff08RAA\uff09\uff0c\u5e76\u8bc1\u660e\u5b83\u4eec\u5177\u6709\u548c\u8c10\u6027\u548c\u89c4\u8303\u5316\u7279\u6027\u3002", "motivation": "\u7814\u7a76\u53cc\u91cd\u5426\u5b9a\u89c4\u5219\u5728\u7ecf\u5178\u903b\u8f91\u4e2d\u7684\u8bc1\u660e\u8bba\u57fa\u7840\uff0c\u63ed\u793a\u5b83\u4eec\u5982\u4f55\u786e\u4fdd\u5f52\u8c2c\u6cd5\u5728\u903b\u8f91\u7cfb\u7edf\u4e2d\u7684\u7a33\u5b9a\u6574\u5408\uff0c\u800c\u975e\u7b80\u5355\u7684\u5197\u4f59\u3002", "method": "\u901a\u8fc7\u5206\u6790\u5e8f\u5217\u6f14\u7b97\u548c\u81ea\u7136\u6f14\u7ece\u7cfb\u7edf\uff0c\u8003\u5bdf\u53cc\u91cd\u5426\u5b9a\u5f15\u5165\u548c\u6d88\u9664\u89c4\u5219\u7684\u8d77\u6e90\u53ca\u5176\u4e0e\u5f52\u8c2c\u6cd5\u7684\u5173\u7cfb\u3002", "result": "\u8bc1\u660e\u53cc\u91cd\u5426\u5b9a\u89c4\u5219\u5177\u6709\u548c\u8c10\u6027\uff08\u5f15\u5165\u4e0e\u6d88\u9664\u4e4b\u95f4\u7684\u5e73\u8861\uff09\u548c\u89c4\u8303\u5316\uff08\u63a8\u5bfc\u53ef\u7b80\u5316\u4e3a\u89c4\u8303\u5f62\u5f0f\uff09\uff0c\u8868\u660e\u53cc\u91cd\u5426\u5b9a\u662f\u4fdd\u8bc1\u8bc1\u660e\u8bba\u7a33\u5b9a\u6027\u7684\u673a\u5236\u3002", "conclusion": "\u53cc\u91cd\u5426\u5b9a\u4e0d\u662f\u5197\u4f59\uff0c\u800c\u662f\u786e\u4fdd\u5f52\u8c2c\u6cd5\u5728\u7ecf\u5178\u903b\u8f91\u4e2d\u6709\u7eaa\u5f8b\u6574\u5408\u7684\u8bc1\u660e\u8bba\u7a33\u5b9a\u6027\u673a\u5236\u3002"}}
{"id": "2509.16864", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.16864", "abs": "https://arxiv.org/abs/2509.16864", "authors": ["Wei Liu", "Yi Wen Heng", "Feng Lin", "Tse-Hsun", "Chen", "Ahmed E. Hassan"], "title": "MobileUPReg: Identifying User-Perceived Performance Regressions in Mobile OS Versions", "comment": "ASE 2025 Industry Showcase", "summary": "Mobile operating systems (OS) are frequently updated, but such updates can\nunintentionally degrade user experience by introducing performance regressions.\nExisting detection techniques often rely on system-level metrics (e.g., CPU or\nmemory usage) or focus on specific OS components, which may miss regressions\nactually perceived by users -- such as slower responses or UI stutters. To\naddress this gap, we present MobileUPReg, a black-box framework for detecting\nuser-perceived performance regressions across OS versions. MobileUPReg runs the\nsame apps under different OS versions and compares user-perceived performance\nmetrics -- response time, finish time, launch time, and dropped frames -- to\nidentify regressions that are truly perceptible to users. In a large-scale\nstudy, MobileUPReg achieves high accuracy in extracting user-perceived metrics\nand detects user-perceived regressions with 0.96 precision, 0.91 recall, and\n0.93 F1-score -- significantly outperforming a statistical baseline using the\nWilcoxon rank-sum test and Cliff's Delta. MobileUPReg has been deployed in an\nindustrial CI pipeline, where it analyzes thousands of screencasts across\nhundreds of apps daily and has uncovered regressions missed by traditional\ntools. These results demonstrate that MobileUPReg enables accurate, scalable,\nand perceptually aligned regression detection for mobile OS validation.", "AI": {"tldr": "MobileUPReg\u662f\u4e00\u4e2a\u9ed1\u76d2\u6846\u67b6\uff0c\u7528\u4e8e\u68c0\u6d4b\u79fb\u52a8\u64cd\u4f5c\u7cfb\u7edf\u7248\u672c\u95f4\u7684\u7528\u6237\u611f\u77e5\u6027\u80fd\u56de\u5f52\uff0c\u901a\u8fc7\u6bd4\u8f83\u7528\u6237\u53ef\u611f\u77e5\u7684\u6027\u80fd\u6307\u6807\uff08\u5982\u54cd\u5e94\u65f6\u95f4\u3001\u5b8c\u6210\u65f6\u95f4\u7b49\uff09\u6765\u8bc6\u522b\u771f\u6b63\u5f71\u54cd\u7528\u6237\u4f53\u9a8c\u7684\u56de\u5f52\u95ee\u9898\u3002", "motivation": "\u79fb\u52a8\u64cd\u4f5c\u7cfb\u7edf\u9891\u7e41\u66f4\u65b0\u53ef\u80fd\u5f15\u5165\u6027\u80fd\u56de\u5f52\uff0c\u4f46\u73b0\u6709\u68c0\u6d4b\u6280\u672f\u4f9d\u8d56\u7cfb\u7edf\u7ea7\u6307\u6807\u6216\u7279\u5b9a\u7ec4\u4ef6\uff0c\u53ef\u80fd\u9519\u8fc7\u7528\u6237\u5b9e\u9645\u611f\u77e5\u7684\u56de\u5f52\uff08\u5982\u54cd\u5e94\u53d8\u6162\u6216UI\u5361\u987f\uff09\u3002", "method": "MobileUPReg\u5728\u4e0d\u540cOS\u7248\u672c\u4e0a\u8fd0\u884c\u76f8\u540c\u5e94\u7528\uff0c\u6bd4\u8f83\u7528\u6237\u611f\u77e5\u6027\u80fd\u6307\u6807\uff08\u54cd\u5e94\u65f6\u95f4\u3001\u5b8c\u6210\u65f6\u95f4\u3001\u542f\u52a8\u65f6\u95f4\u3001\u4e22\u5e27\u6570\uff09\u6765\u8bc6\u522b\u56de\u5f52\u3002", "result": "\u5728\u5927\u89c4\u6a21\u7814\u7a76\u4e2d\uff0cMobileUPReg\u5728\u63d0\u53d6\u7528\u6237\u611f\u77e5\u6307\u6807\u65b9\u9762\u8fbe\u5230\u9ad8\u51c6\u786e\u7387\uff0c\u68c0\u6d4b\u7528\u6237\u611f\u77e5\u56de\u5f52\u7684\u7cbe\u5ea6\u4e3a0.96\uff0c\u53ec\u56de\u7387\u4e3a0.91\uff0cF1\u5206\u6570\u4e3a0.93\uff0c\u663e\u8457\u4f18\u4e8e\u4f7f\u7528Wilcoxon\u79e9\u548c\u68c0\u9a8c\u548cCliff's Delta\u7684\u7edf\u8ba1\u57fa\u7ebf\u3002", "conclusion": "MobileUPReg\u5df2\u5728\u5de5\u4e1aCI\u6d41\u6c34\u7ebf\u4e2d\u90e8\u7f72\uff0c\u6bcf\u5929\u5206\u6790\u6570\u767e\u4e2a\u5e94\u7528\u7684\u6570\u5343\u4e2a\u5c4f\u5e55\u5f55\u50cf\uff0c\u53d1\u73b0\u4e86\u4f20\u7edf\u5de5\u5177\u9057\u6f0f\u7684\u56de\u5f52\uff0c\u8bc1\u660e\u5176\u80fd\u591f\u5b9e\u73b0\u51c6\u786e\u3001\u53ef\u6269\u5c55\u4e14\u4e0e\u611f\u77e5\u5bf9\u9f50\u7684\u79fb\u52a8OS\u9a8c\u8bc1\u56de\u5f52\u68c0\u6d4b\u3002"}}
{"id": "2509.16870", "categories": ["cs.SE", "cs.CR"], "pdf": "https://arxiv.org/pdf/2509.16870", "abs": "https://arxiv.org/abs/2509.16870", "authors": ["Rui Yang", "Michael Fu", "Chakkrit Tantithamthavorn", "Chetan Arora", "Gunel Gulmammadova", "Joey Chua"], "title": "DecipherGuard: Understanding and Deciphering Jailbreak Prompts for a Safer Deployment of Intelligent Software Systems", "comment": "Under Review", "summary": "Intelligent software systems powered by Large Language Models (LLMs) are\nincreasingly deployed in critical sectors, raising concerns about their safety\nduring runtime. Through an industry-academic collaboration when deploying an\nLLM-powered virtual customer assistant, a critical software engineering\nchallenge emerged: how to enhance a safer deployment of LLM-powered software\nsystems at runtime? While LlamaGuard, the current state-of-the-art runtime\nguardrail, offers protection against unsafe inputs, our study reveals a Defense\nSuccess Rate (DSR) drop of 24% under obfuscation- and template-based jailbreak\nattacks. In this paper, we propose DecipherGuard, a novel framework that\nintegrates a deciphering layer to counter obfuscation-based prompts and a\nlow-rank adaptation mechanism to enhance guardrail effectiveness against\ntemplate-based attacks. Empirical evaluation on over 22,000 prompts\ndemonstrates that DecipherGuard improves DSR by 36% to 65% and Overall\nGuardrail Performance (OGP) by 20% to 50% compared to LlamaGuard and two other\nruntime guardrails. These results highlight the effectiveness of DecipherGuard\nin defending LLM-powered software systems against jailbreak attacks during\nruntime.", "AI": {"tldr": "DecipherGuard\u662f\u4e00\u4e2a\u65b0\u578b\u6846\u67b6\uff0c\u901a\u8fc7\u5728LlamaGuard\u57fa\u7840\u4e0a\u589e\u52a0\u89e3\u5bc6\u5c42\u548c\u4f4e\u79e9\u9002\u5e94\u673a\u5236\uff0c\u663e\u8457\u63d0\u9ad8\u4e86LLM\u8f6f\u4ef6\u7cfb\u7edf\u5728\u8fd0\u884c\u65f6\u5bf9\u6297\u6df7\u6dc6\u548c\u6a21\u677f\u5316\u8d8a\u72f1\u653b\u51fb\u7684\u9632\u5fa1\u80fd\u529b\u3002", "motivation": "\u968f\u7740LLM\u9a71\u52a8\u7684\u667a\u80fd\u8f6f\u4ef6\u7cfb\u7edf\u5728\u5173\u952e\u9886\u57df\u90e8\u7f72\uff0c\u5176\u8fd0\u884c\u65f6\u5b89\u5168\u6027\u6210\u4e3a\u91cd\u8981\u6311\u6218\u3002\u7814\u7a76\u53d1\u73b0\u73b0\u6709\u6700\u5148\u8fdb\u7684LlamaGuard\u5728\u6df7\u6dc6\u548c\u6a21\u677f\u5316\u653b\u51fb\u4e0b\u9632\u5fa1\u6210\u529f\u7387\u4e0b\u964d24%\uff0c\u9700\u8981\u66f4\u6709\u6548\u7684\u8fd0\u884c\u65f6\u4fdd\u62a4\u673a\u5236\u3002", "method": "\u63d0\u51faDecipherGuard\u6846\u67b6\uff0c\u96c6\u6210\u89e3\u5bc6\u5c42\u5bf9\u6297\u6df7\u6dc6\u63d0\u793a\uff0c\u91c7\u7528\u4f4e\u79e9\u9002\u5e94\u673a\u5236\u589e\u5f3a\u5bf9\u6a21\u677f\u5316\u653b\u51fb\u7684\u9632\u62a4\u6548\u679c\u3002", "result": "\u572822,000\u591a\u4e2a\u63d0\u793a\u4e0a\u7684\u5b9e\u8bc1\u8bc4\u4f30\u663e\u793a\uff0c\u76f8\u6bd4LlamaGuard\u548c\u5176\u4ed6\u4e24\u4e2a\u8fd0\u884c\u65f6\u62a4\u680f\uff0cDecipherGuard\u5c06\u9632\u5fa1\u6210\u529f\u7387\u63d0\u9ad836%-65%\uff0c\u6574\u4f53\u62a4\u680f\u6027\u80fd\u63d0\u534720%-50%\u3002", "conclusion": "DecipherGuard\u80fd\u6709\u6548\u9632\u5fa1LLM\u8f6f\u4ef6\u7cfb\u7edf\u5728\u8fd0\u884c\u65f6\u906d\u53d7\u7684\u8d8a\u72f1\u653b\u51fb\uff0c\u663e\u8457\u63d0\u5347\u90e8\u7f72\u5b89\u5168\u6027\u3002"}}
{"id": "2509.16939", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.16939", "abs": "https://arxiv.org/abs/2509.16939", "authors": ["Taehyoun Kim", "Duksan Ryu", "Jongmoon Baik"], "title": "Deep Synthetic Cross-Project Approaches for Software Reliability Growth Modeling", "comment": "Submitted on April 26, 2025. Under review", "summary": "Software Reliability Growth Models (SRGMs) are widely used to predict\nsoftware reliability based on defect discovery data collected during testing or\noperational phases. However, their predictive accuracy often degrades in\ndata-scarce environments, such as early-stage testing or safety-critical\nsystems. Although cross-project transfer learning has been explored to mitigate\nthis issue by leveraging data from past projects, its applicability remains\nlimited due to the scarcity and confidentiality of real-world datasets. To\novercome these limitations, we propose Deep Synthetic Cross-project SRGM\n(DSC-SRGM), a novel approach that integrates synthetic data generation with\ncross-project transfer learning. Synthetic datasets are generated using\ntraditional SRGMs to preserve the statistical characteristics of real-world\ndefect discovery trends. A cross-correlation-based clustering method is applied\nto identify synthetic datasets with patterns similar to the target project.\nThese datasets are then used to train a deep learning model for reliability\nprediction. The proposed method is evaluated on 60 real-world datasets, and its\nperformance is compared with both traditional SRGMs and cross-project deep\nlearning models trained on real-world datasets. DSC-SRGM achieves up to 23.3%\nimprovement in predictive accuracy over traditional SRGMs and 32.2% over\ncross-project deep learning models trained on real-world datasets. However,\nexcessive use of synthetic data or a naive combination of synthetic and\nreal-world data may degrade prediction performance, highlighting the importance\nof maintaining an appropriate data balance. These findings indicate that\nDSC-SRGM is a promising approach for software reliability prediction in\ndata-scarce environments.", "AI": {"tldr": "\u63d0\u51faDSC-SRGM\u65b9\u6cd5\uff0c\u901a\u8fc7\u5408\u6210\u6570\u636e\u751f\u6210\u548c\u8de8\u9879\u76ee\u8fc1\u79fb\u5b66\u4e60\u89e3\u51b3\u6570\u636e\u7a00\u7f3a\u73af\u5883\u4e0b\u8f6f\u4ef6\u53ef\u9760\u6027\u9884\u6d4b\u7cbe\u5ea6\u4e0b\u964d\u7684\u95ee\u9898", "motivation": "\u4f20\u7edf\u8f6f\u4ef6\u53ef\u9760\u6027\u589e\u957f\u6a21\u578b\u5728\u6570\u636e\u7a00\u7f3a\u73af\u5883\uff08\u5982\u65e9\u671f\u6d4b\u8bd5\u9636\u6bb5\u6216\u5b89\u5168\u5173\u952e\u7cfb\u7edf\uff09\u4e2d\u9884\u6d4b\u7cbe\u5ea6\u4e0b\u964d\uff0c\u800c\u8de8\u9879\u76ee\u8fc1\u79fb\u5b66\u4e60\u56e0\u771f\u5b9e\u6570\u636e\u96c6\u7a00\u7f3a\u548c\u4fdd\u5bc6\u6027\u53d7\u9650", "method": "\u4f7f\u7528\u4f20\u7edfSRGMs\u751f\u6210\u5408\u6210\u6570\u636e\u96c6\u4fdd\u7559\u7f3a\u9677\u53d1\u73b0\u8d8b\u52bf\u7684\u7edf\u8ba1\u7279\u5f81\uff0c\u5e94\u7528\u8de8\u76f8\u5173\u805a\u7c7b\u65b9\u6cd5\u8bc6\u522b\u4e0e\u76ee\u6807\u9879\u76ee\u6a21\u5f0f\u76f8\u4f3c\u7684\u5408\u6210\u6570\u636e\u96c6\uff0c\u7136\u540e\u7528\u8fd9\u4e9b\u6570\u636e\u96c6\u8bad\u7ec3\u6df1\u5ea6\u5b66\u4e60\u6a21\u578b\u8fdb\u884c\u53ef\u9760\u6027\u9884\u6d4b", "result": "\u572860\u4e2a\u771f\u5b9e\u6570\u636e\u96c6\u4e0a\u8bc4\u4f30\uff0cDSC-SRGM\u76f8\u6bd4\u4f20\u7edfSRGMs\u9884\u6d4b\u7cbe\u5ea6\u63d0\u534723.3%\uff0c\u76f8\u6bd4\u57fa\u4e8e\u771f\u5b9e\u6570\u636e\u96c6\u7684\u8de8\u9879\u76ee\u6df1\u5ea6\u5b66\u4e60\u6a21\u578b\u63d0\u534732.2%", "conclusion": "DSC-SRGM\u662f\u6570\u636e\u7a00\u7f3a\u73af\u5883\u4e0b\u8f6f\u4ef6\u53ef\u9760\u6027\u9884\u6d4b\u7684\u6709\u524d\u666f\u65b9\u6cd5\uff0c\u4f46\u9700\u6ce8\u610f\u5408\u6210\u6570\u636e\u4f7f\u7528\u91cf\u548c\u4e0e\u771f\u5b9e\u6570\u636e\u7684\u5e73\u8861\uff0c\u907f\u514d\u6027\u80fd\u4e0b\u964d"}}
{"id": "2509.16941", "categories": ["cs.SE", "cs.CL"], "pdf": "https://arxiv.org/pdf/2509.16941", "abs": "https://arxiv.org/abs/2509.16941", "authors": ["Xiang Deng", "Jeff Da", "Edwin Pan", "Yannis Yiming He", "Charles Ide", "Kanak Garg", "Niklas Lauffer", "Andrew Park", "Nitin Pasari", "Chetan Rane", "Karmini Sampath", "Maya Krishnan", "Srivatsa Kundurthy", "Sean Hendryx", "Zifan Wang", "Chen Bo Calvin Zhang", "Noah Jacobson", "Bing Liu", "Brad Kenstler"], "title": "SWE-Bench Pro: Can AI Agents Solve Long-Horizon Software Engineering Tasks?", "comment": null, "summary": "We introduce SWE-Bench Pro, a substantially more challenging benchmark that\nbuilds upon the best practices of SWE-BENCH [25], but is explicitly designed to\ncapture realistic, complex, enterprise-level problems beyond the scope of\nSWE-BENCH. SWE-BENCH PRO contains 1,865 problems sourced from a diverse set of\n41 actively maintained repositories spanning business applications, B2B\nservices, and developer tools. The benchmark is partitioned into a public set\nwith open access to problems sourced from 11 repositories, a held-out set of 12\nrepositories and a commercial set of 18 proprietary repositories where we have\nformal partnership agreements with early-stage startups. Problems in the\nheld-out and the commercial set are not publicly accessible, but we release\nresults on the commercial set. Our benchmark features long-horizon tasks that\nmay require hours to days for a professional software engineer to complete,\noften involving patches across multiple files and substantial code\nmodifications. All tasks are human-verified and augmented with sufficient\ncontext to ensure resolvability. In our evaluation of widely used coding\nmodels, under a unified scaffold, we observe that their performance on\nSWE-Bench PRO remains below 25% (Pass@1), with GPT-5 achieving the highest\nscore to date at 23.3%. To better understand these limitations, we cluster the\nfailure modes observed in the collected agent trajectories for a clearer\ncharacterization of the error patterns exhibited by current models. Overall,\nSWE-BENCH PRO provides a contamination-resistant testbed that more faithfully\ncaptures the complexity and diversity of real-world software development,\nadvancing the pursuit of truly autonomous software engineering agents at a\nprofessional level.", "AI": {"tldr": "SWE-Bench Pro\u662f\u4e00\u4e2a\u6bd4SWE-BENCH\u66f4\u5177\u6311\u6218\u6027\u7684\u57fa\u51c6\u6d4b\u8bd5\uff0c\u4e13\u95e8\u8bbe\u8ba1\u7528\u4e8e\u6355\u6349\u73b0\u5b9e\u4e16\u754c\u4e2d\u590d\u6742\u7684\u4f01\u4e1a\u7ea7\u8f6f\u4ef6\u5de5\u7a0b\u95ee\u9898\uff0c\u5305\u542b1,865\u4e2a\u6765\u81ea41\u4e2a\u6d3b\u8dc3\u4ed3\u5e93\u7684\u95ee\u9898\u3002", "motivation": "\u73b0\u6709\u7684SWE-BENCH\u57fa\u51c6\u65e0\u6cd5\u5145\u5206\u53cd\u6620\u771f\u5b9e\u4f01\u4e1a\u7ea7\u8f6f\u4ef6\u5f00\u53d1\u7684\u590d\u6742\u6027\uff0c\u9700\u8981\u521b\u5efa\u66f4\u80fd\u4ee3\u8868\u4e13\u4e1a\u8f6f\u4ef6\u5de5\u7a0b\u6311\u6218\u7684\u6d4b\u8bd5\u5e73\u53f0\u3002", "method": "\u4ece41\u4e2a\u6d3b\u8dc3\u4ed3\u5e93\u6536\u96c61,865\u4e2a\u95ee\u9898\uff0c\u5206\u4e3a\u516c\u5f00\u96c6\u3001\u4fdd\u7559\u96c6\u548c\u5546\u4e1a\u96c6\u3002\u6240\u6709\u4efb\u52a1\u90fd\u7ecf\u8fc7\u4eba\u5de5\u9a8c\u8bc1\u5e76\u5305\u542b\u8db3\u591f\u4e0a\u4e0b\u6587\uff0c\u786e\u4fdd\u53ef\u89e3\u51b3\u6027\u3002", "result": "\u5728\u7edf\u4e00\u6846\u67b6\u4e0b\u8bc4\u4f30\u5e7f\u6cdb\u4f7f\u7528\u7684\u7f16\u7801\u6a21\u578b\uff0c\u6027\u80fd\u5747\u4f4e\u4e8e25%\uff08Pass@1\uff09\uff0cGPT-5\u8fbe\u5230\u6700\u9ad8\u520623.3%\u3002\u901a\u8fc7\u805a\u7c7b\u5206\u6790\u5931\u8d25\u6a21\u5f0f\u6765\u7406\u89e3\u6a21\u578b\u5c40\u9650\u6027\u3002", "conclusion": "SWE-BENCH PRO\u63d0\u4f9b\u4e86\u4e00\u4e2a\u6297\u6c61\u67d3\u6d4b\u8bd5\u5e73\u53f0\uff0c\u66f4\u771f\u5b9e\u5730\u53cd\u6620\u4e86\u73b0\u5b9e\u4e16\u754c\u8f6f\u4ef6\u5f00\u53d1\u7684\u590d\u6742\u6027\uff0c\u63a8\u52a8\u4e86\u771f\u6b63\u81ea\u4e3b\u8f6f\u4ef6\u5de5\u7a0b\u4ee3\u7406\u7684\u53d1\u5c55\u3002"}}
{"id": "2509.16985", "categories": ["cs.SE", "cs.CR"], "pdf": "https://arxiv.org/pdf/2509.16985", "abs": "https://arxiv.org/abs/2509.16985", "authors": ["James J. Cusick"], "title": "Static Security Vulnerability Scanning of Proprietary and Open-Source Software: An Adaptable Process with Variants and Results", "comment": "A total of 8 pages, 7 figures, 4 tables, and 31 references", "summary": "Software vulnerabilities remain a significant risk factor in achieving\nsecurity objectives within software development organizations. This is\nespecially true where either proprietary or open-source software (OSS) is\nincluded in the technological environment. In this paper an end-to-end process\nwith supporting methods and tools is presented. This industry proven generic\nprocess allows for the custom instantiation, configuration, and execution of\nroutinized code scanning for software vulnerabilities and their prioritized\nremediation. A select set of tools are described for this key DevSecOps\nfunction and placed into an iterative process. Examples of both industrial\nproprietary applications and open-source applications are provided including\nspecific vulnerability instances and a discussion of their treatment. The\nbenefits of each selected tool are considered, and alternative tools are also\nintroduced. Application of this method in a comprehensive SDLC model is also\nreviewed along with prospective enhancements from automation and the\napplication of advanced technologies including AI. Adoption of this method can\nbe achieved with minimal adjustments and with maximum flexibility for results\nin reducing source code vulnerabilities, reducing supply chain risk, and\nimproving the security profile of new or legacy solutions.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u4e2a\u7aef\u5230\u7aef\u7684\u8f6f\u4ef6\u6f0f\u6d1e\u626b\u63cf\u548c\u4fee\u590d\u6d41\u7a0b\uff0c\u5305\u542b\u652f\u6301\u65b9\u6cd5\u548c\u5de5\u5177\uff0c\u7528\u4e8e\u5728DevSecOps\u73af\u5883\u4e2d\u7cfb\u7edf\u5316\u5730\u68c0\u6d4b\u548c\u4f18\u5148\u4fee\u590d\u6e90\u4ee3\u7801\u6f0f\u6d1e\u3002", "motivation": "\u8f6f\u4ef6\u6f0f\u6d1e\u662f\u8f6f\u4ef6\u5f00\u53d1\u7ec4\u7ec7\u5b9e\u73b0\u5b89\u5168\u76ee\u6807\u7684\u91cd\u8981\u98ce\u9669\u56e0\u7d20\uff0c\u7279\u522b\u662f\u5728\u5305\u542b\u4e13\u6709\u6216\u5f00\u6e90\u8f6f\u4ef6\u7684\u6280\u672f\u73af\u5883\u4e2d\uff0c\u9700\u8981\u5efa\u7acb\u7cfb\u7edf\u5316\u7684\u6f0f\u6d1e\u7ba1\u7406\u6d41\u7a0b\u3002", "method": "\u63d0\u51fa\u4e86\u4e00\u4e2a\u884c\u4e1a\u9a8c\u8bc1\u7684\u901a\u7528\u6d41\u7a0b\uff0c\u652f\u6301\u81ea\u5b9a\u4e49\u5b9e\u4f8b\u5316\u3001\u914d\u7f6e\u548c\u6267\u884c\u5e38\u89c4\u4ee3\u7801\u626b\u63cf\uff0c\u5305\u62ec\u6f0f\u6d1e\u68c0\u6d4b\u5de5\u5177\u7684\u9009\u62e9\u548c\u96c6\u6210\uff0c\u5f62\u6210\u8fed\u4ee3\u5f0fDevSecOps\u6d41\u7a0b\u3002", "result": "\u63d0\u4f9b\u4e86\u5de5\u4e1a\u4e13\u6709\u5e94\u7528\u548c\u5f00\u6e90\u5e94\u7528\u7684\u5177\u4f53\u6f0f\u6d1e\u5b9e\u4f8b\u53ca\u5176\u5904\u7406\u65b9\u6cd5\uff0c\u5c55\u793a\u4e86\u6240\u9009\u5de5\u5177\u7684\u4f18\u52bf\uff0c\u5e76\u4ecb\u7ecd\u4e86\u66ff\u4ee3\u5de5\u5177\u9009\u9879\u3002", "conclusion": "\u8be5\u65b9\u6cd5\u53ef\u4ee5\u6700\u5c0f\u5316\u8c03\u6574\u5b9e\u73b0\uff0c\u7075\u6d3b\u5e94\u7528\u4e8eSDLC\u6a21\u578b\uff0c\u901a\u8fc7\u51cf\u5c11\u6e90\u4ee3\u7801\u6f0f\u6d1e\u3001\u964d\u4f4e\u4f9b\u5e94\u94fe\u98ce\u9669\u548c\u6539\u5584\u5b89\u5168\u72b6\u51b5\u6765\u63d0\u5347\u8f6f\u4ef6\u5b89\u5168\u6027\uff0c\u672a\u6765\u53ef\u901a\u8fc7\u81ea\u52a8\u5316\u548cAI\u6280\u672f\u8fdb\u4e00\u6b65\u589e\u5f3a\u3002"}}
{"id": "2509.17096", "categories": ["cs.SE", "cs.AI", "cs.HC"], "pdf": "https://arxiv.org/pdf/2509.17096", "abs": "https://arxiv.org/abs/2509.17096", "authors": ["Ziyou Li", "Agnia Sergeyuk", "Maliheh Izadi"], "title": "Prompt-with-Me: in-IDE Structured Prompt Management for LLM-Driven Software Engineering", "comment": "Accepted in the 40th IEEE/ACM International Conference on Automated\n  Software Engineering, ASE 2025 (Industry track)", "summary": "Large Language Models are transforming software engineering, yet prompt\nmanagement in practice remains ad hoc, hindering reliability, reuse, and\nintegration into industrial workflows. We present Prompt-with-Me, a practical\nsolution for structured prompt management embedded directly in the development\nenvironment. The system automatically classifies prompts using a\nfour-dimensional taxonomy encompassing intent, author role, software\ndevelopment lifecycle stage, and prompt type. To enhance prompt reuse and\nquality, Prompt-with-Me suggests language refinements, masks sensitive\ninformation, and extracts reusable templates from a developer's prompt library.\nOur taxonomy study of 1108 real-world prompts demonstrates that modern LLMs can\naccurately classify software engineering prompts. Furthermore, our user study\nwith 11 participants shows strong developer acceptance, with high usability\n(Mean SUS=73), low cognitive load (Mean NASA-TLX=21), and reported gains in\nprompt quality and efficiency through reduced repetitive effort. Lastly, we\noffer actionable insights for building the next generation of prompt management\nand maintenance tools for software engineering workflows.", "AI": {"tldr": "Prompt-with-Me\u662f\u4e00\u4e2a\u5d4c\u5165\u5f00\u53d1\u73af\u5883\u7684\u7ed3\u6784\u5316\u63d0\u793a\u7ba1\u7406\u7cfb\u7edf\uff0c\u901a\u8fc7\u56db\u7ef4\u5206\u7c7b\u6cd5\u81ea\u52a8\u5206\u7c7b\u63d0\u793a\uff0c\u63d0\u4f9b\u8bed\u8a00\u4f18\u5316\u3001\u654f\u611f\u4fe1\u606f\u5c4f\u853d\u548c\u6a21\u677f\u63d0\u53d6\u529f\u80fd\uff0c\u63d0\u9ad8\u63d0\u793a\u7684\u53ef\u9760\u6027\u548c\u91cd\u7528\u6027\u3002", "motivation": "\u5f53\u524dLLM\u5728\u8f6f\u4ef6\u5de5\u7a0b\u4e2d\u7684\u5e94\u7528\u65e5\u76ca\u5e7f\u6cdb\uff0c\u4f46\u63d0\u793a\u7ba1\u7406\u4ecd\u5904\u4e8e\u4e34\u65f6\u72b6\u6001\uff0c\u963b\u788d\u4e86\u53ef\u9760\u6027\u3001\u91cd\u7528\u6027\u548c\u5de5\u4e1a\u5de5\u4f5c\u6d41\u7684\u96c6\u6210\u3002", "method": "\u5f00\u53d1\u4e86Prompt-with-Me\u7cfb\u7edf\uff0c\u4f7f\u7528\u56db\u7ef4\u5206\u7c7b\u6cd5\uff08\u610f\u56fe\u3001\u4f5c\u8005\u89d2\u8272\u3001\u8f6f\u4ef6\u5f00\u53d1\u751f\u547d\u5468\u671f\u9636\u6bb5\u3001\u63d0\u793a\u7c7b\u578b\uff09\u81ea\u52a8\u5206\u7c7b\u63d0\u793a\uff0c\u5e76\u63d0\u4f9b\u8bed\u8a00\u4f18\u5316\u3001\u654f\u611f\u4fe1\u606f\u5c4f\u853d\u548c\u6a21\u677f\u63d0\u53d6\u529f\u80fd\u3002\u901a\u8fc71108\u4e2a\u771f\u5b9e\u63d0\u793a\u7684\u5206\u7c7b\u7814\u7a76\u548c11\u540d\u53c2\u4e0e\u8005\u7684\u7528\u6237\u7814\u7a76\u9a8c\u8bc1\u7cfb\u7edf\u6548\u679c\u3002", "result": "\u7814\u7a76\u8868\u660e\u73b0\u4ee3LLM\u80fd\u51c6\u786e\u5206\u7c7b\u8f6f\u4ef6\u5de5\u7a0b\u63d0\u793a\uff0c\u7528\u6237\u7814\u7a76\u663e\u793a\u9ad8\u53ef\u7528\u6027\uff08\u5e73\u5747SUS=73\uff09\u3001\u4f4e\u8ba4\u77e5\u8d1f\u8377\uff08\u5e73\u5747NASA-TLX=21\uff09\uff0c\u5f00\u53d1\u8005\u62a5\u544a\u63d0\u793a\u8d28\u91cf\u548c\u6548\u7387\u663e\u8457\u63d0\u5347\u3002", "conclusion": "Prompt-with-Me\u4e3a\u8f6f\u4ef6\u5de5\u7a0b\u5de5\u4f5c\u6d41\u4e2d\u7684\u63d0\u793a\u7ba1\u7406\u548c\u7ef4\u62a4\u5de5\u5177\u63d0\u4f9b\u4e86\u53ef\u884c\u7684\u89e3\u51b3\u65b9\u6848\u548c\u5efa\u8bbe\u6027\u89c1\u89e3\u3002"}}
{"id": "2509.17314", "categories": ["cs.SE", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.17314", "abs": "https://arxiv.org/abs/2509.17314", "authors": ["Juyeon Yoon", "Somin Kim", "Robert Feldt", "Shin Yoo"], "title": "Clotho: Measuring Task-Specific Pre-Generation Test Adequacy for LLM Inputs", "comment": null, "summary": "Software increasingly relies on the emergent capabilities of Large Language\nModels (LLMs), from natural language understanding to program analysis and\ngeneration. Yet testing them on specific tasks remains difficult and costly:\nmany prompts lack ground truth, forcing reliance on human judgment, while\nexisting uncertainty and adequacy measures typically require full inference. A\nkey challenge is to assess input adequacy in a way that reflects the demands of\nthe task, ideally before even generating any output. We introduce CLOTHO, a\ntask-specific, pre-generation adequacy measure that estimates input difficulty\ndirectly from hidden LLM states. Given a large pool of unlabelled inputs for a\nspecific task, CLOTHO uses a Gaussian Mixture Model (GMM) to adaptively sample\nthe most informative cases for human labelling. Based on this reference set the\nGMM can then rank unseen inputs by their likelihood of failure. In our\nempirical evaluation across eight benchmark tasks and three open-weight LLMs,\nCLOTHO can predict failures with a ROC-AUC of 0.716, after labelling reference\nsets that are on average only 5.4% of inputs. It does so without generating any\noutputs, thereby reducing costs compared to existing uncertainty measures.\nComparison of CLOTHO and post-generation uncertainty measures shows that the\ntwo approaches complement each other. Crucially, we show that adequacy scores\nlearnt from open-weight LLMs transfer effectively to proprietary models,\nextending the applicability of the approach. When prioritising test inputs for\nproprietary models, CLOTHO increases the average number of failing inputs from\n18.7 to 42.5 out of 100, compared to random prioritisation.", "AI": {"tldr": "CLOTHO\u662f\u4e00\u79cd\u4efb\u52a1\u7279\u5b9a\u7684\u9884\u751f\u6210\u5145\u5206\u6027\u5ea6\u91cf\u65b9\u6cd5\uff0c\u901a\u8fc7\u5206\u6790LLM\u9690\u85cf\u72b6\u6001\u6765\u4f30\u8ba1\u8f93\u5165\u96be\u5ea6\uff0c\u65e0\u9700\u751f\u6210\u8f93\u51fa\u5373\u53ef\u9884\u6d4b\u6a21\u578b\u5931\u8d25\u6982\u7387\uff0c\u663e\u8457\u964d\u4f4e\u6d4b\u8bd5\u6210\u672c\u3002", "motivation": "\u5f53\u524d\u6d4b\u8bd5LLM\u5728\u7279\u5b9a\u4efb\u52a1\u4e0a\u7684\u8868\u73b0\u5b58\u5728\u56f0\u96be\u4e14\u6210\u672c\u9ad8\u6602\uff0c\u8bb8\u591a\u63d0\u793a\u7f3a\u4e4f\u771f\u5b9e\u6807\u7b7e\uff0c\u9700\u8981\u4f9d\u8d56\u4eba\u5de5\u5224\u65ad\uff0c\u800c\u73b0\u6709\u4e0d\u786e\u5b9a\u6027\u5ea6\u91cf\u901a\u5e38\u9700\u8981\u5b8c\u6574\u63a8\u7406\u8fc7\u7a0b\u3002\u5173\u952e\u6311\u6218\u662f\u5728\u751f\u6210\u8f93\u51fa\u524d\u8bc4\u4f30\u8f93\u5165\u5145\u5206\u6027\u3002", "method": "CLOTHO\u4f7f\u7528\u9ad8\u65af\u6df7\u5408\u6a21\u578b(GMM)\u4ece\u5927\u91cf\u672a\u6807\u8bb0\u8f93\u5165\u4e2d\u81ea\u9002\u5e94\u91c7\u6837\u6700\u5177\u4fe1\u606f\u91cf\u7684\u6848\u4f8b\u8fdb\u884c\u4eba\u5de5\u6807\u6ce8\uff0c\u7136\u540e\u57fa\u4e8e\u53c2\u8003\u96c6\u5bf9\u672a\u89c1\u8f93\u5165\u6309\u5931\u8d25\u53ef\u80fd\u6027\u8fdb\u884c\u6392\u5e8f\u3002\u8be5\u65b9\u6cd5\u76f4\u63a5\u5206\u6790LLM\u9690\u85cf\u72b6\u6001\uff0c\u65e0\u9700\u751f\u6210\u4efb\u4f55\u8f93\u51fa\u3002", "result": "\u57288\u4e2a\u57fa\u51c6\u4efb\u52a1\u548c3\u4e2a\u5f00\u6e90LLM\u4e0a\u7684\u5b9e\u8bc1\u8bc4\u4f30\u663e\u793a\uff0cCLOTHO\u80fd\u4ee50.716\u7684ROC-AUC\u9884\u6d4b\u5931\u8d25\uff0c\u53c2\u8003\u96c6\u6807\u6ce8\u91cf\u5e73\u5747\u4ec5\u4e3a\u8f93\u5165\u76845.4%\u3002\u4ece\u5f00\u6e90LLM\u5b66\u4e60\u7684\u5145\u5206\u6027\u5206\u6570\u80fd\u6709\u6548\u8fc1\u79fb\u5230\u4e13\u6709\u6a21\u578b\uff0c\u76f8\u6bd4\u968f\u673a\u4f18\u5148\u7ea7\u6392\u5e8f\uff0c\u5931\u8d25\u8f93\u5165\u6570\u91cf\u4ece18.7\u589e\u52a0\u523042.5\uff08\u6bcf100\u4e2a\u8f93\u5165\uff09\u3002", "conclusion": "CLOTHO\u63d0\u4f9b\u4e86\u4e00\u79cd\u9ad8\u6548\u7684\u9884\u751f\u6210\u5145\u5206\u6027\u5ea6\u91cf\u65b9\u6cd5\uff0c\u4e0e\u540e\u751f\u6210\u4e0d\u786e\u5b9a\u6027\u5ea6\u91cf\u4e92\u8865\uff0c\u663e\u8457\u964d\u4f4e\u4e86LLM\u6d4b\u8bd5\u6210\u672c\uff0c\u5e76\u5c55\u793a\u4e86\u826f\u597d\u7684\u6a21\u578b\u95f4\u8fc1\u79fb\u80fd\u529b\u3002"}}
{"id": "2509.17335", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.17335", "abs": "https://arxiv.org/abs/2509.17335", "authors": ["Mingxuan Xiao", "Yan Xiao", "Shunhui Ji", "Jiahe Tu", "Pengcheng Zhang"], "title": "BASFuzz: Towards Robustness Evaluation of LLM-based NLP Software via Automated Fuzz Testing", "comment": null, "summary": "Fuzzing has shown great success in evaluating the robustness of intelligent\nnatural language processing (NLP) software. As large language model (LLM)-based\nNLP software is widely deployed in critical industries, existing methods still\nface two main challenges: 1 testing methods are insufficiently coupled with the\nbehavioral patterns of LLM-based NLP software; 2 fuzzing capability for the\ntesting scenario of natural language generation (NLG) generally degrades. To\naddress these issues, we propose BASFuzz, an efficient Fuzz testing method\ntailored for LLM-based NLP software. BASFuzz targets complete test inputs\ncomposed of prompts and examples, and uses a text consistency metric to guide\nmutations of the fuzzing loop, aligning with the behavioral patterns of\nLLM-based NLP software. A Beam-Annealing Search algorithm, which integrates\nbeam search and simulated annealing, is employed to design an efficient fuzzing\nloop. In addition, information entropy-based adaptive adjustment and an elitism\nstrategy further enhance fuzzing capability. We evaluate BASFuzz on six\ndatasets in representative scenarios of NLG and natural language understanding\n(NLU). Experimental results demonstrate that BASFuzz achieves a testing\neffectiveness of 90.335% while reducing the average time overhead by 2,163.852\nseconds compared to the current best baseline, enabling more effective\nrobustness evaluation prior to software deployment.", "AI": {"tldr": "BASFuzz\u662f\u4e00\u79cd\u9488\u5bf9\u57fa\u4e8eLLM\u7684NLP\u8f6f\u4ef6\u7684\u6a21\u7cca\u6d4b\u8bd5\u65b9\u6cd5\uff0c\u901a\u8fc7\u6587\u672c\u4e00\u81f4\u6027\u6307\u6807\u5f15\u5bfc\u53d8\u5f02\uff0c\u7ed3\u5408\u675f\u9000\u706b\u641c\u7d22\u7b97\u6cd5\uff0c\u5728NLG\u548cNLU\u573a\u666f\u4e2d\u663e\u8457\u63d0\u5347\u6d4b\u8bd5\u6548\u679c\u5e76\u964d\u4f4e\u65f6\u95f4\u5f00\u9500\u3002", "motivation": "\u73b0\u6709\u65b9\u6cd5\u5b58\u5728\u4e24\u4e2a\u4e3b\u8981\u6311\u6218\uff1a1) \u6d4b\u8bd5\u65b9\u6cd5\u4e0e\u57fa\u4e8eLLM\u7684NLP\u8f6f\u4ef6\u884c\u4e3a\u6a21\u5f0f\u8026\u5408\u4e0d\u8db3\uff1b2) \u5728\u81ea\u7136\u8bed\u8a00\u751f\u6210(NLG)\u6d4b\u8bd5\u573a\u666f\u4e2d\u6a21\u7cca\u6d4b\u8bd5\u80fd\u529b\u666e\u904d\u4e0b\u964d\u3002", "method": "BASFuzz\u9488\u5bf9\u5305\u542b\u63d0\u793a\u548c\u793a\u4f8b\u7684\u5b8c\u6574\u6d4b\u8bd5\u8f93\u5165\uff0c\u4f7f\u7528\u6587\u672c\u4e00\u81f4\u6027\u6307\u6807\u6307\u5bfc\u6a21\u7cca\u6d4b\u8bd5\u5faa\u73af\u7684\u53d8\u5f02\uff0c\u91c7\u7528\u7ed3\u5408\u675f\u641c\u7d22\u548c\u6a21\u62df\u9000\u706b\u7684\u675f\u9000\u706b\u641c\u7d22\u7b97\u6cd5\uff0c\u5e76\u5f15\u5165\u57fa\u4e8e\u4fe1\u606f\u71b5\u7684\u81ea\u9002\u5e94\u8c03\u6574\u548c\u7cbe\u82f1\u7b56\u7565\u3002", "result": "\u5728\u516d\u4e2aNLG\u548c\u81ea\u7136\u8bed\u8a00\u7406\u89e3(NLU)\u6570\u636e\u96c6\u4e0a\u7684\u5b9e\u9a8c\u7ed3\u679c\u8868\u660e\uff0cBASFuzz\u8fbe\u523090.335%\u7684\u6d4b\u8bd5\u6548\u679c\uff0c\u76f8\u6bd4\u5f53\u524d\u6700\u4f73\u57fa\u7ebf\u5e73\u5747\u51cf\u5c112,163.852\u79d2\u65f6\u95f4\u5f00\u9500\u3002", "conclusion": "BASFuzz\u80fd\u591f\u5728\u8f6f\u4ef6\u90e8\u7f72\u524d\u8fdb\u884c\u66f4\u6709\u6548\u7684\u9c81\u68d2\u6027\u8bc4\u4f30\uff0c\u4e3a\u57fa\u4e8eLLM\u7684NLP\u8f6f\u4ef6\u63d0\u4f9b\u9ad8\u6548\u7684\u6a21\u7cca\u6d4b\u8bd5\u89e3\u51b3\u65b9\u6848\u3002"}}
{"id": "2509.17338", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.17338", "abs": "https://arxiv.org/abs/2509.17338", "authors": ["Pengfei He", "Shaowei Wang", "Tse-Hsun Chen"], "title": "SLICET5: Static Program Slicing using Language Models with Copy Mechanism and Constrained Decoding", "comment": "3 tables, 6 Figures, 12 pages", "summary": "Static program slicing is a fundamental technique in software engineering.\nTraditional static slicing tools rely on parsing complete source code, which\nlimits their applicability to real-world scenarios where code snippets are\nincomplete or unparsable. While recent research developed learning-based\napproaches to predict slices, they face critical challenges: (1) Inaccurate\ndependency identification, where models fail to precisely capture data and\ncontrol dependencies between code elements; and (2) Unconstrained generation,\nwhere models produce slices with extraneous or hallucinated tokens not present\nin the input, violating the structural integrity of slices. To address these\nchallenges, we propose \\ourtool, a novel slicing framework that reformulates\nstatic program slicing as a sequence-to-sequence task using lightweight\nlanguage models (e.g., CodeT5+). Our approach incorporates two key innovations.\nFirst, we introduce a copy mechanism that enables the model to more accurately\ncapture inter-element dependencies and directly copy relevant tokens from the\ninput, improving both dependency reasoning and generation constraint. Second,\nwe design a constrained decoding process with (a) lexical constraint,\nrestricting outputs to input tokens only, and (b) syntactic constraint,\nleveraging Tree Similarity of Edit Distance (TSED) monotonicity to detect\nstructurally invalid outputs and discard them. We evaluate \\ourtool on CodeNet\nand LeetCode datasets and show it consistently outperforms state-of-the-art\nbaselines, improving ExactMatch scores by up to 27\\%. Furthermore, \\ourtool\ndemonstrates strong performance on incomplete code, highlighting its robustness\nand practical utility in real-world development environments.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u57fa\u4e8e\u8f7b\u91cf\u7ea7\u8bed\u8a00\u6a21\u578b\u7684\u9759\u6001\u7a0b\u5e8f\u5207\u7247\u6846\u67b6\uff0c\u901a\u8fc7\u590d\u5236\u673a\u5236\u548c\u7ea6\u675f\u89e3\u7801\u89e3\u51b3\u4f20\u7edf\u65b9\u6cd5\u548c\u5b66\u4e60\u65b9\u6cd5\u7684\u4f9d\u8d56\u8bc6\u522b\u4e0d\u51c6\u786e\u548c\u751f\u6210\u4e0d\u53d7\u7ea6\u675f\u7684\u95ee\u9898\u3002", "motivation": "\u4f20\u7edf\u9759\u6001\u5207\u7247\u5de5\u5177\u9700\u8981\u5b8c\u6574\u6e90\u4ee3\u7801\uff0c\u800c\u5b66\u4e60\u65b9\u6cd5\u5b58\u5728\u4f9d\u8d56\u8bc6\u522b\u4e0d\u51c6\u786e\u548c\u751f\u6210\u4e0d\u53d7\u7ea6\u675f\u7684\u95ee\u9898\uff0c\u9650\u5236\u4e86\u5728\u5b9e\u9645\u5f00\u53d1\u73af\u5883\u4e2d\u7684\u5e94\u7528\u3002", "method": "\u5c06\u9759\u6001\u7a0b\u5e8f\u5207\u7247\u91cd\u6784\u4e3a\u5e8f\u5217\u5230\u5e8f\u5217\u4efb\u52a1\uff0c\u4f7f\u7528\u8f7b\u91cf\u7ea7\u8bed\u8a00\u6a21\u578b\uff0c\u7ed3\u5408\u590d\u5236\u673a\u5236\u548c\u5305\u542b\u8bcd\u6c47\u7ea6\u675f\u4e0e\u8bed\u6cd5\u7ea6\u675f\u7684\u7ea6\u675f\u89e3\u7801\u8fc7\u7a0b\u3002", "result": "\u5728CodeNet\u548cLeetCode\u6570\u636e\u96c6\u4e0a\u8bc4\u4f30\uff0cExactMatch\u5206\u6570\u63d0\u5347\u9ad8\u8fbe27%\uff0c\u5728\u975e\u5b8c\u6574\u4ee3\u7801\u4e0a\u8868\u73b0\u5f3a\u52b2\u3002", "conclusion": "\u8be5\u65b9\u6cd5\u5728\u9759\u6001\u7a0b\u5e8f\u5207\u7247\u4efb\u52a1\u4e0a\u4f18\u4e8e\u73b0\u6709\u6280\u672f\uff0c\u5c55\u793a\u4e86\u5728\u5b9e\u9645\u5f00\u53d1\u73af\u5883\u4e2d\u7684\u9c81\u68d2\u6027\u548c\u5b9e\u7528\u6027\u3002"}}
{"id": "2509.17548", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.17548", "abs": "https://arxiv.org/abs/2509.17548", "authors": ["Hugo Villamizar", "Jannik Fischbach", "Alexander Korn", "Andreas Vogelsang", "Daniel Mendez"], "title": "Prompts as Software Engineering Artifacts: A Research Agenda and Preliminary Findings", "comment": "This paper has been accepted for presentation at the 26th\n  International Conference on Product-Focused Software Process Improvement\n  (PROFES 2025)", "summary": "Developers now routinely interact with large language models (LLMs) to\nsupport a range of software engineering (SE) tasks. This prominent role\npositions prompts as potential SE artifacts that, like other artifacts, may\nrequire systematic development, documentation, and maintenance. However, little\nis known about how prompts are actually used and managed in LLM-integrated\nworkflows, what challenges practitioners face, and whether the benefits of\nsystematic prompt management outweigh the associated effort. To address this\ngap, we propose a research programme that (a) characterizes current prompt\npractices, challenges, and influencing factors in SE; (b) analyzes prompts as\nsoftware artifacts, examining their evolution, traceability, reuse, and the\ntrade-offs of systematic management; and (c) develops and empirically evaluates\nevidence-based guidelines for managing prompts in LLM-integrated workflows. As\na first step, we conducted an exploratory survey with 74 software professionals\nfrom six countries to investigate current prompt practices and challenges. The\nfindings reveal that prompt usage in SE is largely ad-hoc: prompts are often\nrefined through trial-and-error, rarely reused, and shaped more by individual\nheuristics than standardized practices. These insights not only highlight the\nneed for more systematic approaches to prompt management but also provide the\nempirical foundation for the subsequent stages of our research programme.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e00\u4e2a\u7814\u7a76\u8ba1\u5212\uff0c\u65e8\u5728\u7cfb\u7edf\u5316\u5730\u5206\u6790\u548c\u7ba1\u7406\u8f6f\u4ef6\u5de5\u7a0b\u4e2dLLM\u63d0\u793a\u7684\u4f7f\u7528\uff0c\u5305\u62ec\u5f53\u524d\u5b9e\u8df5\u3001\u6311\u6218\u4ee5\u53ca\u63d0\u793a\u4f5c\u4e3a\u8f6f\u4ef6\u5de5\u4ef6\u7684\u7279\u6027\u3002", "motivation": "\u968f\u7740\u5f00\u53d1\u8005\u8d8a\u6765\u8d8a\u591a\u5730\u4f7f\u7528\u5927\u578b\u8bed\u8a00\u6a21\u578b\uff08LLM\uff09\u652f\u6301\u8f6f\u4ef6\u5de5\u7a0b\u4efb\u52a1\uff0c\u63d0\u793a\u5df2\u6210\u4e3a\u91cd\u8981\u7684\u8f6f\u4ef6\u5de5\u7a0b\u5de5\u4ef6\uff0c\u4f46\u7f3a\u4e4f\u5bf9\u5176\u7cfb\u7edf\u5316\u5f00\u53d1\u3001\u6587\u6863\u5316\u548c\u7ef4\u62a4\u7684\u7814\u7a76\u3002", "method": "\u91c7\u7528\u63a2\u7d22\u6027\u8c03\u67e5\u65b9\u6cd5\uff0c\u5bf9\u6765\u81ea\u516d\u4e2a\u56fd\u5bb6\u768474\u540d\u8f6f\u4ef6\u4e13\u4e1a\u4eba\u58eb\u8fdb\u884c\u8c03\u67e5\uff0c\u5206\u6790\u5f53\u524d\u63d0\u793a\u4f7f\u7528\u5b9e\u8df5\u548c\u6311\u6218\uff1b\u5e76\u8ba1\u5212\u540e\u7eed\u7814\u7a76\u5305\u62ec\u63d0\u793a\u7279\u6027\u5206\u6790\u3001\u6f14\u5316\u8ffd\u8e2a\u548c\u5b9e\u8bc1\u8bc4\u4f30\u6307\u5357\u3002", "result": "\u8c03\u67e5\u53d1\u73b0\u63d0\u793a\u5728\u8f6f\u4ef6\u5de5\u7a0b\u4e2d\u7684\u4f7f\u7528\u4e3b\u8981\u662f\u4e34\u65f6\u6027\u7684\uff1a\u63d0\u793a\u901a\u5e38\u901a\u8fc7\u8bd5\u9519\u8fdb\u884c\u4f18\u5316\uff0c\u5f88\u5c11\u88ab\u91cd\u7528\uff0c\u66f4\u591a\u4f9d\u8d56\u4e2a\u4eba\u7ecf\u9a8c\u800c\u975e\u6807\u51c6\u5316\u5b9e\u8df5\u3002", "conclusion": "\u7814\u7a76\u7ed3\u679c\u5f3a\u8c03\u4e86\u9700\u8981\u66f4\u7cfb\u7edf\u5316\u7684\u63d0\u793a\u7ba1\u7406\u65b9\u6cd5\uff0c\u5e76\u4e3a\u540e\u7eed\u7814\u7a76\u9636\u6bb5\u63d0\u4f9b\u4e86\u5b9e\u8bc1\u57fa\u7840\u3002"}}
{"id": "2509.17629", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.17629", "abs": "https://arxiv.org/abs/2509.17629", "authors": ["Antonio Bucchiarone", "Juri Di Rocco", "Damiano Di Vincenzo", "Alfonso Pierantonio"], "title": "From OCL to JSX: declarative constraint modeling in modern SaaS tools", "comment": "10 pages, 2 Figures, Joint Proceedings of the STAF 2025 Workshops:\n  OCL, OOPSLE, LLM4SE, ICMM, AgileMDE, AI4DPS, and TTC. Koblenz, Germany, June\n  10-13, 2025", "summary": "The rise of Node.js in 2010, followed by frameworks like Angular, React, and\nVue.js, has accelerated the growth of low code development platforms. These\nplatforms harness modern UIX paradigms, component-based architectures, and the\nSaaS model to enable non-experts to build software. The widespread adoption of\nsingle-page applications (SPAs), driven by these frameworks, has shaped\nlow-code tools to deliver responsive, client side experiences. In parallel,\nmany modeling platforms have moved to the cloud, adopting either server-centric\narchitectures (e.g., GSLP) or client-side intelligence via SPA frameworks,\nanchoring core components in JavaScript or TypeScript. Within this context,\nOCL.js, a JavaScript-based implementation of the Object Constraint Language,\noffers a web aligned approach to model validation, yet faces challenges such as\npartial standard coverage, limited adoption, and weak integration with modern\nfront-end toolchains. In this paper, we explore JSX, a declarative, functional\nsubset of JavaScript/TypeScript used in the React ecosystem, as an alternative\nto constraint expression in SaaS-based modeling environments. Its\ncomponent-oriented structure supports inductive definitions for syntax, code\ngeneration, and querying. Through empirical evaluation, we compare JSX-based\nconstraints with OCL.js across representative modeling scenarios. Results show\nJSX provides broader expressiveness and better fits front-end-first\narchitectures, indicating a promising path for constraint specification in\nmodern modeling tools.", "AI": {"tldr": "\u672c\u6587\u63a2\u8ba8\u4e86\u5728SaaS\u5efa\u6a21\u73af\u5883\u4e2d\u4f7f\u7528JSX\u4f5c\u4e3a\u7ea6\u675f\u8868\u8fbe\u5f0f\u7684\u66ff\u4ee3\u65b9\u6848\uff0c\u4e0eOCL.js\u8fdb\u884c\u6bd4\u8f83\uff0c\u53d1\u73b0JSX\u5728\u8868\u8fbe\u80fd\u529b\u548c\u524d\u7aef\u67b6\u6784\u9002\u914d\u6027\u65b9\u9762\u8868\u73b0\u66f4\u4f18\u3002", "motivation": "\u968f\u7740Node.js\u548c\u524d\u7aef\u6846\u67b6\u7684\u53d1\u5c55\uff0c\u4f4e\u4ee3\u7801\u5f00\u53d1\u5e73\u53f0\u5174\u8d77\uff0c\u4f46\u73b0\u6709\u7684OCL.js\u5728\u6807\u51c6\u8986\u76d6\u3001\u91c7\u7528\u7387\u548c\u524d\u7aef\u5de5\u5177\u94fe\u96c6\u6210\u65b9\u9762\u5b58\u5728\u4e0d\u8db3\uff0c\u9700\u8981\u63a2\u7d22\u66f4\u9002\u5408\u73b0\u4ee3\u5efa\u6a21\u5de5\u5177\u7684\u7ea6\u675f\u89c4\u8303\u65b9\u6cd5\u3002", "method": "\u901a\u8fc7\u5b9e\u8bc1\u8bc4\u4f30\uff0c\u5728\u4ee3\u8868\u6027\u5efa\u6a21\u573a\u666f\u4e2d\u6bd4\u8f83\u57fa\u4e8eJSX\u7684\u7ea6\u675f\u4e0eOCL.js\uff0c\u5206\u6790JSX\u7684\u58f0\u660e\u5f0f\u3001\u529f\u80fd\u6027\u7279\u6027\u53ca\u5176\u5728React\u751f\u6001\u7cfb\u7edf\u4e2d\u7684\u5e94\u7528\u3002", "result": "JSX\u63d0\u4f9b\u4e86\u66f4\u5e7f\u6cdb\u7684\u8868\u8fbe\u80fd\u529b\uff0c\u5e76\u4e14\u66f4\u9002\u5408\u524d\u7aef\u4f18\u5148\u7684\u67b6\u6784\uff0c\u663e\u793a\u51fa\u5728\u73b0\u4ee3\u5efa\u6a21\u5de5\u5177\u4e2d\u7ea6\u675f\u89c4\u8303\u7684\u6709\u524d\u666f\u7684\u8def\u5f84\u3002", "conclusion": "JSX\u4f5c\u4e3a\u7ea6\u675f\u8868\u8fbe\u5f0f\u5728SaaS\u5efa\u6a21\u73af\u5883\u4e2d\u5177\u6709\u4f18\u52bf\uff0c\u7279\u522b\u662f\u5728\u8868\u8fbe\u80fd\u529b\u548c\u524d\u7aef\u67b6\u6784\u9002\u914d\u6027\u65b9\u9762\uff0c\u4e3a\u73b0\u4ee3\u5efa\u6a21\u5de5\u5177\u63d0\u4f9b\u4e86\u6709\u5e0c\u671b\u7684\u66ff\u4ee3\u65b9\u6848\u3002"}}
{"id": "2509.17776", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.17776", "abs": "https://arxiv.org/abs/2509.17776", "authors": ["Cristina Stratan", "Claudio Mandrioli", "Domenico Bianculli"], "title": "Diagnosing Violations of State-based Specifications in iCFTL", "comment": null, "summary": "As modern software systems grow in complexity and operate in dynamic\nenvironments, the need for runtime analysis techniques becomes a more critical\npart of the verification and validation process. Runtime verification monitors\nthe runtime system behaviour by checking whether an execution trace - a\nsequence of recorded events - satisfies a given specification, yielding a\nBoolean or quantitative verdict. However, when a specification is violated,\nsuch a verdict is often insufficient to understand why the violation happened.\nTo fill this gap, diagnostics approaches aim to produce more informative\nverdicts. In this paper, we address the problem of generating informative\nverdicts for violated Inter-procedural Control-Flow Temporal Logic (iCFTL)\nspecifications that express constraints over program variable values. We\npropose a diagnostic approach based on backward data-flow analysis to\nstatically determine the relevant statements contributing to the specification\nviolation. Using this analysis, we instrument the program to produce enriched\nexecution traces. Using the enriched execution traces, we perform the runtime\nanalysis and identify the statements whose execution led to the specification\nviolation. We implemented our approach in a prototype tool, iCFTL-Diagnostics,\nand evaluated it on 112 specifications across 10 software projects. Our tool\nachieves 90% precision in identifying relevant statements for 100 of the 112\nspecifications. It reduces the number of lines that have to be inspected for\ndiagnosing a violation by at least 90%. In terms of computational cost,\niCFTL-Diagnostics generates a diagnosis within 7 min, and requires no more than\n25 MB of memory. The instrumentation required to support diagnostics incurs an\nexecution time overhead of less than 30% and a memory overhead below 20%.", "AI": {"tldr": "\u8be5\u8bba\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u57fa\u4e8e\u53cd\u5411\u6570\u636e\u6d41\u5206\u6790\u7684\u8bca\u65ad\u65b9\u6cd5\uff0c\u7528\u4e8e\u4e3a\u8fdd\u53cdiCFTL\u89c4\u8303\u7684\u8f6f\u4ef6\u7cfb\u7edf\u751f\u6210\u4fe1\u606f\u4e30\u5bcc\u7684\u8bca\u65ad\u7ed3\u679c\uff0c\u901a\u8fc7\u7a0b\u5e8f\u63d2\u6869\u548c\u8fd0\u884c\u65f6\u5206\u6790\u8bc6\u522b\u5bfc\u81f4\u89c4\u8303\u8fdd\u89c4\u7684\u76f8\u5173\u8bed\u53e5\u3002", "motivation": "\u968f\u7740\u8f6f\u4ef6\u7cfb\u7edf\u590d\u6742\u6027\u548c\u52a8\u6001\u6027\u7684\u589e\u52a0\uff0c\u8fd0\u884c\u65f6\u9a8c\u8bc1\u6280\u672f\u53d8\u5f97\u81f3\u5173\u91cd\u8981\u3002\u7136\u800c\uff0c\u5f53\u89c4\u8303\u88ab\u8fdd\u53cd\u65f6\uff0c\u4f20\u7edf\u7684\u5e03\u5c14\u6216\u5b9a\u91cf\u5224\u51b3\u4e0d\u8db3\u4ee5\u7406\u89e3\u8fdd\u89c4\u539f\u56e0\uff0c\u9700\u8981\u66f4\u4fe1\u606f\u5316\u7684\u8bca\u65ad\u65b9\u6cd5\u3002", "method": "\u63d0\u51fa\u57fa\u4e8e\u53cd\u5411\u6570\u636e\u6d41\u5206\u6790\u7684\u8bca\u65ad\u65b9\u6cd5\uff0c\u9759\u6001\u786e\u5b9a\u5bfc\u81f4\u89c4\u8303\u8fdd\u89c4\u7684\u76f8\u5173\u8bed\u53e5\uff0c\u901a\u8fc7\u7a0b\u5e8f\u63d2\u6869\u751f\u6210\u589e\u5f3a\u7684\u6267\u884c\u8f68\u8ff9\uff0c\u5728\u8fd0\u884c\u65f6\u5206\u6790\u4e2d\u8bc6\u522b\u5bfc\u81f4\u8fdd\u89c4\u7684\u5177\u4f53\u8bed\u53e5\u3002", "result": "\u539f\u578b\u5de5\u5177iCFTL-Diagnostics\u572810\u4e2a\u8f6f\u4ef6\u9879\u76ee\u7684112\u4e2a\u89c4\u8303\u4e0a\u8bc4\u4f30\uff0c90%\u7684\u7cbe\u786e\u5ea6\u8bc6\u522b\u76f8\u5173\u8bed\u53e5\uff0c\u8bca\u65ad\u8fdd\u89c4\u9700\u68c0\u67e5\u7684\u4ee3\u7801\u884c\u6570\u51cf\u5c11\u81f3\u5c1190%\uff0c\u8ba1\u7b97\u6210\u672c\u57287\u5206\u949f\u5185\u751f\u6210\u8bca\u65ad\uff0c\u5185\u5b58\u4f7f\u7528\u4e0d\u8d85\u8fc725MB\uff0c\u63d2\u6869\u5e26\u6765\u7684\u6267\u884c\u65f6\u95f4\u5f00\u9500\u4f4e\u4e8e30%\uff0c\u5185\u5b58\u5f00\u9500\u4f4e\u4e8e20%\u3002", "conclusion": "\u8be5\u65b9\u6cd5\u80fd\u6709\u6548\u751f\u6210\u4fe1\u606f\u4e30\u5bcc\u7684\u8bca\u65ad\u7ed3\u679c\uff0c\u663e\u8457\u51cf\u5c11\u8bca\u65ad\u5de5\u4f5c\u91cf\uff0c\u5177\u6709\u8f83\u4f4e\u7684\u8ba1\u7b97\u5f00\u9500\uff0c\u4e3a\u590d\u6742\u8f6f\u4ef6\u7cfb\u7edf\u7684\u8fd0\u884c\u65f6\u9a8c\u8bc1\u63d0\u4f9b\u4e86\u5b9e\u7528\u7684\u8bca\u65ad\u89e3\u51b3\u65b9\u6848\u3002"}}

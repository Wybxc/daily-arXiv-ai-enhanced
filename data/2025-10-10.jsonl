{"id": "2510.07435", "categories": ["cs.SE", "cs.HC"], "pdf": "https://arxiv.org/pdf/2510.07435", "abs": "https://arxiv.org/abs/2510.07435", "authors": ["Zixuan Feng", "Sadia Afroz", "Anita Sarma"], "title": "Modeling Developer Burnout with GenAI Adoption", "comment": "10 pages, LLM", "summary": "Generative AI (GenAI) is rapidly reshaping software development workflows.\nWhile prior studies emphasize productivity gains, the adoption of GenAI also\nintroduces new pressures that may harm developers' well-being. In this paper,\nwe investigate the relationship between the adoption of GenAI and developers'\nburnout. We utilized the Job Demands--Resources (JD--R) model as the analytic\nlens in our empirical study. We employed a concurrent embedded mixed-methods\nresearch design, integrating quantitative and qualitative evidence. We first\nsurveyed 442 developers across diverse organizations, roles, and levels of\nexperience. We then employed Partial Least Squares--Structural Equation\nModeling (PLS-SEM) and regression to model the relationships among job demands,\njob resources, and burnout, complemented by a qualitative analysis of\nopen-ended responses to contextualize the quantitative findings. Our results\nshow that GenAI adoption heightens burnout by increasing job demands, while job\nresources and positive perceptions of GenAI mitigate these effects, reframing\nadoption as an opportunity."}
{"id": "2510.07529", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.07529", "abs": "https://arxiv.org/abs/2510.07529", "authors": ["Carol Hanna", "Federica Sarro", "Mark Harman", "Justyna Petke"], "title": "HotBugs.jar: A Benchmark of Hot Fixes for Time-Critical Bugs", "comment": null, "summary": "Hot fixes are urgent, unplanned changes deployed to production systems to\naddress time-critical issues. Despite their importance, no existing evaluation\nbenchmark focuses specifically on hot fixes. We present HotBugs$.$jar, the\nfirst dataset dedicated to real-world hot fixes. From an initial mining of 10\nactive Apache projects totaling over 190K commits and 150K issue reports, we\nidentified 746 software patches that met our hot-fix criteria. After manual\nevaluation, 679 were confirmed as genuine hot fixes, of which 110 are\nreproducible using a test suite. Building upon the Bugs$.$jar framework,\nHotBugs$.$jar integrates these 110 reproducible cases and makes available all\n679 manually validated hot fixes, each enriched with comprehensive metadata to\nsupport future research. Each hot fix was systematically identified using Jira\nissue data, validated by independent reviewers, and packaged in a reproducible\nformat with buggy and fixed versions, test suites, and metadata. HotBugs$.$jar\nhas already been adopted as the official challenge dataset for the Search-Based\nSoftware Engineering (SBSE) Conference Challenge Track, demonstrating its\nimmediate impact. This benchmark enables the study and evaluation of tools for\nrapid debugging, automated repair, and production-grade resilience in modern\nsoftware systems to drive research in this essential area forward."}
{"id": "2510.07604", "categories": ["cs.SE", "D.2.4"], "pdf": "https://arxiv.org/pdf/2510.07604", "abs": "https://arxiv.org/abs/2510.07604", "authors": ["Yubo Bai", "Tapti Palit"], "title": "RustAssure: Differential Symbolic Testing for LLM-Transpiled C-to-Rust Code", "comment": "13 pages to appear in Proceedings of ASE 2025", "summary": "Rust is a memory-safe programming language that significantly improves\nsoftware security. Existing codebases written in unsafe memory languages, such\nas C, must first be transpiled to Rust to take advantage of Rust's improved\nsafety guarantees. RustAssure presents a system that uses Large Language Models\n(LLMs) to automatically transpile existing C codebases to Rust. RustAssure uses\nprompt engineering techniques to maximize the chances of the LLM generating\nidiomatic and safe Rust code. Moreover, because LLMs often generate code with\nsubtle bugs that can be missed under traditional unit or fuzz testing,\nRustAssure performs differential symbolic testing to establish the semantic\nsimilarity between the original C and LLM-transpiled Rust code. We evaluated\nRustAssure with five real-world applications and libraries, and showed that our\nsystem is able to generate compilable Rust functions for 89.8% of all C\nfunctions, of which 69.9% produced equivalent symbolic return values for both\nthe C and Rust functions."}
{"id": "2510.07740", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.07740", "abs": "https://arxiv.org/abs/2510.07740", "authors": ["Dezhi Ran", "Yuan Cao", "Mengzhou Wu", "Simin Chen", "Yuzhe Guo", "Jun Ren", "Zihe Song", "Hao Yu", "Jialei Wei", "Linyi Li", "Wei Yang", "Baishakhi Ray", "Tao Xie"], "title": "AppForge: From Assistant to Independent Developer -- Are GPTs Ready for Software Development?", "comment": "Under Review. Benchmark and leadboards at\n  https://appforge-bench.github.io/", "summary": "Large language models (LLMs) have demonstrated remarkable capability in\nfunction-level code generation tasks. Unlike isolated functions, real-world\napplications demand reasoning over the entire software system: developers must\norchestrate how different components interact, maintain consistency across\nstates over time, and ensure the application behaves correctly within the\nlifecycle and framework constraints. Yet, no existing benchmark adequately\nevaluates whether LLMs can bridge this gap and construct entire software\nsystems from scratch. To address this gap, we propose APPFORGE, a benchmark\nconsisting of 101 software development problems drawn from real-world Android\napps. Given a natural language specification detailing the app functionality, a\nlanguage model is tasked with implementing the functionality into an Android\napp from scratch. Developing an Android app from scratch requires understanding\nand coordinating app states, lifecycle management, and asynchronous operations,\ncalling for LLMs to generate context-aware, robust, and maintainable code. To\nconstruct APPFORGE, we design a multi-agent system to automatically summarize\nthe main functionalities from app documents and navigate the app to synthesize\ntest cases validating the functional correctness of app implementation.\nFollowing rigorous manual verification by Android development experts, APPFORGE\nincorporates the test cases within an automated evaluation framework that\nenables reproducible assessment without human intervention, making it easily\nadoptable for future research. Our evaluation on 12 flagship LLMs show that all\nevaluated models achieve low effectiveness, with the best-performing model\n(GPT-5) developing only 18.8% functionally correct applications, highlighting\nfundamental limitations in current models' ability to handle complex,\nmulti-component software engineering challenges."}
{"id": "2510.07696", "categories": ["cs.FL", "math.LO", "68Q45 (Primary) 03D05, 68Q30, 68Q06 (Secondary)", "F.4.2; F.4.3"], "pdf": "https://arxiv.org/pdf/2510.07696", "abs": "https://arxiv.org/abs/2510.07696", "authors": ["Joey Chen", "Bjørn Kjos-Hanssen", "Ivan Koswara", "Linus Richter", "Frank Stephan"], "title": "Languages of Words of Low Automatic Complexity Are Hard to Compute", "comment": "22 pages, 1 figure", "summary": "The automatic complexity of a finite word (string) is an analogue for finite\nautomata of Sipser's distinguishing complexity (1983) and was introduced by\nShallit and Wang (2001). For a finite alphabet $\\Sigma$ of at least two\nelements, we consider the non-deterministic automatic complexity given by\nexactly - yet not necessarily uniquely - accepting automata: a word $x \\in\n\\Sigma^*$ has exact non-deterministic automatic complexity $k \\in \\mathbb{N}$\nif there exists a non-deterministic automaton of $k$ states which accepts $x$\nwhile rejecting every other word of the same length as $x$, and no automaton of\nfewer states has this property. Importantly, and in contrast to the classical\nnotion, the witnessing automaton may have multiple paths of computation\naccepting $x$. We denote this measure of complexity by $A_{Ne}$, and study a\nclass of languages of low $A_{Ne}$-complexity defined as $L_q = \\{ \\, x \\in\n\\Sigma^* : A_{Ne}(x) < q|x| \\, \\}$, which is parameterised by rationals $q \\in\n(0,1/2)$ (generalising a class of sets first studied by Kjos-Hanssen). We show\nthat for every $q \\in (0,1/2)$, this class is neither context-free nor\nrecognisable by certain Boolean circuits. In the process, we answer an open\nquestion of Kjos-Hanssen quantifying the complexity of $L_{1/3}$ in terms of\nBoolean circuits, and also prove the Shannon effect for $A_{Ne}$."}
{"id": "2510.07361", "categories": ["cs.LO"], "pdf": "https://arxiv.org/pdf/2510.07361", "abs": "https://arxiv.org/abs/2510.07361", "authors": ["Gilles Geeraerts", "Frédéric Herbreteau", "Jean-François Raskin", "Alexis Reynouard"], "title": "A Zone-Based Algorithm for Timed Parity Games", "comment": "16 pages, 5 figures, to be published in FSTTCS 2025", "summary": "This paper revisits timed games by building upon the semantics introduced in\n\"The Element of Surprise in Timed Games\". We introduce some modifications to\nthis semantics for two primary reasons: firstly, we recognize instances where\nthe original semantics appears counterintuitive in the context of controller\nsynthesis; secondly, we present methods to develop efficient zone-based\nalgorithms. Our algorithm successfully addresses timed parity games, and we\nhave implemented it using UppAal's zone library. This prototype effectively\ndemonstrates the feasibility of a zone-based algorithm for parity objectives\nand a rich semantics for timed interactions between the players."}
{"id": "2510.07582", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2510.07582", "abs": "https://arxiv.org/abs/2510.07582", "authors": ["Yuyan Bao", "Tiark Rompf"], "title": "Type, Ability, and Effect Systems: Perspectives on Purity, Semantics, and Expressiveness", "comment": null, "summary": "Programming benefits from a clear separation between pure, mathematical\ncomputation and impure, effectful interaction with the world. Existing\napproaches to enforce this separation include monads, type-and-effect systems,\nand capability systems. All share a tension between precision and usability,\nand each one has non-obvious strengths and weaknesses.\n  This paper aims to raise the bar in assessing such systems. First, we propose\na semantic definition of purity, inspired by contextual equivalence, as a\nbaseline independent of any specific typing discipline. Second, we propose that\nexpressiveness should be measured by the degree of completeness, i.e., how many\nsemantically pure terms can be typed as pure. Using this measure, we focus on\nminimal meaningful effect and capability systems and show that they are\nincomparable, i.e., neither subsumes the other in terms of expressiveness.\n  Based on this result, we propose a synthesis and show that type, ability, and\neffect systems combine their respective strengths while avoiding their\nweaknesses. As part of our formal model, we provide a logical relation to\nfacilitate proofs of purity and other properties for a variety of effect typing\ndisciplines."}
{"id": "2510.07815", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.07815", "abs": "https://arxiv.org/abs/2510.07815", "authors": ["Zeyu Sun", "Jingjing Liang", "Weiyi Wang", "Chenyao Suo", "Junjie Chen", "Fanjiang Xu"], "title": "Interleaved Learning and Exploration: A Self-Adaptive Fuzz Testing Framework for MLIR", "comment": null, "summary": "MLIR (Multi-Level Intermediate Representation) has rapidly become a\nfoundational technology for modern compiler frameworks, enabling extensibility\nacross diverse domains. However, ensuring the correctness and robustness of\nMLIR itself remains challenging. Existing fuzzing approaches-based on manually\ncrafted templates or rule-based mutations-struggle to generate sufficiently\ndiverse and semantically valid test cases, making it difficult to expose subtle\nor deep-seated bugs within MLIR's complex and evolving code space. In this\npaper, we present FLEX, a novel self-adaptive fuzzing framework for MLIR. FLEX\nleverages neural networks for program generation, a perturbed sampling strategy\nto encourage diversity, and a feedback-driven augmentation loop that\niteratively improves its model using both crashing and non-crashing test cases.\nStarting from a limited seed corpus, FLEX progressively learns valid syntax and\nsemantics and autonomously produces high-quality test inputs. We evaluate FLEX\non the upstream MLIR compiler against four state-of-the-art fuzzers. In a\n30-day campaign, FLEX discovers 80 previously unknown bugs-including multiple\nnew root causes and parser bugs-while in 24-hour fixed-revision comparisons, it\ndetects 53 bugs (over 3.5x as many as the best baseline) and achieves 28.2%\ncode coverage, outperforming the next-best tool by 42%. Ablation studies\nfurther confirm the critical role of both perturbed generation and diversity\naugmentation in FLEX's effectiveness."}
{"id": "2510.08127", "categories": ["cs.FL"], "pdf": "https://arxiv.org/pdf/2510.08127", "abs": "https://arxiv.org/abs/2510.08127", "authors": ["Antoine Amarilli", "Mikaël Monet", "Paul Raphaël", "Sylvain Salvati"], "title": "On the Complexity of Language Membership for Probabilistic Words", "comment": "35 pages including 1 title page, 15 pages of main text, 4 pages of\n  reference, and appendix", "summary": "We study the membership problem to context-free languages L (CFLs) on\nprobabilistic words, that specify for each position a probability distribution\non the letters (assuming independence across positions). Our task is to\ncompute, given a probabilistic word, what is the probability that a word drawn\naccording to the distribution belongs to L. This problem generalizes the\nproblem of counting how many words of length n belong to L, or of counting how\nmany completions of a partial word belong to L.\n  We show that this problem is in polynomial time for unambiguous context-free\nlanguages (uCFLs), but can be #P-hard already for unions of two linear uCFLs.\nMore generally, we show that the problem is in polynomial time for so-called\npoly-slicewise-unambiguous languages, where given a length n we can tractably\ncompute an uCFL for the words of length n in the language. This class includes\nsome inherently ambiguous languages, and implies the tractability of bounded\nCFLs and of languages recognized by unambiguous polynomial-time counter\nautomata; but we show that the problem can be #P-hard for nondeterministic\ncounter automata, even for Parikh automata with a single counter. We then\nintroduce classes of circuits from knowledge compilation which we use for\ntractable counting, and show that this covers the tractability of\npoly-slicewise-unambiguous languages and of some CFLs that are not\npoly-slicewise-unambiguous. Extending these circuits with negation further\nallows us to show tractability for the language of primitive words, and for the\nlanguage of concatenations of two palindromes. We finally show the conditional\nundecidability of the meta-problem that asks, given a CFG, whether the\nprobabilistic membership problem for that CFG is tractable or #P-hard."}
{"id": "2510.07422", "categories": ["cs.LO", "cs.DB", "cs.FL"], "pdf": "https://arxiv.org/pdf/2510.07422", "abs": "https://arxiv.org/abs/2510.07422", "authors": ["Rémi Morvan"], "title": "Homomorphism Problems in Graph Databases and Automatic Structures", "comment": "Ph.D. thesis, in French language, defended on 3 July 2025 at\n  Universit\\'e de Bordeaux", "summary": "This thesis investigates the central role of homomorphism problems\n(structure-preserving maps) in two complementary domains: database querying\nover finite, graph-shaped data, and constraint solving over (potentially\ninfinite) structures. Building on the well-known equivalence between\nconjunctive query evaluation and homomorphism existence, the first part focuses\non conjunctive regular path queries, a standard extension of conjunctive\nqueries that incorporates regular-path predicates. We study the fundamental\nproblem of query minimization under two measures: the number of atoms\n(constraints) and the tree-width of the query graph. In both cases, we prove\nthe problem to be decidable, and provide efficient algorithms for a large\nfragment of queries used in practice. The second part of the thesis lifts\nhomomorphism problems to automatic structures, which are infinite structures\ndescribable by finite automata. We highlight a dichotomy, between homomorphism\nproblems over automatic structures that are decidable in non-deterministic\nlogarithmic space, and those that are undecidable (proving to be the more\ncommon case). In contrast to this prevalence of undecidability, we then focus\non the language-theoretic properties of these structures, and show, relying on\na novel algebraic language theory, that for any well-behaved logic (a\npseudovariety), whether an automatic structure can be described in this logic\nis decidable."}
{"id": "2510.07851", "categories": ["cs.PL", "cs.LO"], "pdf": "https://arxiv.org/pdf/2510.07851", "abs": "https://arxiv.org/abs/2510.07851", "authors": ["Willem Heijltjes"], "title": "The Functional Machine Calculus III: Control", "comment": null, "summary": "The Functional Machine Calculus (Heijltjes 2022) is a new approach to\nunifying the imperative and functional programming paradigms. It extends the\nlambda-calculus, preserving the key features of confluent reduction and typed\ntermination, to embed computational effects, evaluation strategies, and control\nflow operations. The first instalment modelled sequential higher-order\ncomputation with global store, input/output, probabilities, and\nnon-determinism, and embedded both the call-by-name and call-by-value\nlambda-calculus, as well as Moggi's computational metalanguage and Levy's\ncall-by-push-value. The present paper extends the calculus from sequential to\nbranching and looping control flow. This allows the faithful embedding of a\nminimal but complete imperative language, including conditionals, exception\nhandling, and iteration, as well as constants and algebraic data types.\n  The calculus is defined through a simple operational semantics, extending the\n(simplified) Krivine machine for the lambda-calculus with multiple operand\nstacks to model effects and a continuation stack to model sequential,\nbranching, and looping computation. It features a confluent reduction relation\nand a system of simple types that guarantees termination of the machine and\nstrong normalization of reduction (in the absence of iteration). These\nproperties carry over to the embedded imperative language, providing a unified\nfunctional-imperative model of computation that supports simple types, a direct\nand intuitive operational semantics, and a confluent reduction semantics."}
{"id": "2510.07834", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.07834", "abs": "https://arxiv.org/abs/2510.07834", "authors": ["Lingjun Liu", "Feiran Qin", "Owolabi Legunsen", "Marcelo d'Amorim"], "title": "Bug Histories as Sources of Compiler Fuzzing Mutators", "comment": null, "summary": "Bugs in compilers, which are critical infrastructure today, can have outsized\nnegative impacts. Mutational fuzzers aid compiler bug detection by\nsystematically mutating compiler inputs, i.e., programs. Their effectiveness\ndepends on the quality of the mutators used. Yet, no prior work used compiler\nbug histories as a source of mutators. We propose IssueMut, the first approach\nfor extracting compiler fuzzing mutators from bug histories. Our insight is\nthat bug reports contain hints about program elements that induced compiler\nbugs; they can guide fuzzers towards similar bugs. IssueMut uses an automated\nmethod to mine mutators from bug reports and retrofit such mutators into\nexisting mutational compiler fuzzers. Using IssueMut, we mine 587 mutators from\n1760 GCC and LLVM bug reports. Then, we run IssueMut on these compilers, with\nall their test inputs as seed corpora. We find that \"bug history\" mutators are\neffective: they find new bugs that a state-of-the-art mutational compiler\nfuzzer misses-28 in GCC and 37 in LLVM. Of these, 60 were confirmed or fixed,\nvalidating our idea that bug histories have rich information that compiler\nfuzzers should leverage."}
{"id": "2510.08045", "categories": ["cs.LO", "cs.AI", "cs.CC", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.08045", "abs": "https://arxiv.org/abs/2510.08045", "authors": ["Artem Chernobrovkin", "Marco Sälzer", "François Schwarzentruber", "Nicolas Troquard"], "title": "Verifying Graph Neural Networks with Readout is Intractable", "comment": null, "summary": "We introduce a logical language for reasoning about quantized\naggregate-combine graph neural networks with global readout (ACR-GNNs). We\nprovide a logical characterization and use it to prove that verification tasks\nfor quantized GNNs with readout are (co)NEXPTIME-complete. This result implies\nthat the verification of quantized GNNs is computationally intractable,\nprompting substantial research efforts toward ensuring the safety of GNN-based\nsystems. We also experimentally demonstrate that quantized ACR-GNN models are\nlightweight while maintaining good accuracy and generalization capabilities\nwith respect to non-quantized models."}
{"id": "2510.07941", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.07941", "abs": "https://arxiv.org/abs/2510.07941", "authors": ["Srijita Basu", "Haraldsson Bengt", "Miroslaw Staron", "Christian Berger", "Jennifer Horkoff", "Magnus Almgren"], "title": "An AUTOSAR-Aligned Architectural Study of Vulnerabilities in Automotive SoC Software", "comment": "16 pages, 7 figures, 18th International Conference on the Quality of\n  Information and Communications Technology", "summary": "Cooperative, Connected and Automated Mobility (CCAM) are complex\ncyber-physical systems (CPS) that integrate computation, communication, and\ncontrol in safety-critical environments. At their core, System-on-Chip (SoC)\nplatforms consolidate processing units, communication interfaces, AI\naccelerators, and security modules into a single chip. AUTOSAR (AUTomotive Open\nSystem ARchitecture) standard was developed in the automotive domain to better\nmanage this complexity, defining layered software structures and interfaces to\nfacilitate reuse of HW/SW components. However, in practice, this integrated SoC\nsoftware architecture still poses security challenges, particularly in\nreal-time, safety-critical environments. Recent reports highlight a surge in\nSoC-related vulnerabilities, yet systematic analysis of their root causes and\nimpact within AUTOSAR-aligned architectures is lacking. This study fills that\ngap by analyzing 180 publicly reported automotive SoC vulnerabilities, mapped\nto a representative SoC software architecture model that is aligned with\nAUTOSAR principles for layered abstraction and service orientation. We identify\n16 root causes and 56 affected software modules, and examine mitigation delays\nacross Common Weakness Enumeration (CWE) categories and architectural layers.\nWe uncover dominant vulnerability patterns and critical modules with prolonged\npatch delays, and provide actionable insights for securing automotive CPS\nplatforms, including guides for improved detection, prioritization, and\nlocalization strategies for SoC software architectures in SoC-based vehicle\nplatforms."}
{"id": "2510.08112", "categories": ["cs.LO"], "pdf": "https://arxiv.org/pdf/2510.08112", "abs": "https://arxiv.org/abs/2510.08112", "authors": ["Minna Hirvonen"], "title": "Implication Problems over Positive Semirings", "comment": null, "summary": "We study various notions of dependency in semiring team semantics. Semiring\nteams are essentially database relations, where each tuple is annotated with\nsome element from a positive semiring. We consider semiring generalizations of\nseveral dependency notions from database theory and probability theory,\nincluding functional and inclusion dependencies, marginal identity, and\n(probabilistic) independence. We examine axiomatizations of implication\nproblems, which are rule-based characterizations for the logical implication\nand inference of new dependencies from a given set of dependencies. Semiring\nteam semantics provides a general framework, where different implication\nproblems can be studied simultaneously for various semirings. The choice of the\nsemiring leads to a specific semantic interpretation of the dependencies, and\nhence different semirings offer a way to study different semantics (e.g.,\nrelational, bag, and probabilistic semantics) in a unified framework."}
{"id": "2510.08005", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.08005", "abs": "https://arxiv.org/abs/2510.08005", "authors": ["Utku Boran Torun", "Mehmet Taha Demircan", "Mahmut Furkan Gön", "Eray Tüzün"], "title": "Past, Present, and Future of Bug Tracking in the Generative AI Era", "comment": "Submitted to ACM TOSEM Special Issue: 2030 Software Engineering\n  Roadmap", "summary": "Traditional bug tracking systems rely heavily on manual reporting,\nreproduction, triaging, and resolution, each carried out by different\nstakeholders such as end users, customer support, developers, and testers. This\ndivision of responsibilities requires significant coordination and widens the\ncommunication gap between non-technical users and technical teams, slowing the\nprocess from bug discovery to resolution. Moreover, current systems are highly\nasynchronous; users often wait hours or days for a first response, delaying\nfixes and contributing to frustration. This paper examines the evolution of bug\ntracking, from early paper-based reporting to today's web-based and SaaS\nplatforms. Building on this trajectory, we propose an AI-powered bug tracking\nframework that augments existing tools with intelligent, large language model\n(LLM)-driven automation. Our framework addresses two main challenges: reducing\ntime-to-fix and minimizing human overhead. Users report issues in natural\nlanguage, while AI agents refine reports, attempt reproduction, and request\nmissing details. Reports are then classified, invalid ones resolved through\nno-code fixes, and valid ones localized and assigned to developers. LLMs also\ngenerate candidate patches, with human oversight ensuring correctness. By\nintegrating automation into each phase, our framework accelerates response\ntimes, improves collaboration, and strengthens software maintenance practices\nfor a more efficient, user-centric future."}
{"id": "2510.08122", "categories": ["cs.LO", "math.LO", "03D15, 03B60", "F.2.2; F.4.1"], "pdf": "https://arxiv.org/pdf/2510.08122", "abs": "https://arxiv.org/abs/2510.08122", "authors": ["Aleksi Anttila", "Juha Kontinen", "Fan Yang"], "title": "Complexity Results in Team Semantics: Nonemptiness Is Not So Complex", "comment": "12 pages", "summary": "We initiate the study of the complexity-theoretic properties of convex logics\nin team semantics. We focus on the extension of classical propositional logic\nwith the nonemptiness atom NE, a logic known to be both convex and union\nclosed. We show that the satisfiability problem for this logic is NP-complete,\nthat its validity problem is coNP-complete, and that its model-checking problem\nis in P."}
{"id": "2510.08200", "categories": ["cs.SE", "68N15", "D.2.13"], "pdf": "https://arxiv.org/pdf/2510.08200", "abs": "https://arxiv.org/abs/2510.08200", "authors": ["Alexander Hellwig", "Nico Jansen", "Bernhard Rumpe"], "title": "Building Whitespace-Sensitive Languages Using Whitespace-Insensitive Components", "comment": "11 pages, 4 figures, 6 listings", "summary": "In Software Language Engineering, there is a trend towards reusability by\ncomposing modular language components. However, this reusability is severely\ninhibited by a gap in integrating whitespace-sensitive and\nwhitespace-insensitive languages. There is currently no consistent procedure\nfor seamlessly reusing such language components in both cases, such that\nlibraries often cannot be reused, and whitespacesensitive languages are\ndeveloped from scratch. This paper presents a technique for using modular,\nwhitespaceinsensitive language modules to construct whitespace sensitive\nlanguages by pre-processing language artifacts before parsing. The approach is\nevaluated by reconstructing a simplified version of the programming language\nPython. Our solution aims to increase the reusability of existing language\ncomponents to reduce development time and increase the overall quality of\nsoftware languages."}
{"id": "2510.08420", "categories": ["cs.LO"], "pdf": "https://arxiv.org/pdf/2510.08420", "abs": "https://arxiv.org/abs/2510.08420", "authors": ["Rémy Cerda", "Alexis Saurin"], "title": "Compression for Coinductive Infinitary Rewriting: A Generic Approach, with Applications to Cut-Elimination for Non-Wellfounded Proofs", "comment": null, "summary": "Infinitary rewriting, i.e. rewriting featuring possibly infinite terms and\nsequences of reduction, is a convenient framework for describing the dynamics\nof non-terminating but productive rewriting systems. In its original definition\nbased on metric convergence of ordinal-indexed sequences of rewriting steps, a\nhighly desirable property of an infinitary rewriting system is Compression,\ni.e. the fact that rewriting sequences of arbitrary ordinal length can always\nbe 'compressed' to equivalent sequences of length at most {\\omega}.\n  Since then, the standard examples of infinitary rewriting systems have been\ngiven another equivalent presentation based on coinduction. In this work, we\nextend this presentation to the rewriting of arbitrary non-wellfounded\nderivations and we investigate compression in this setting. We design a generic\nproof of compression, relying on a characterisation factorising most of the\nproof and identifying the key property a compressible infinitary rewriting\nsystem should enjoy.\n  As running examples, we discuss first-order rewriting and infinitary\n{\\lambda}-calculi. For the latter, compression can in particular be seen as a\njustification of its coinductive presentation in the literature. As a more\nadvanced example, we also address compression of cut-elimination sequences in\nthe non-wellfounded proof system {\\mu}MALL{\\infty} for multiplicative-additive\nlinear logics with fixed points, which is a key lemma of several\ncut-elimination results for similar proof systems."}
{"id": "2510.08468", "categories": ["cs.LO"], "pdf": "https://arxiv.org/pdf/2510.08468", "abs": "https://arxiv.org/abs/2510.08468", "authors": ["Yang Xu", "Xingxing He", "Shuwei Chen", "Jun Liu", "Xiaomei Zhong"], "title": "Dynamic Automated Deduction by Contradiction Separation: The Standard Extension Algorithm", "comment": "36 pages, 2 figures", "summary": "Automated deduction seeks to enable machines to reason with mathematical\nprecision and logical completeness. Classical resolution-based systems, such as\nProver9, E, and Vampire, rely on binary inference, which inherently limits\nmulti-clause synergy during proof search. The Contradiction Separation\nExtension (CSE) framework, introduced by Xu et al. (2018), overcame this\ntheoretical limitation by extending deduction beyond binary inference. However,\nthe original work did not specify how contradictions are algorithmically\nconstructed and extended in practice. This paper presents the Standard\nExtension algorithm, the first explicit procedural realization of contradiction\nseparation reasoning. The proposed method dynamically constructs contradictions\nthrough complementary literal extension, thereby operationalizing the CSE\ntheory within a unified algorithm for satisfiability and unsatisfiability\nchecking. The algorithm's soundness and completeness are formally proven, and\nits effectiveness is supported indirectly through the performance of CSE-based\nsystems, including CSE, CSE-E, CSI-E, and CSI-Enig in major automated reasoning\ncompetitions (CASC) in the last few years. These results confirm that the\nStandard Extension mechanism constitutes a robust and practically validated\nfoundation for dynamic, multi-clause automated deduction."}
{"id": "2510.07851", "categories": ["cs.PL", "cs.LO"], "pdf": "https://arxiv.org/pdf/2510.07851", "abs": "https://arxiv.org/abs/2510.07851", "authors": ["Willem Heijltjes"], "title": "The Functional Machine Calculus III: Control", "comment": null, "summary": "The Functional Machine Calculus (Heijltjes 2022) is a new approach to\nunifying the imperative and functional programming paradigms. It extends the\nlambda-calculus, preserving the key features of confluent reduction and typed\ntermination, to embed computational effects, evaluation strategies, and control\nflow operations. The first instalment modelled sequential higher-order\ncomputation with global store, input/output, probabilities, and\nnon-determinism, and embedded both the call-by-name and call-by-value\nlambda-calculus, as well as Moggi's computational metalanguage and Levy's\ncall-by-push-value. The present paper extends the calculus from sequential to\nbranching and looping control flow. This allows the faithful embedding of a\nminimal but complete imperative language, including conditionals, exception\nhandling, and iteration, as well as constants and algebraic data types.\n  The calculus is defined through a simple operational semantics, extending the\n(simplified) Krivine machine for the lambda-calculus with multiple operand\nstacks to model effects and a continuation stack to model sequential,\nbranching, and looping computation. It features a confluent reduction relation\nand a system of simple types that guarantees termination of the machine and\nstrong normalization of reduction (in the absence of iteration). These\nproperties carry over to the embedded imperative language, providing a unified\nfunctional-imperative model of computation that supports simple types, a direct\nand intuitive operational semantics, and a confluent reduction semantics."}

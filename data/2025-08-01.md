<div id=toc></div>

# Table of Contents

- [cs.SE](#cs.SE) [Total: 12]
- [cs.PL](#cs.PL) [Total: 2]
- [cs.LO](#cs.LO) [Total: 1]


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [1] [On LLM-Assisted Generation of Smart Contracts from Business Processes](https://arxiv.org/abs/2507.23087)
*Fabian Stiehle,Hans Weytjens,Ingo Weber*

Main category: cs.SE

TL;DR: 研究探讨了大型语言模型（LLMs）从业务流程描述生成智能合约代码的能力，并提出了一个自动化评估框架，发现LLMs在可靠性上存在不足。


<details>
  <summary>Details</summary>
Motivation: 探索LLMs在智能合约代码生成中的应用，以克服传统基于规则的代码生成方法的局限性。

Method: 通过自动化评估框架，测试不同类型和大小的LLMs在生成代码时是否满足流程执行的关键属性（如流程流、资源分配等）。

Result: LLMs在智能合约开发中的表现未能达到所需的完美可靠性。

Conclusion: 建议未来研究探索如何将LLMs负责任地集成到现有代码生成工具中，以提高输出可靠性，并提供了基准框架作为基础。

Abstract: Large language models (LLMs) have changed the reality of how software is
produced. Within the wider software engineering community, among many other
purposes, they are explored for code generation use cases from different types
of input. In this work, we present an exploratory study to investigate the use
of LLMs for generating smart contract code from business process descriptions,
an idea that has emerged in recent literature to overcome the limitations of
traditional rule-based code generation approaches. However, current LLM-based
work evaluates generated code on small samples, relying on manual inspection,
or testing whether code compiles but ignoring correct execution. With this
work, we introduce an automated evaluation framework and provide empirical data
from larger data sets of process models. We test LLMs of different types and
sizes in their capabilities of achieving important properties of process
execution, including enforcing process flow, resource allocation, and
data-based conditions. Our results show that LLM performance falls short of the
perfect reliability required for smart contract development. We suggest future
work to explore responsible LLM integrations in existing tools for code
generation to ensure more reliable output. Our benchmarking framework can serve
as a foundation for developing and evaluating such integrations.

</details>


### [2] [FlowETL: An Autonomous Example-Driven Pipeline for Data Engineering](https://arxiv.org/abs/2507.23118)
*Mattia Di Profio,Mingjun Zhong,Yaji Sripada,Marcel Jaspars*

Main category: cs.SE

TL;DR: FlowETL是一种基于示例的自主ETL管道架构，旨在自动标准化和准备输入数据集，减少人工干预。


<details>
  <summary>Details</summary>
Motivation: 现代ETL解决方案需要大量人工设计特定上下文且不可通用的转换，缺乏自动化能力。

Method: FlowETL通过规划引擎和ETL工作器自动构建并应用转换计划，同时提供监控和日志功能。

Result: 在14个不同领域、文件结构和大小的数据集上表现出良好的泛化能力。

Conclusion: FlowETL展示了自动化ETL流程的潜力，减少了人工干预的需求。

Abstract: The Extract, Transform, Load (ETL) workflow is fundamental for populating and
maintaining data warehouses and other data stores accessed by analysts for
downstream tasks. A major shortcoming of modern ETL solutions is the extensive
need for a human-in-the-loop, required to design and implement
context-specific, and often non-generalisable transformations. While related
work in the field of ETL automation shows promising progress, there is a lack
of solutions capable of automatically designing and applying these
transformations. We present FlowETL, a novel example-based autonomous ETL
pipeline architecture designed to automatically standardise and prepare input
datasets according to a concise, user-defined target dataset. FlowETL is an
ecosystem of components which interact together to achieve the desired outcome.
A Planning Engine uses a paired input-output datasets sample to construct a
transformation plan, which is then applied by an ETL worker to the source
dataset. Monitoring and logging provide observability throughout the entire
pipeline. The results show promising generalisation capabilities across 14
datasets of various domains, file structures, and file sizes.

</details>


### [3] [Vibe Modeling: Challenges and Opportunities](https://arxiv.org/abs/2507.23120)
*Jordi Cabot*

Main category: cs.SE

TL;DR: 论文提出了一种结合AI和模型驱动工程（MDE）的“氛围建模”方法，以加速可靠复杂系统的开发。


<details>
  <summary>Details</summary>
Motivation: 随着软件系统需求的增长和复杂性增加，现有开发方法和工具面临挑战，需要结合AI和MDE的优势。

Method: 提出“氛围建模”概念，整合自然语言处理和模型驱动工程，以提高开发效率和质量。

Result: 氛围建模为复杂系统开发提供了新思路，但也带来了新的机遇和挑战。

Conclusion: 氛围建模有望成为未来建模领域的重要方向，但仍需解决开放性问题。

Abstract: There is a pressing need for better development methods and tools to keep up
with the growing demand and increasing complexity of new software systems. New
types of user interfaces, the need for intelligent components, sustainability
concerns, ... bring new challenges that we need to handle. In the last years,
model-driven engineering (MDE) has been key to improving the quality and
productivity of software development, but models themselves are becoming
increasingly complex to specify and manage. At the same time, we are witnessing
the growing popularity of vibe coding approaches that rely on Large Language
Models (LLMs) to transform natural language descriptions into running code at
the expenses of code vulnerabilities, scalability issues and maintainability
concerns. In this paper, we introduce the concept of \textit{vibe modeling} as
a novel approach to integrate the best of both worlds (AI and MDE) to speed up
the development of reliable complex systems. We outline the key concepts of
vibe modeling and highlight the opportunities and open challenges it presents
for the future of modeling.

</details>


### [4] [Extension Decisions in Open Source Software Ecosystem](https://arxiv.org/abs/2507.23168)
*Elmira Onagh,Maleknaz Nayebi*

Main category: cs.SE

TL;DR: 研究发现GitHub Marketplace中65%的新CI Actions功能重复，且通常在六个月内出现，少数先行者占据主导。


<details>
  <summary>Details</summary>
Motivation: 研究GitHub Marketplace中CI工具的功能重复现象，为开发者和维护者提供数据支持。

Method: 通过链接6,983个CI Actions到3,869个提供者，并挖掘其版本历史，构建时间戳图模型。

Result: 65%的新CI Actions功能重复，少数先行者主导后续分叉和扩展。

Conclusion: 研究结果为开发者提供发布时机和功能定位建议，并帮助维护者清理冗余工具。

Abstract: GitHub Marketplace is expanding by approximately 41% annually, with new
tools; however, many additions replicate existing functionality. We study this
phenomenon in the platform's largest segment, Continuous Integration (CI), by
linking 6,983 CI Actions to 3,869 providers and mining their version histories.
Our graph model timestamps every functionality's debut, tracks its adoption,
and clusters redundant tools. We find that approximately 65% of new CI Actions
replicate existing capabilities, typically within six months, and that a small
set of first-mover Actions accounts for most subsequent forks and extensions.
These insights enable developers to choose the optimal moment to launch, target
unmet functionality, and help maintainers eliminate redundant tools. We publish
the complete graph and dataset to encourage longitudinal research on innovation
and competition in software ecosystems, and to provide practitioners with a
data-driven roadmap for identifying emerging trends and guiding product
strategy.

</details>


### [5] [AutoBridge: Automating Smart Device Integration with Centralized Platform](https://arxiv.org/abs/2507.23178)
*Siyuan Liu,Zhice Yang,Huangxun Chen*

Main category: cs.SE

TL;DR: AutoBridge自动化生成物联网设备集成代码，通过分治策略和多阶段调试管道，显著减少人工干预，成功率和功能覆盖率均超过90%。


<details>
  <summary>Details</summary>
Motivation: 物联网设备集成需要大量人工编程，AutoBridge旨在自动化这一过程，减少专家依赖。

Method: 采用分治策略，先生成设备控制逻辑，再合成平台兼容代码，并通过多阶段调试确保正确性。

Result: 在34个设备上测试，平均成功率达93.87%，功能覆盖率达94.87%，用户反馈后可达100%。

Conclusion: AutoBridge在代码准确性和效率上显著优于人工编程，展示了自动化集成的潜力。

Abstract: Multimodal IoT systems coordinate diverse IoT devices to deliver
human-centered services. The ability to incorporate new IoT devices under the
management of a centralized platform is an essential requirement. However, it
requires significant human expertise and effort to program the complex IoT
integration code that enables the platform to understand and control the device
functions. Therefore, we propose AutoBridge to automate IoT integration code
generation. Specifically, AutoBridge adopts a divide-and-conquer strategy: it
first generates device control logic by progressively retrieving
device-specific knowledge, then synthesizes platformcompliant integration code
using platform-specific knowledge. To ensure correctness, AutoBridge features a
multi-stage debugging pipeline, including an automated debugger for virtual IoT
device testing and an interactive hardware-in-the-loop debugger that requires
only binary user feedback (yes and no) for real-device verification. We
evaluate AutoBridge on a benchmark of 34 IoT devices across two open-source IoT
platforms. The results demonstrate that AutoBridge can achieves an average
success rate of 93.87% and an average function coverage of 94.87%, without any
human involvement. With minimal binary yes and no feedback from users, the code
is then revised to reach 100% function coverage. A user study with 15
participants further shows that AutoBridge outperforms expert programmers by
50% to 80% in code accuracy, even when the programmers are allowed to use
commercial code LLMs.

</details>


### [6] [XABPs: Towards eXplainable Autonomous Business Processes](https://arxiv.org/abs/2507.23269)
*Peter Fettke,Fabiana Fournier,Lior Limonad,Andreas Metzger,Stefanie Rinderle-Ma,Barbara Weber*

Main category: cs.SE

TL;DR: 论文提出可解释的自主业务流程（XABPs），以解决自主业务流程（ABPs）可能带来的信任、调试、责任、偏见和合规性问题。


<details>
  <summary>Details</summary>
Motivation: 自主业务流程（ABPs）虽能提升效率和降低成本，但可能引发信任、调试、责任等问题，需通过可解释性解决。

Method: 提出系统性方法，包括形式化XABPs、结构化可解释性，并识别关键研究挑战。

Result: XABPs能通过解释其决策逻辑，缓解ABPs的潜在问题。

Conclusion: XABPs为解决ABPs的挑战提供了可行路径，未来需进一步研究其实现和应用。

Abstract: Autonomous business processes (ABPs), i.e., self-executing workflows
leveraging AI/ML, have the potential to improve operational efficiency, reduce
errors, lower costs, improve response times, and free human workers for more
strategic and creative work. However, ABPs may raise specific concerns
including decreased stakeholder trust, difficulties in debugging, hindered
accountability, risk of bias, and issues with regulatory compliance. We argue
for eXplainable ABPs (XABPs) to address these concerns by enabling systems to
articulate their rationale. The paper outlines a systematic approach to XABPs,
characterizing their forms, structuring explainability, and identifying key BPM
research challenges towards XABPs.

</details>


### [7] [SWE-Debate: Competitive Multi-Agent Debate for Software Issue Resolution](https://arxiv.org/abs/2507.23348)
*Han Li,Yuling Shi,Shaoxin Lin,Xiaodong Gu,Heng Lian,Xin Wang,Yantao Jia,Tao Huang,Qianxiang Wang*

Main category: cs.SE

TL;DR: SWE-Debate是一种竞争性多代理辩论框架，通过多样化推理路径和协作性讨论，提升软件工程问题的解决能力。


<details>
  <summary>Details</summary>
Motivation: 现有基于代理的问题解决方法常陷入局部解，难以识别跨代码库的问题模式。

Method: SWE-Debate通过生成多个故障传播路径，组织三轮辩论，由不同视角的代理协作达成统一修复计划。

Result: 在SWE-bench基准测试中，SWE-Debate表现优于现有基线，达到最新技术水平。

Conclusion: SWE-Debate通过多代理辩论显著提升了问题定位和修复能力。

Abstract: Issue resolution has made remarkable progress thanks to the advanced
reasoning capabilities of large language models (LLMs). Recently, agent-based
frameworks such as SWE-agent have further advanced this progress by enabling
autonomous, tool-using agents to tackle complex software engineering tasks.
While existing agent-based issue resolution approaches are primarily based on
agents' independent explorations, they often get stuck in local solutions and
fail to identify issue patterns that span across different parts of the
codebase. To address this limitation, we propose SWE-Debate, a competitive
multi-agent debate framework that encourages diverse reasoning paths and
achieves more consolidated issue localization. SWE-Debate first creates
multiple fault propagation traces as localization proposals by traversing a
code dependency graph. Then, it organizes a three-round debate among
specialized agents, each embodying distinct reasoning perspectives along the
fault propagation trace. This structured competition enables agents to
collaboratively converge on a consolidated fix plan. Finally, this consolidated
fix plan is integrated into an MCTS-based code modification agent for patch
generation. Experiments on the SWE-bench benchmark show that SWE-Debate
achieves new state-of-the-art results in open-source agent frameworks and
outperforms baselines by a large margin.

</details>


### [8] [Quality Evaluation of COBOL to Java Code Transformation](https://arxiv.org/abs/2507.23356)
*Shmulik Froimovich,Raviv Gal,Wesam Ibraheem,Avi Ziv*

Main category: cs.SE

TL;DR: IBM开发了一个自动化评估系统，用于评估COBOL到Java代码的翻译质量，结合分析检查器和LLM作为评判技术，支持持续集成和大规模基准测试。


<details>
  <summary>Details</summary>
Motivation: 解决基于LLM的翻译器评估中的模型不透明性和翻译质量评估复杂性等关键挑战。

Method: 结合分析检查器和LLM-as-a-judge（LaaJ）技术，提供可扩展的多方面评估。

Result: 系统支持持续集成工作流，减少对人工审查的依赖，并为开发者和项目经理提供可操作的见解。

Conclusion: 该系统有助于推动高质量、现代化代码库的发展。

Abstract: We present an automated evaluation system for assessing COBOL-to-Java code
translation within IBM's watsonx Code Assistant for Z (WCA4Z). The system
addresses key challenges in evaluating LLM-based translators, including model
opacity and the complexity of translation quality assessment. Our approach
combines analytic checkers with LLM-as-a-judge (LaaJ) techniques to deliver
scalable, multi-faceted evaluations. The system supports continuous integration
workflows, enables large-scale benchmarking, and reduces reliance on manual
review. We describe the system architecture, evaluation strategies, and
reporting mechanisms that provide actionable insights for developers and
project managers, facilitating the evolution of high-quality, modernized
codebases.

</details>


### [9] [SWE-Exp: Experience-Driven Software Issue Resolution](https://arxiv.org/abs/2507.23361)
*Silin Chen,Shaoxin Lin,Xiaodong Gu,Yuling Shi,Heng Lian,Longfei Yun,Dong Chen,Weiguo Sun,Lin Cao,Qianxiang Wang*

Main category: cs.SE

TL;DR: SWE-Exp是一种通过经验增强的LLM代理方法，解决了现有代理在软件问题解决中缺乏记忆和知识复用的问题，提高了问题解决效率。


<details>
  <summary>Details</summary>
Motivation: 当前LLM代理在解决软件问题时缺乏记忆能力，无法复用之前的修复经验，导致冗余探索和效率低下。

Method: 提出SWE-Exp方法，通过多维度经验库捕获成功和失败的修复尝试，提取可复用的知识。

Result: 实验显示SWE-Exp在SWE-bench-Verified上达到41.6%的Pass@1解决率。

Conclusion: SWE-Exp为自动化软件工程代理引入了经验驱动的战略修复模式，显著提升了问题解决效率。

Abstract: Recent advances in large language model (LLM) agents have shown remarkable
progress in software issue resolution, leveraging advanced techniques such as
multi-agent collaboration and Monte Carlo Tree Search (MCTS). However, current
agents act as memoryless explorers - treating each problem separately without
retaining or reusing knowledge from previous repair experiences. This leads to
redundant exploration of failed trajectories and missed chances to adapt
successful issue resolution methods to similar problems. To address this
problem, we introduce SWE-Exp, an experience - enhanced approach that distills
concise and actionable experience from prior agent trajectories, enabling
continuous learning across issues. Our method introduces a multi-faceted
experience bank that captures both successful and failed repair attempts.
Specifically, it extracts reusable issue resolution knowledge at different
levels - from high-level problem comprehension to specific code changes.
Experiments show that SWE-Exp achieves state-of-the-art resolution rate (41.6%
Pass@1) on SWE-bench-Verified under open-source agent frameworks. Our approach
establishes a new paradigm in which automated software engineering agents
systematically accumulate and leverage repair expertise, fundamentally shifting
from trial-and-error exploration to strategic, experience-driven issue
resolution.

</details>


### [10] [Trae Agent: An LLM-based Agent for Software Engineering with Test-time Scaling](https://arxiv.org/abs/2507.23370)
*Trae Research Team,Pengfei Gao,Zhao Tian,Xiangxin Meng,Xinchen Wang,Ruida Hu,Yuanan Xiao,Yizhou Liu,Zhao Zhang,Junjie Chen,Cuiyun Gao,Yun Lin,Yingfei Xiong,Chao Peng,Xia Liu*

Main category: cs.SE

TL;DR: 本文提出了一种基于代理的集成推理方法Trae Agent，用于解决软件问题，显著提升了性能。


<details>
  <summary>Details</summary>
Motivation: 现有基于提示的方法在探索大型集成空间和仓库级理解方面存在局限性，限制了其效果。

Method: Trae Agent通过模块化代理（生成、剪枝和选择）将目标建模为最优解搜索问题。

Result: 在SWE-bench基准测试中，Trae Agent平均Pass@1提升10.22%，并以75.20%的分数位居榜首。

Conclusion: Trae Agent是一种高效的仓库级问题解决方法，已开源以支持研究社区。

Abstract: Software issue resolution is a critical challenge in software engineering and
has garnered increasing attention in recent years. With the rapid advancement
of large language models (LLMs), substantial progress has been made in
addressing real-world software engineering tasks. Recent studies have
introduced ensemble reasoning techniques to enhance the performance of
LLM-based issue resolution. However, existing prompting-based methods still
face limitations in effectively exploring large ensemble spaces and lack the
capacity for repository-level understanding, both of which constrain their
overall effectiveness. In this paper, we propose Trae Agent, the first
agent-based ensemble reasoning approach for repository-level issue resolution.
Trae Agent formulates our goal as an optimal solution search problem and
addresses two key challenges, i.e., large ensemble spaces and repository-level
understanding, through modular agents for generation, pruning, and selection.
We conduct extensive experiments using three leading LLMs on the widely-adopted
SWE-bench benchmark, comparing Trae Agent against four state-of-the-art
ensemble reasoning techniques. Experimental results demonstrate that Trae Agent
consistently achieves superior performance, with an average improvement of
10.22% over all baselines in terms of Pass@1. Trae Agent has achieved first
place on the SWE-bench Verified leaderboard, with a notable Pass@1 score of
75.20%. We are pleased to release Trae Agent as an open-source project to
support the research community, with all resources available at
https://github.com/bytedance/trae-agent.

</details>


### [11] [Dynamic and Static Analysis of Python Software with Kieker Including Reconstructed Architectures](https://arxiv.org/abs/2507.23425)
*Daphné Larrivain,Shinhyung Yang,Wilhelm Hasselbring*

Main category: cs.SE

TL;DR: Kieker框架扩展支持Python，结合静态和动态分析，提供全面的系统观察能力。


<details>
  <summary>Details</summary>
Motivation: Python的流行使得对其应用的结构化洞察变得重要，Kieker原为Java设计，扩展支持Python具有价值。

Method: 结合静态和动态分析，构建完整的系统视图。

Result: 实现了对Python应用的全面观察能力。

Conclusion: Kieker框架成功扩展至Python，为开发者提供了更广泛的工具支持。

Abstract: The Kieker observability framework is a tool that provides users with the
means to design a custom observability pipeline for their application.
Originally tailored for Java, supporting Python with Kieker is worthwhile.
Python's popularity has exploded over the years, thus making structural
insights of Python applications highly valuable. Our Python analysis pipeline
combines static and dynamic analysis in order to build a complete picture of a
given system.

</details>


### [12] [An Empirical Study on the Amount of Changes Required for Merge Request Acceptance](https://arxiv.org/abs/2507.23640)
*Samah Kansab,Mohammed Sayagh,Francis Bordeleau,Ali Tizghadam*

Main category: cs.SE

TL;DR: 论文研究了代码审查（CR）中的工作量，基于GitLab合并请求（MRs）的数据，发现71%的MRs需要调整，28%涉及超过200行代码修改。机器学习模型能有效预测工作量。


<details>
  <summary>Details</summary>
Motivation: 现有研究较少关注基于代码修改量的CR工作量，尤其是在GitLab MRs背景下。本文旨在填补这一空白。

Method: 使用23,600多个MRs数据集，定义CR工作量为提交后的代码修改量，并训练可解释的机器学习模型。

Result: 71%的MRs需要调整，28%涉及超过200行代码修改。模型AUC达0.84-0.88，复杂度、经验和文本特征是关键预测因子。

Conclusion: 机器学习可用于解释和预测CR工作量，项目历史特征对当前工作量有影响。

Abstract: Code review (CR) is essential to software development, helping ensure that
new code is properly integrated. However, the CR process often involves
significant effort, including code adjustments, responses to reviewers, and
continued implementation. While past studies have examined CR delays and
iteration counts, few have investigated the effort based on the volume of code
changes required, especially in the context of GitLab Merge Requests (MRs),
which remains underexplored. In this paper, we define and measure CR effort as
the amount of code modified after submission, using a dataset of over 23,600
MRs from four GitLab projects. We find that up to 71% of MRs require
adjustments after submission, and 28% of these involve changes to more than 200
lines of code. Surprisingly, this effort is not correlated with review time or
the number of participants. To better understand and predict CR effort, we
train an interpretable machine learning model using metrics across multiple
dimensions: text features, code complexity, developer experience, review
history, and branching. Our model achieves strong performance (AUC 0.84-0.88)
and reveals that complexity, experience, and text features are key predictors.
Historical project characteristics also influence current review effort. Our
findings highlight the feasibility of using machine learning to explain and
anticipate the effort needed to integrate code changes during review.

</details>


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [13] [Abstractions of Sequences, Functions and Operators](https://arxiv.org/abs/2507.23151)
*Louis Rustenholz,Pedro Lopez-Garcia,Manuel V. Hermenegildo*

Main category: cs.PL

TL;DR: 论文提出了一种新的约束抽象域（B-bound domains），用于抽象数值函数，并引入域抽象（domain abstraction）技术，支持从符号函数到数值函数的转换。


<details>
  <summary>Details</summary>
Motivation: 研究动机是解决递归定义的函数的闭式边界推断问题，应用于程序分析和混合系统。

Method: 方法包括提出B-bound domains抽象域，利用凸性简化传递函数设计，并引入域抽象技术。

Result: 结果展示了B-bound domains能够推断高度非线性数值不变量，优于传统数值抽象域。

Conclusion: 结论是该方法在程序分析和混合系统中具有广泛的应用潜力。

Abstract: We present theoretical and practical results on the order theory of lattices
of functions, focusing on Galois connections that abstract (sets of) functions
- a topic known as higher-order abstract interpretation.
  We are motivated by the challenge of inferring closed-form bounds on
functions which are defined recursively, i.e. as the fixed point of an operator
or, equivalently, as the solution to a functional equation. This has multiple
applications in program analysis (e.g. cost analysis, loop acceleration,
declarative language analysis) and in hybrid systems governed by differential
equations.
  Our main contribution is a new family of constraint-based abstract domains
for abstracting numerical functions, B-bound domains, which abstract a function
f by a conjunction of bounds from a preselected set of boundary functions. They
allow inferring highly non-linear numerical invariants, which classical
numerical abstract domains struggle with. We uncover a convexity property in
the constraint space that simplifies, and, in some cases, fully automates,
transfer function design.
  We also introduce domain abstraction, a functor that lifts arbitrary mappings
in value space to Galois connections in function space. This supports
abstraction from symbolic to numerical functions (i.e. size abstraction), and
enables dimensionality reduction of equations.
  We base our constructions of transfer functions on a simple operator
language, starting with sequences, and extending to more general functions,
including multivariate, piecewise, and non-discrete domains.

</details>


### [14] [Kernel-FFI: Transparent Foreign Function Interfaces for Interactive Notebooks](https://arxiv.org/abs/2507.23205)
*Hebi Li,Forrest Sheng Bao,Qi Xiao,Jin Tian*

Main category: cs.PL

TL;DR: Kernel-FFI是一个语言无关的框架，用于在交互式笔记本中实现无缝跨语言函数调用和对象操作，解决了现有FFI解决方案在动态工作流中的不足。


<details>
  <summary>Details</summary>
Motivation: 现有FFI解决方案在动态、交互式笔记本环境中（如Jupyter）存在配置复杂、样板代码多、缺乏对递归调用和面向对象编程（OOP）的支持等问题。

Method: Kernel-FFI通过源代码级转换自动重写跨语言调用，无需手动绑定或样板代码，并支持OOP和跨语言资源管理。此外，通过侧信道通信机制解决Jupyter内核的阻塞问题。

Result: Kernel-FFI实现了无缝跨语言调用和对象操作，支持递归和异步调用，解决了现有FFI的局限性。

Conclusion: Kernel-FFI为动态笔记本环境提供了一种高效、透明的跨语言互操作解决方案，未来将开源。

Abstract: Foreign Function Interfaces (FFIs) are essential for enabling
interoperability between programming languages, yet existing FFI solutions are
ill-suited for the dynamic, interactive workflows prevalent in modern notebook
environments such as Jupyter. Current approaches require extensive manual
configuration, introduce significant boilerplate, and often lack support for
recursive calls and object-oriented programming (OOP) constructs-features
critical for productive, multi-language development.
  We present Kernel-FFI, a transparent, language-agnostic framework that
enables seamless cross-language function calls and object manipulation within
interactive notebooks. Kernel-FFI employs source-level transformation to
automatically rewrite cross-language invocations, eliminating the need for
manual bindings or boilerplate. Kernel-FFI provides robust support for OOP by
enabling foreign object referencing and automatic resource management across
language boundaries. Furthermore, to address the blocking nature of Jupyter
kernels and support recursive and asynchronous foreign calls, we introduce a
novel side-channel communication mechanism. Our tool will be open-sourced and
available at https://codepod.io/docs/kernel-ffi

</details>


<div id='cs.LO'></div>

# cs.LO [[Back]](#toc)

### [15] [Explanations for Unrealizability of Infinite-State Safety Shields](https://arxiv.org/abs/2507.23603)
*Andoni Rodriguez,Irfansha Shaik,Davide Corsi,Roy Fox,Cesar Sanchez*

Main category: cs.LO

TL;DR: 本文提出了一种通过时间公式展开的方法，为不可实现的屏蔽提供无条件或有条件的解释，以解决安全强化学习中规范不一致的问题。


<details>
  <summary>Details</summary>
Motivation: 安全强化学习中，屏蔽方法常因规范不一致而不可实现，需要一种解释方法来解决这一缺陷。

Method: 采用时间公式展开技术，生成无条件或有条件的解释，以证明屏蔽的不可实现性。

Result: 展示了该技术的不同变体及其适用性。

Conclusion: 该方法为解决屏蔽不可实现性问题提供了有效的解释工具。

Abstract: Safe Reinforcement Learning focuses on developing optimal policies while
ensuring safety. A popular method to address such task is shielding, in which a
correct-by-construction safety component is synthesized from logical
specifications. Recently, shield synthesis has been extended to infinite-state
domains, such as continuous environments. This makes shielding more applicable
to realistic scenarios. However, often shields might be unrealizable because
the specification is inconsistent (e.g., contradictory). In order to address
this gap, we present a method to obtain simple unconditional and conditional
explanations that witness unrealizability, which goes by temporal formula
unrolling. In this paper, we show different variants of the technique and its
applicability.

</details>

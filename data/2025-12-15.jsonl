{"id": "2512.11762", "categories": ["cs.PL", "math.CT"], "pdf": "https://arxiv.org/pdf/2512.11762", "abs": "https://arxiv.org/abs/2512.11762", "authors": ["Jack Liell-Cock", "Zev Shirazi", "Sam Staton"], "title": "The Relative Monadic Metalanguage", "comment": "41 pages. Published in Proceedings of the ACM on Programming Languages (POPL 2026)", "summary": "Relative monads provide a controlled view of computation. We generalise the monadic metalanguage to a relative setting and give a complete semantics with strong relative monads. Adopting this perspective, we generalise two existing program calculi from the literature. We provide a linear-non-linear language for graded monads, LNL-RMM, along with a semantic proof that it is a conservative extension of the graded monadic metalanguage. Additionally, we provide a complete semantics for the arrow calculus, showing it is a restricted relative monadic metalanguage. This motivates the introduction of ARMM, a computational lambda calculus-style language for arrows that conservatively extends the arrow calculus."}
{"id": "2512.11577", "categories": ["cs.LO", "cs.PL"], "pdf": "https://arxiv.org/pdf/2512.11577", "abs": "https://arxiv.org/abs/2512.11577", "authors": ["Sergei Stepanenko", "Emma Nardino", "Virgil Marionneau", "Dan Frumin", "Amin Timany", "Lars Birkedal"], "title": "Context-Dependent Effects and Concurrency in Guarded Interaction Trees", "comment": null, "summary": "Guarded Interaction Trees are a structure and a fully formalized framework for representing higher-order computations with higher-order effects in Rocq. We present an extension of Guarded Interaction Trees to support formal reasoning about context-dependent effects. That is, effects whose behaviors depend on the evaluation context, e.g., call/cc, shift and reset. Using and reasoning about such effects is challenging since certain compositionality principles no longer hold in the presence of such effects. For example, the so-called ``bind rule'' in modern program logics is no longer valid. The goal of our extension is to support representation and reasoning about context-dependent effects in the most painless way possible. To that end, our extension is conservative: the reasoning principles for context-independent effects remain the same. We use it to give direct-style denotational semantics for higher-order programming languages with call/cc and with delimited continuations. We extend the program logic for Guarded Interaction Trees to account for context-dependent effects, and we use the program logic to prove that the denotational semantics is adequate with respect to the operational semantics. Additionally, we retain the ability to combine multiple effects in a modular way, which we demonstrate by showing type soundness for safe interoperability of a programming language with delimited continuations and a programming language with higher-order store. Furthermore, as another contribution, in addition to context-dependent effects, we show how to extend Guarded Interaction Trees with preemptive concurrency. To support implementation and verification of concurrent data structures and algorithms in the presence of preemptive concurrency one requires atomic state modification operations, e.g., compare-and-exchange."}
{"id": "2512.11007", "categories": ["cs.FL", "cs.GT"], "pdf": "https://arxiv.org/pdf/2512.11007", "abs": "https://arxiv.org/abs/2512.11007", "authors": ["Henning Fernau", "Carolina Haase", "Stefan Hoffmann", "Mikhail Volkov"], "title": "Uniform winning strategies for the synchronization games on subclasses of finite automata", "comment": "18 pages, 5 figures. Expanded and essentially modified version of the authors' paper in the Proceedings of 14th International Workshop on Non-Classical Models of Automata and Applications, NCMA. EPTCS 407, 77-85 (2024)", "summary": "The pseudovariety $\\mathbf{DS}$ consists of all finite monoids whose regular $D$-classes form subsemigroups. We exhibit a uniform winning strategy for Synchronizer in the synchronization game on every synchronizing automaton whose transition monoid lies in $\\mathbf{DS}$, and we prove that $\\mathbf{DS}$ is the largest pseudovariety with this property."}
{"id": "2512.11223", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2512.11223", "abs": "https://arxiv.org/abs/2512.11223", "authors": ["Sasara Shimizu", "Yoshiki Higo"], "title": "Coverage Isn't Enough: SBFL-Driven Insights into Manually Created vs. Automatically Generated Tests", "comment": null, "summary": "The testing phase is an essential part of software development, but manually creating test cases can be time-consuming. Consequently, there is a growing need for more efficient testing methods. To reduce the burden on developers, various automated test generation tools have been developed, and several studies have been conducted to evaluate the effectiveness of the tests they produce. However, most of these studies focus primarily on coverage metrics, and only a few examine how well the tests support fault localization-particularly using artificial faults introduced through mutation testing. In this study, we compare the SBFL (Spectrum-Based Fault Localization) score and code coverage of automatically generated tests with those of manually created tests. The SBFL score indicates how accurately faults can be localized using SBFL techniques. By employing SBFL score as an evaluation metric-an approach rarely used in prior studies on test generation-we aim to provide new insights into the respective strengths and weaknesses of manually created and automatically generated tests. Our experimental results show that automatically generated tests achieve higher branch coverage than manually created tests, but their SBFL score is lower, especially for code with deeply nested structures. These findings offer guidance on how to effectively combine automatically generated and manually created testing approaches."}
{"id": "2512.11361", "categories": ["cs.LO"], "pdf": "https://arxiv.org/pdf/2512.11361", "abs": "https://arxiv.org/abs/2512.11361", "authors": ["Rasmus Ejlers Møgelberg"], "title": "Multi-clocked Guarded Recursion Beyond ω", "comment": "21 pages", "summary": "Type theories with multi-clocked guarded recursion provide a flexible framework for programming with coinductive types encoding productivity in types. Combining this with solutions to general guarded domain equations one can also construct relatively simple denotational models of programming languages with advanced features. These constructions have previously been explored in the setting of extensional type theory through a presheaf model, which proves correctness of encodings of W-types. That model has been adapted to presheaves of cubical sets (functors into the category of cubical sets), where the model verifies correctness of encodings also of coinductive types whose definitions involve quotient inductive types such as finite powersets or finite distributions. Likewise the cubical model also verifies correctness of coinductive predicates defined using existential quantification and allows the results to be related to the global world of cubical sets.\n  This paper looks at how to extend the extensional presheaf model of multi-clocked guarded recursion to higher ordinals, so that correctness of encodings of coinductive types can be extended from W-types to those involving finite powersets and finite distributions, as well as coinductive predicates involving existential quantification. This extension will allow results previously proved in Clocked Cubical Type Theory to be interpreted in a model based on set-theory, proving the correctness of these results as understood in their usual set theoretic interpretation."}
{"id": "2512.11398", "categories": ["cs.SE", "cs.MA"], "pdf": "https://arxiv.org/pdf/2512.11398", "abs": "https://arxiv.org/abs/2512.11398", "authors": ["Qiuming Luo", "Yanming Lei", "Kunzhong Wu", "Yixuan Cao", "Chengjian Liu"], "title": "AutoFSM: A Multi-agent Framework for FSM Code Generation with IR and SystemC-Based Testing", "comment": "This version corrects a typo in the section title (\"Intruction\" -> \"Introduction\") that appears in the published version", "summary": "With the rapid advancement of large language models (LLMs) in code generation, their applications in hardware design are receiving growing attention. However, existing LLMs face several challenges when generating Verilog code for finite state machine (FSM) control logic, including frequent syntax errors, low debugging efficiency, and heavy reliance on test benchmarks. To address these challenges, this paper proposes AutoFSM, a multi-agent collaborative framework designed for FSM code generation tasks. AutoFSM introduces a structurally clear intermediate representation (IR) to reduce syntax error rate during code generation and provides a supporting toolchain to enable automatic translation from IR to Verilog. Furthermore, AutoFSM is the first to integrate SystemC-based modeling with automatic testbench generation, thereby improving debugging efficiency and feedback quality. To systematically evaluate the framework's performance, we construct SKT-FSM, the first hierarchical FSM benchmark in the field, comprising 67 FSM samples across different complexity levels. Experimental results show that, under the same base LLM, AutoFSM consistently outperforms the open-source framework MAGE on the SKT-FSM benchmark, achieving up to an 11.94% improvement in pass rate and up to a 17.62% reduction in syntax error rate. These results demonstrate the potential of combining LLMs with structured IR and automated testing to improve the reliability and scalability of register-transfer level (RTL) code generation."}
{"id": "2512.11435", "categories": ["cs.LO"], "pdf": "https://arxiv.org/pdf/2512.11435", "abs": "https://arxiv.org/abs/2512.11435", "authors": ["Tuyen Van Kieu", "Phong Chi Nguyen", "Bao Gia Hoang", "Khanh Van To"], "title": "Compact SAT Encoding for Power Peak Minimization", "comment": null, "summary": "The Simple Assembly Line Balancing Problem with Power Peak Minimization (SALBP-3PM) minimizes maximum instantaneous power usage while assigning $n$ tasks to $m$ workstations and determining execution schedules within given cycle time constraints. This NP-hard problem couples workstation assignment, temporal sequencing, and power aggregation, presenting significant computational challenges for exact optimization methods. Existing Boolean Satisfiability (SAT) and Maximum Satisfiability (MaxSAT) approaches suffer from baseline encodings generating $O(m^2)$ clauses per precedence edge. We introduce a Compact SAT Encoding (CSE) achieving $O(m)$ clauses per transitive precedence edge using sequential counter techniques. We instantiate four optimization variants: Clause-Based iterative SAT, Pseudo-Boolean (PB) Constraint iterative SAT, MaxSAT, and Incremental SAT. Comprehensive experimental evaluation on benchmark instances demonstrates consistent performance improvements over state-of-the-art approaches, enabling exact optimization on previously intractable industrial-scale instances. The encoding principles generalize to other assembly line balancing variants and broader scheduling problems with precedence constraints."}
{"id": "2512.11402", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2512.11402", "abs": "https://arxiv.org/abs/2512.11402", "authors": ["Aryan Gupta", "Y. Raghu Reddy"], "title": "REMODEL-LLM: Transforming C code to Java using LLMs", "comment": null, "summary": "The automated translation of C code to Java code is a notoriously difficult task, fraught with challenges stemming from fundamental paradigm shifts (procedural vs. Object Oriented), memory models (manual pointers vs. Garbage Collection), and incompatible data types. This paper investigates the efficacy of 19 small, quantized LLMs (under 20 billion parameters) for the C to Java translation task. We use a novel, hybrid pipeline that leverages Abstract Syntax Trees (ASTs) for semantic decomposition and employs a highly constrained, rule based prompting strategy. The results are stark: a clear multi tiered performance divide emerged. The vast majority of models (Tier 3, e.g., llama3.1, gemma3, starcoder2) failed 100\\% of the tests, proving incapable of generating even basic, runnable Java boilerplate. A small middle tier (Tier 2, e.g., mistral-nemo and mistral) produced runnable code but was plagued by dangerous semantic failures and wrong translations. Only three models (Tier 1: phi4, deepseek-coder-v2, codeqwen) proved viable, passing over 50\\% of the test suite. Even these top models failed on the most complex C concepts, such as function pointers, sizeof, and enum logic, revealing a hard ceiling for the reasoning capabilities of current quantized models."}
{"id": "2512.11577", "categories": ["cs.LO", "cs.PL"], "pdf": "https://arxiv.org/pdf/2512.11577", "abs": "https://arxiv.org/abs/2512.11577", "authors": ["Sergei Stepanenko", "Emma Nardino", "Virgil Marionneau", "Dan Frumin", "Amin Timany", "Lars Birkedal"], "title": "Context-Dependent Effects and Concurrency in Guarded Interaction Trees", "comment": null, "summary": "Guarded Interaction Trees are a structure and a fully formalized framework for representing higher-order computations with higher-order effects in Rocq. We present an extension of Guarded Interaction Trees to support formal reasoning about context-dependent effects. That is, effects whose behaviors depend on the evaluation context, e.g., call/cc, shift and reset. Using and reasoning about such effects is challenging since certain compositionality principles no longer hold in the presence of such effects. For example, the so-called ``bind rule'' in modern program logics is no longer valid. The goal of our extension is to support representation and reasoning about context-dependent effects in the most painless way possible. To that end, our extension is conservative: the reasoning principles for context-independent effects remain the same. We use it to give direct-style denotational semantics for higher-order programming languages with call/cc and with delimited continuations. We extend the program logic for Guarded Interaction Trees to account for context-dependent effects, and we use the program logic to prove that the denotational semantics is adequate with respect to the operational semantics. Additionally, we retain the ability to combine multiple effects in a modular way, which we demonstrate by showing type soundness for safe interoperability of a programming language with delimited continuations and a programming language with higher-order store. Furthermore, as another contribution, in addition to context-dependent effects, we show how to extend Guarded Interaction Trees with preemptive concurrency. To support implementation and verification of concurrent data structures and algorithms in the presence of preemptive concurrency one requires atomic state modification operations, e.g., compare-and-exchange."}
{"id": "2512.11482", "categories": ["cs.SE", "cs.AI", "cs.CR"], "pdf": "https://arxiv.org/pdf/2512.11482", "abs": "https://arxiv.org/abs/2512.11482", "authors": ["Melih Catal", "Pooja Rani", "Harald C. Gall"], "title": "Towards Privacy-Preserving Code Generation: Differentially Private Code Language Models", "comment": null, "summary": "Large language models specialized for code (CodeLLMs) have demonstrated remarkable capabilities in generating code snippets, documentation, and test cases. However, despite their promising capabilities, CodeLLMs can inadvertently memorize and reproduce snippets from their training data, which poses risks of privacy breaches and intellectual property violations. These risks restrict the deployment of CodeLLMs in sensitive domains and limit their training datasets to publicly available sources. To mitigate the memorization risk without compromising their task performance, we apply Differential Privacy (DP) to CodeLLMs. To the best of our knowledge, this is the first comprehensive study that systematically evaluates the effectiveness of DP in CodeLLMs. DP adds calibrated noise to the training process to protect individual data points while still allowing the model to learn useful patterns. To this end, we first identify and understand the driving reasons of the memorization behaviour of the CodeLLMs during their fine-tuning. Then, to address this issue, we empirically evaluate the effect of DP on mitigating memorization while preserving code generation capabilities. Our findings show that DP substantially reduces memorization in CodeLLMs across all the tested snippet types. The snippet types most prone to memorization are also the most effectively mitigated by DP. Furthermore, we observe that DP slightly increases perplexity but preserves, and can even enhance, the code generation capabilities of CodeLLMs, which makes it feasible to apply DP in practice without significantly compromising model utility. Finally, we analyze the impact of DP on training efficiency and energy consumption, finding that DP does not significantly affect training time or energy usage, making it a practical choice for privacy-preserving CodeLLMs training."}
{"id": "2512.11527", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2512.11527", "abs": "https://arxiv.org/abs/2512.11527", "authors": ["Xi Wang", "Shuo Shi", "Chenyu Wu"], "title": "Mini-SFC: A Comprehensive Simulation Framework for Orchestration and Management of Service Function Chains", "comment": null, "summary": "In the continuously evolving cloud computing and network environment, service function chain (SFC) plays a crucial role in implementing complex services in the network with its flexible deployment capabilities. To address the limitations of existing SFC simulation tools, this paper introduces Mini-SFC, a modular simulation framework that supports both numerical and container-based virtual simulations, while also supporting online dynamic topology adjustments. As an open-source platform emphasizing user-friendliness, Mini-SFC facilitates rapid algorithm verification and realistic service deployment validation. By simplifying module design and providing standardized solver interfaces, Mini-SFC significantly shortens the learning curve for researchers and enhances the flexibility and scalability required for advanced SFC management and optimization. For readers interested in exploring or utilizing Mini-SFC, more information is available on the official project page."}
{"id": "2512.11589", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2512.11589", "abs": "https://arxiv.org/abs/2512.11589", "authors": ["Lukas Twist"], "title": "A Study of Library Usage in Agent-Authored Pull Requests", "comment": "5 pages, 3 tables", "summary": "Coding agents are becoming increasingly capable of completing end-to-end software engineering workflows that previously required a human developer, including raising pull requests (PRs) to propose their changes. However, we still know little about how these agents use libraries when generating code, a core part of real-world software development. To fill this gap, we study 26,760 agent-authored PRs from the AIDev dataset to examine three questions: how often do agents import libraries, how often do they introduce new dependencies (and with what versioning), and which specific libraries do they choose? We find that agents often import libraries (29.5% of PRs) but rarely add new dependencies (1.3% of PRs); and when they do, they follow strong versioning practices (75.0% specify a version), an improvement on direct LLM usage where versions are rarely mentioned. Generally, agents draw from a surprisingly diverse set of external libraries, contrasting with the limited \"library preferences\" seen in prior non-agentic LLM studies. Our results offer an early empirical view into how AI coding agents interact with today's software ecosystems."}

{"id": "2508.16671", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2508.16671", "abs": "https://arxiv.org/abs/2508.16671", "authors": ["Mingyang Zhou", "Quanming Yao", "Lun Du", "Lanning Wei", "Da Zheng"], "title": "Reflective Paper-to-Code Reproduction Enabled by Fine-Grained Verification", "comment": null, "summary": "Reproducing machine learning papers is essential for scientific progress but\nremains challenging for both humans and automated agents. Existing agent-based\nmethods often struggle to fully and accurately reproduce implementation details\nsuch as mathematical formulas and algorithmic logic. Previous studies show that\nreflection with explicit feedback improves agent performance. However, current\npaper reproduction methods fail to effectively adopt this strategy. This gap\nmainly arises from the diverse paper patterns, complex method modules, and\nvaried configurations encountered in research papers. Motivated by how humans\nuse systematic checklists to efficiently debug complex code, we propose\n\\textbf{RePro}, a \\textbf{Re}flective Paper-to-Code \\textbf{Repro}duction\nframework that automatically extracts a paper's fingerprint, referring to a\ncomprehensive set of accurate and atomic criteria serving as high-quality\nsupervisory signals. The framework first generates code based on the extracted\ninformation, and then leverages the fingerprint within iterative verification\nand refinement loop. This approach systematically detects discrepancies and\nproduces targeted revisions to align generated code with the paper's\nimplementation details. Extensive experiments on the PaperBench Code-Dev\nbenchmark have been conducted, RePro achieves 13.0\\% performance gap over\nbaselines, and it correctly revises complex logical and mathematical criteria\nin reflecting, on which the effectiveness is obvious."}
{"id": "2508.16678", "categories": ["cs.SE", "cs.MA"], "pdf": "https://arxiv.org/pdf/2508.16678", "abs": "https://arxiv.org/abs/2508.16678", "authors": ["Konrad Cinkusz", "Jarosław A. Chudziak", "Ewa Niewiadomska-Szynkiewicz"], "title": "Cognitive Agents Powered by Large Language Models for Agile Software Project Management", "comment": null, "summary": "This paper investigates the integration of cognitive agents powered by Large\nLanguage Models (LLMs) within the Scaled Agile Framework (SAFe) to reinforce\nsoftware project management. By deploying virtual agents in simulated software\nenvironments, this study explores their potential to fulfill fundamental roles\nin IT project development, thereby optimizing project outcomes through\nintelligent automation. Particular emphasis is placed on the adaptability of\nthese agents to Agile methodologies and their transformative impact on\ndecision-making, problem-solving, and collaboration dynamics. The research\nleverages the CogniSim ecosystem, a platform designed to simulate real-world\nsoftware engineering challenges, such as aligning technical capabilities with\nbusiness objectives, managing interdependencies, and maintaining project\nagility. Through iterative simulations, cognitive agents demonstrate advanced\ncapabilities in task delegation, inter-agent communication, and project\nlifecycle management. By employing natural language processing to facilitate\nmeaningful dialogues, these agents emulate human roles and improve the\nefficiency and precision of Agile practices. Key findings from this\ninvestigation highlight the ability of LLM-powered cognitive agents to deliver\nmeasurable improvements in various metrics, including task completion times,\nquality of deliverables, and communication coherence. These agents exhibit\nscalability and adaptability, ensuring their applicability across diverse and\ncomplex project environments. This study underscores the potential of\nintegrating LLM-powered agents into Agile project management frameworks as a\nmeans of advancing software engineering practices. This integration not only\nrefines the execution of project management tasks but also sets the stage for a\nparadigm shift in how teams collaborate and address emerging challenges."}
{"id": "2508.16684", "categories": ["cs.SE", "cs.HC"], "pdf": "https://arxiv.org/pdf/2508.16684", "abs": "https://arxiv.org/abs/2508.16684", "authors": ["Vikranth Udandarao", "Nipun Misra"], "title": "Democratizing AI Development: Local LLM Deployment for India's Developer Ecosystem in the Era of Tokenized APIs", "comment": "for survey results, check\n  https://docs.google.com/spreadsheets/d/1t0eV9oURaiu2HfARWo6sriBO0eC8bHUyZNN7CgK2NAk/edit?usp=sharing", "summary": "India's developer community faces significant barriers to sustained\nexperimentation and learning with commercial Large Language Model (LLM) APIs,\nprimarily due to economic and infrastructural constraints. This study\nempirically evaluates local LLM deployment using Ollama as an alternative to\ncommercial cloud-based services for developer-focused applications. Through a\nmixed-methods analysis involving 180 Indian developers, students, and AI\nenthusiasts, we find that local deployment enables substantially greater\nhands-on development and experimentation, while reducing costs by 33% compared\nto commercial solutions. Developers using local LLMs completed over twice as\nmany experimental iterations and reported deeper understanding of advanced AI\narchitectures. Our results highlight local deployment as a critical enabler for\ninclusive and accessible AI development, demonstrating how technological\naccessibility can enhance learning outcomes and innovation capacity in\nresource-constrained environments."}
{"id": "2508.16688", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2508.16688", "abs": "https://arxiv.org/abs/2508.16688", "authors": ["Ankur Tomar", "Hengyue Liang", "Indranil Bhattacharya", "Natalia Larios", "Francesco Carbone"], "title": "Cybernaut: Towards Reliable Web Automation", "comment": null, "summary": "The emergence of AI-driven web automation through Large Language Models\n(LLMs) offers unprecedented opportunities for optimizing digital workflows.\nHowever, deploying such systems within industry's real-world environments\npresents four core challenges: (1) ensuring consistent execution, (2)\naccurately identifying critical HTML elements, (3) meeting human-like accuracy\nin order to automate operations at scale and (4) the lack of comprehensive\nbenchmarking data on internal web applications. Existing solutions are\nprimarily tailored for well-designed, consumer-facing websites (e.g.,\nAmazon.com, Apple.com) and fall short in addressing the complexity of\npoorly-designed internal web interfaces. To address these limitations, we\npresent Cybernaut, a novel framework to ensure high execution consistency in\nweb automation agents designed for robust enterprise use. Our contributions are\nthreefold: (1) a Standard Operating Procedure (SOP) generator that converts\nuser demonstrations into reliable automation instructions for linear browsing\ntasks, (2) a high-precision HTML DOM element recognition system tailored for\nthe challenge of complex web interfaces, and (3) a quantitative metric to\nassess execution consistency. The empirical evaluation on our internal\nbenchmark demonstrates that using our framework enables a 23.2% improvement\n(from 72% to 88.68%) in task execution success rate over the browser_use.\nCybernaut identifies consistent execution patterns with 84.7% accuracy,\nenabling reliable confidence assessment and adaptive guidance during task\nexecution in real-world systems. These results highlight Cybernaut's\neffectiveness in enterprise-scale web automation and lay a foundation for\nfuture advancements in web automation."}
{"id": "2508.16746", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2508.16746", "abs": "https://arxiv.org/abs/2508.16746", "authors": ["Karuna Grewal", "P. Brighten Godfrey", "Justin Hsu"], "title": "SafeTree: Expressive Tree Policies for Microservices", "comment": null, "summary": "A microservice-based application is composed of multiple self-contained\ncomponents called microservices, and controlling inter-service communication is\nimportant for enforcing safety properties. Presently, inter-service\ncommunication is configured using microservice deployment tools. However, such\ntools only support a limited class of single-hop policies, which can be overly\npermissive because they ignore the rich service tree structure of microservice\ncalls. Policies that can express the service tree structure can offer\ndevelopment and security teams more fine-grained control over communication\npatterns.\n  To this end, we design an expressive policy language to specify service tree\nstructures, and we develop a visibly pushdown automata-based dynamic\nenforcement mechanism to enforce service tree policies. Our technique is\nnon-invasive: it does not require any changes to service implementations, and\ndoes not require access to microservice code. To realize our method, we build a\nruntime monitor on top of a service mesh, an emerging network infrastructure\nlayer that can control inter-service communication during deployment. In\nparticular, we employ the programmable network traffic filtering capabilities\nof Istio, a popular service mesh implementation, to implement an online and\ndistributed monitor. Our experiments show that our monitor can enforce rich\nsafety properties while adding minimal latency overhead on the order of\nmilliseconds."}
{"id": "2508.16782", "categories": ["cs.LO", "cs.SE", "68N17 (Primary) 68N30, 68Q60 (Secondary)", "D.1.6; D.2.3; F.3.1"], "pdf": "https://arxiv.org/pdf/2508.16782", "abs": "https://arxiv.org/abs/2508.16782", "authors": ["Włodzimierz Drabent"], "title": "On systematic construction of correct logic programs", "comment": "21 pages. Accepted for ICLP 2025 (The 41st International Conference\n  on Logic Programming)", "summary": "Partial correctness of imperative or functional programming divides in logic\nprogramming into two notions. Correctness means that all answers of the program\nare compatible with the specification. Completeness means that the program\nproduces all the answers required by the specifications. We also consider\nsemi-completeness -- completeness for those queries for which the program does\nnot diverge. This paper presents an approach to systematically construct\nprovably correct and semi-complete logic programs, for a given specification.\nNormal programs are considered, under Kunen's 3-valued completion semantics (of\nnegation as finite failure) and the well-founded semantics (of negation as\npossibly infinite failure). The approach is declarative, it abstracts from\ndetails of operational semantics, like e.g.\\ the form of the selected literals\n(``procedure calls'') during the computation. The proposed method is simple,\nand can be used (maybe informally) in actual everyday programming."}
{"id": "2508.17451", "categories": ["cs.FL", "cs.LO"], "pdf": "https://arxiv.org/pdf/2508.17451", "abs": "https://arxiv.org/abs/2508.17451", "authors": ["Davide Ancona", "Angelo Ferrando"], "title": "On The Space Complexity of Partial Derivatives of Regular Expressions with Shuffle", "comment": null, "summary": "Partial derivatives of regular expressions, introduced by Antimirov, define\nan elegant algorithm for generating equivalent non-deterministic finite\nautomata (NFA) with a limited number of states.\n  Here we focus on runtime verification (RV) of simple properties expressible\nwith regular expressions. In this case, words are finite traces of monitorable\nevents forming the language's alphabet, and the generated NFA may have an\nintractable number of states.\n  This typically occurs when sub-traces of mutually independent events are\nallowed to interleave.\n  To address this issue, regular expressions used for RV are extended with the\nshuffle operator to make specifications more compact and easier to read.\n  Exploiting partial derivatives enables a rewriting-based approach to RV,\nwhere only one derivative is stored at each step, avoiding the construction of\nan intractably large automaton.\n  This raises the question of the space complexity of the largest generated\npartial derivative. While the total number of generated partial derivatives is\nknown to be linear in the size of the initial regular expression, no results\ncan be found in the literature regarding the size of the largest partial\nderivative.\n  We study this problem w.r.t. two metrics (height and size of regular\nexpressions), and show that the former increases by at most one, while the\nlatter is quadratic in the size of the regular expression. Surprisingly, these\nresults also hold with shuffle."}
{"id": "2508.16708", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2508.16708", "abs": "https://arxiv.org/abs/2508.16708", "authors": ["Shufeng Chen", "Halima El Badaoui", "Mariat James Elizebeth", "Takuya Nakashima", "Siddartha Khastgir", "Paul Jennings"], "title": "A Scalable Framework for the Management of STPA Requirements: a Case Study on eVTOL Operations", "comment": null, "summary": "System-Theoretic Process Analysis (STPA) is a recommended method for\nanalysing complex systems, capable of identifying thousands of safety\nrequirements often missed by traditional techniques such as Failure Mode and\nEffects Analysis (FMEA) and Fault Tree Analysis (FTA). However, the absence of\na structured framework for managing and prioritising these requirements\npresents challenges, particularly in fast-paced development environments. This\npaper introduces a scalable framework for prioritising STPA-derived\nrequirements. The framework integrates outputs from each STPA step and\nincorporates expert evaluations based on four key factors: implementation time,\ncost, requirement type, and regulatory coverage. To reduce subjectivity,\nMonte-Carlo Simulation (MCS) is employed to calculate and stabilise requirement\nrankings. An automation toolchain supports the framework, enabling dynamic\nmapping of prioritised requirements in a scaling matrix. This visualisation\naids decision-making and ensures traceability across development phases. The\nframework is applicable from early conceptualisation to more advanced stages,\nenhancing its utility in iterative system development. The framework was\nvalidated through a real-world case study focused on Electric Vertical Take-off\nand Landing (eVTOL) operations, conducted in collaboration with the UK Civil\nAviation Authority. The findings contributed directly to CAP3141, a Civil\nAviation Publication that identifies systemic operational risks and safety\nmitigations for regulators, operators, and vertiports. The prioritisation\nprocess supported decision-making by helping stakeholders identify and manage\nhigh-impact requirements efficiently. This work contributes a practical\nsolution for managing STPA outputs, bridging gaps in requirement prioritisation\nand supporting safety-critical development in emerging technologies."}
{"id": "2508.16848", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2508.16848", "abs": "https://arxiv.org/abs/2508.16848", "authors": ["David Moon", "Andrew Blinn", "Thomas J. Porter", "Cyrus Omar"], "title": "Syntactic Completions with Material Obligations", "comment": null, "summary": "Code editors provide essential services that help developers understand,\nnavigate, and modify programs. However, these services often fail in the\npresence of syntax errors. Existing syntax error recovery techniques, like\npanic mode and multi-option repairs, are either too coarse, e.g. in deleting\nlarge swathes of code, or lead to a proliferation of possible completions. This\npaper introduces $\\texttt{tylr}$, a parser and editor generator that completes\narbitrarily malformed code by inserting obligations, which generalize holes to\ncover missing operands, operators, mixfix keywords, and sort transitions.\n$\\texttt{tylr}$ is backed by a novel theory of tile-based parsing, which\nextends operator-precedence parsing in two ways. First, traditional token\nprecedence comparisons are replaced by a notion of grammar walks, which form\nthe basis for generating obligations. Second, a distinct \"molding\" system based\non grammar zippers expand grammar expressivity by allowing the system to\ndisambiguate between possible parses and completions based on an obligation\nminimization criterion. In addition to serving as a novel approach to error\ncorrection, $\\texttt{tylr}$'s design enables the development of an editor that\nvisually materializes obligations to the human user, serving as a novel hybrid\nbetween a text editor and a structure editor. We introduce $\\texttt{tylr}$ by\nexample, then formalize its key ideas. Finally, we conduct a human subjects\nstudy to evaluate the extent to which an editor like $\\texttt{tylr}$ that\nmaterializes syntactic obligations might be usable and useful, finding both\npoints of positivity and interesting new avenues for future work."}
{"id": "2508.17758", "categories": ["cs.LO"], "pdf": "https://arxiv.org/pdf/2508.17758", "abs": "https://arxiv.org/abs/2508.17758", "authors": ["Han Gao", "Daniil Kozhemiachenko", "Nicola Olivetti"], "title": "Paraconsistent Constructive Modal Logic", "comment": null, "summary": "We present a family of paraconsistent counterparts of the constructive modal\nlogic CK. These logics aim to formalise reasoning about contradictory but\nnon-trivial propositional attitudes like beliefs or obligations. We define\ntheir Kripke-style semantics based on intuitionistic frames with two valuations\nwhich provide independent support for truth and falsity; they are connected by\nstrong negation as defined in Nelson's logic. A family of systems is obtained\ndepending on whether both modal operators are defined using the same or by\ndifferent accessibility relations for their positive and negative support. We\npropose Hilbert-style axiomatisations for all logics determined by this\nsemantic framework. We also propose a~family of modular cut-free sequent\ncalculi that we use to establish decidability."}
{"id": "2508.18133", "categories": ["cs.FL", "68Q70, 68Q45, 68P30", "F.4.3; E.4; F.1.1"], "pdf": "https://arxiv.org/pdf/2508.18133", "abs": "https://arxiv.org/abs/2508.18133", "authors": ["Eugene Asarin", "Aldric Degorre", "Catalin Dima", "Bernardo Jacobo Inclán"], "title": "Weighing Obese Timed Languages", "comment": "30 pages, 8 figures, accepted to Reachability Problems - RP'2025,\n  short (14 pages) version will be published by Springer Nature in the\n  Proceedings of RP'2025", "summary": "The bandwidth of a timed language characterizes the quantity of information\nper time unit (with a finite observation precision $\\varepsilon$). Obese timed\nautomata have an unbounded frequency of events and produce information at the\nmaximal possible rate. In this article, we compute the bandwidth of any such\nautomaton in the form $\\approx\\alpha/\\varepsilon$. Our approach reduces the\nproblem to computing the best reward-to-time ratio in a weighted timed graph\nconstructed from the given timed automaton, with weights corresponding to the\nentropy of auxiliary finite automata."}
{"id": "2508.16713", "categories": ["cs.SE", "cs.AI", "hep-ex"], "pdf": "https://arxiv.org/pdf/2508.16713", "abs": "https://arxiv.org/abs/2508.16713", "authors": ["Mohammad Atif", "Kriti Chopra", "Ozgur Kilic", "Tianle Wang", "Zhihua Dong", "Charles Leggett", "Meifeng Lin", "Paolo Calafiura", "Salman Habib"], "title": "CelloAI: Leveraging Large Language Models for HPC Software Development in High Energy Physics", "comment": "12 pages, 2 figures", "summary": "Next-generation High Energy Physics (HEP) experiments will generate\nunprecedented data volumes, necessitating High Performance Computing (HPC)\nintegration alongside traditional high-throughput computing. However, HPC\nadoption in HEP is hindered by the challenge of porting legacy software to\nheterogeneous architectures and the sparse documentation of these complex\nscientific codebases. We present CelloAI, a locally hosted coding assistant\nthat leverages Large Language Models (LLMs) with retrieval-augmented generation\n(RAG) to support HEP code documentation and generation. This local deployment\nensures data privacy, eliminates recurring costs and provides access to large\ncontext windows without external dependencies. CelloAI addresses two primary\nuse cases, code documentation and code generation, through specialized\ncomponents. For code documentation, the assistant provides: (a) Doxygen style\ncomment generation for all functions and classes by retrieving relevant\ninformation from RAG sources (papers, posters, presentations), (b) file-level\nsummary generation, and (c) an interactive chatbot for code comprehension\nqueries. For code generation, CelloAI employs syntax-aware chunking strategies\nthat preserve syntactic boundaries during embedding, improving retrieval\naccuracy in large codebases. The system integrates callgraph knowledge to\nmaintain dependency awareness during code modifications and provides\nAI-generated suggestions for performance optimization and accurate refactoring.\nWe evaluate CelloAI using real-world HEP applications from ATLAS, CMS, and DUNE\nexperiments, comparing different embedding models for code retrieval\neffectiveness. Our results demonstrate the AI assistant's capability to enhance\ncode understanding and support reliable code generation while maintaining the\ntransparency and safety requirements essential for scientific computing\nenvironments."}
{"id": "2508.17344", "categories": ["cs.SE", "cs.LG", "cs.PF", "cs.PL"], "pdf": "https://arxiv.org/pdf/2508.17344", "abs": "https://arxiv.org/abs/2508.17344", "authors": ["Rajrupa Chattaraj", "Sridhar Chimalakonda", "Vibhu Saujanya Sharma", "Vikrant Kaulgud"], "title": "Who Wins the Race? (R Vs Python) - An Exploratory Study on Energy Consumption of Machine Learning Algorithms", "comment": "18 pages including references, 5 figures", "summary": "The utilization of Machine Learning (ML) in contemporary software systems is\nextensive and continually expanding. However, its usage is energy-intensive,\ncontributing to increased carbon emissions and demanding significant resources.\nWhile numerous studies examine the performance and accuracy of ML, only a\nlimited few focus on its environmental aspects, particularly energy\nconsumption. In addition, despite emerging efforts to compare energy\nconsumption across various programming languages for specific algorithms and\ntasks, there remains a gap specifically in comparing these languages for\nML-based tasks. This paper aims to raise awareness of the energy costs\nassociated with employing different programming languages for ML model training\nand inference. Through this empirical study, we measure and compare the energy\nconsumption along with run-time performance of five regression and five\nclassification tasks implemented in Python and R, the two most popular\nprogramming languages in this context. Our study results reveal a statistically\nsignificant difference in costs between the two languages in 95% of the cases\nexamined. Furthermore, our analysis demonstrates that the choice of programming\nlanguage can influence energy efficiency significantly, up to 99.16% during\nmodel training and up to 99.8% during inferences, for a given ML task."}
{"id": "2508.17859", "categories": ["cs.LO"], "pdf": "https://arxiv.org/pdf/2508.17859", "abs": "https://arxiv.org/abs/2508.17859", "authors": ["Christel Baier", "Calvin Chau", "Volodymyr Drobitko", "Simon Jantsch", "Sascha Klüppelholz"], "title": "Certificates and Witnesses for Multi-objective ω-regular Queries in Markov Decision Processes", "comment": "This preprint has not undergone peer review (when applicable) or any\n  post-submission improvements or corrections. To appear at SEFM 2025", "summary": "Multi-objective probabilistic model checking is a powerful technique for\nverifying stochastic systems against multiple (potentially conflicting)\nproperties. To enhance the trustworthiness and explainability of model checking\ntools, we present independently checkable certificates and witnesses for\nmulti-objective {\\omega}-regular queries in Markov decision processes. For the\ncertification, we extend and improve existing certificates for the\ndecomposition of maximal end components and reachability properties. We then\nderive mixed-integer linear programs (MILPs) for finding minimal witnessing\nsubsystems. For the special case of Markov chains and LTL properties, we use\nunambiguous B\\\"uchi automata to find witnesses, resulting in an algorithm that\nrequires single-exponential space. Existing approaches based on deterministic\nautomata require doubly-exponential space in the worst case. Finally, we\nconsider the practical computation of our certificates and witnesses and\nprovide an implementation of the developed techniques, along with an\nexperimental evaluation, demonstrating the efficacy of our techniques."}
{"id": "2508.16771", "categories": ["cs.SE", "cs.AI", "cs.HC"], "pdf": "https://arxiv.org/pdf/2508.16771", "abs": "https://arxiv.org/abs/2508.16771", "authors": ["Yifan Zhang", "Chen Huang", "Yueke Zhang", "Jiahao Zhang", "Toby Jia-Jun Li", "Collin McMillan", "Kevin Leach", "Yu Huang"], "title": "EyeMulator: Improving Code Language Models by Mimicking Human Visual Attention", "comment": null, "summary": "Code language models (so-called CodeLLMs) are now commonplace in software\ndevelopment. As a general rule, CodeLLMs are trained by dividing training\nexamples into input tokens and then learn importance of those tokens in a\nprocess called machine attention. Machine attention is based solely on input\ntoken salience to output token examples during training. Human software\ndevelopers are different, as humans intuitively know that some tokens are more\nsalient than others. While intuition itself is ineffable and a subject of\nphilosophy, clues about salience are present in human visual attention, since\npeople tend to look at more salient words more often. In this paper, we present\nEyeMulator, a technique for training CodeLLMs to mimic human visual attention\nwhile training for various software development tasks. We add special weights\nfor each token in each input example to the loss function used during LLM\nfine-tuning. We draw these weights from observations of human visual attention\nderived from a previously-collected publicly-available dataset of eye-tracking\nexperiments in software engineering tasks. These new weights ultimately induce\nchanges in the attention of the subject LLM during training, resulting in a\nmodel that does not need eye-tracking data during inference. Our evaluation\nshows that EyeMulator outperforms strong LLM baselines on several tasks such as\ncode translation, completion and summarization. We further show an ablation\nstudy that demonstrates the improvement is due to subject models learning to\nmimic human attention."}
{"id": "2508.18115", "categories": ["cs.LO", "cs.PL"], "pdf": "https://arxiv.org/pdf/2508.18115", "abs": "https://arxiv.org/abs/2508.18115", "authors": ["Quang Loc Le"], "title": "Compositional Verification in Concurrent Separation Logic with Permissions Regions", "comment": null, "summary": "Concurrent separation logic with fractional permissions (CSLPerm) provides a\npromising reasoning system to verify most complex sequential and concurrent\nfine-grained programs. The logic with strong and weak separating conjunctions\noffers a solid foundation for producing concise and precise proofs. However, it\nlacks automation and compositionality support. This paper addresses this\nlimitation by introducing a compositional verification system for concurrent\nprograms that manipulate regions of shared memory. The centre of our system is\nnovel logical principles and an entailment procedure that can infer the\nresidual heaps in the frame rule for a fragment of CSL-Perm with explicit\narithmetical constraints for memory heaps' disjointness. This procedure enables\nthe compositional reasoning for concurrent threads and function calls. We have\nimplemented the proposal in a prototype tool called CoSl, tested it with 10\nchallenging concurrent programs, including those beyond the state-of-the-art,\nand confirmed the advantage of our approach."}
{"id": "2508.17895", "categories": ["cs.LO"], "pdf": "https://arxiv.org/pdf/2508.17895", "abs": "https://arxiv.org/abs/2508.17895", "authors": ["Lidia Losavio", "Marco Paganoni", "Carlo A. Furia"], "title": "Model-Based Testing of an Intermediate Verifier Using Executable Operational Semantics", "comment": "In Proceedings of the 20th International Conference on integrated\n  Formal Methods (iFM), Paris, France, 17-21 November 2025", "summary": "Lightweight validation technique, such as those based on random testing, are\nsometimes practical alternatives to full formal verification -- providing\nvaluable benefits, such as finding bugs, without requiring a disproportionate\neffort. In fact, they can be useful even for fully formally verified tools, by\nexercising the parts of a complex system that go beyond the reach of formal\nmodels.\n  In this context, this paper introduces BCC: a model-based testing technique\nfor the Boogie intermediate verifier. BCC combines the formalization of a\nsmall, deterministic subset of the Boogie language with the generative\ncapabilities of the PLT Redex language engineering framework. Basically, BCC\nuses PLT Redex to generate random Boogie programs, and to execute them\naccording to a formal operational semantics; then, it runs the same programs\nthrough the Boogie verifier. Any inconsistency between the two executions (in\nPLT Redex and with Boogie) may indicate a potential bug in Boogie's\nimplementation.\n  To understand whether BCC can be useful in practice, we used it to generate\nthree million Boogie programs. These experiments found 2% of cases indicative\nof completeness failures (i.e., spurious verification failures) in Boogie's\ntoolchain. These results indicate that lightweight analysis tools, such as\nthose for model-based random testing, are also useful to test and validate\nformal verification tools such as Boogie."}
{"id": "2508.16853", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2508.16853", "abs": "https://arxiv.org/abs/2508.16853", "authors": ["Pratyush Nidhi Sharma", "Lauren Wright", "Anne Herfurth", "Munsif Sokiyna", "Pratyaksh Nidhi Sharma", "Sethu Das", "Mikko Siponen"], "title": "DevLicOps: A Framework for Mitigating Licensing Risks in AI-Generated Code", "comment": "18 pages, 1 figure, 2 Tables", "summary": "Generative AI coding assistants (ACAs) are widely adopted yet pose serious\nlegal and compliance risks. ACAs can generate code governed by restrictive\nopen-source licenses (e.g., GPL), potentially exposing companies to litigation\nor forced open-sourcing. Few developers are trained in these risks, and legal\nstandards vary globally, especially with outsourcing. Our article introduces\nDevLicOps, a practical framework that helps IT leaders manage ACA-related\nlicensing risks through governance, incident response, and informed tradeoffs.\nAs ACA adoption grows and legal frameworks evolve, proactive license compliance\nis essential for responsible, risk-aware software development in the AI era."}
{"id": "2508.18231", "categories": ["cs.LO", "cs.MA", "cs.PL"], "pdf": "https://arxiv.org/pdf/2508.18231", "abs": "https://arxiv.org/abs/2508.18231", "authors": ["Anjo Seidel", "Sarah Winkler", "Alessandro Gianola", "Marco Montali", "Mathias Weske"], "title": "To bind or not to bind? Discovering Stable Relationships in Object-centric Processes (Extended Version)", "comment": null, "summary": "Object-centric process mining investigates the intertwined behavior of\nmultiple objects in business processes. From object-centric event logs,\nobject-centric Petri nets (OCPN) can be discovered to replay the behavior of\nprocesses accessing different object types. Although they indicate how objects\nflow through the process and co-occur in events, OCPNs remain underspecified\nabout the relationships of objects. Hence, they are not able to represent\nsynchronization, i.e. executing objects only according to their intended\nrelationships, and fail to identify violating executions. Existing formal\nmodeling approaches, such as object-centric Petri nets with identifiers (OPID),\nrepresent object identities and relationships to synchronize them correctly.\nHowever, OPID discovery has not yet been studied. This paper uses explicit data\nmodels to bridge the gap between OCPNs and formal OPIDs. We identify the\nimplicit assumptions of stable many-to-one relationships in object-centric\nevent logs, which implies synchronization of related objects. To formally\nunderpin this observation, we combine OCPNs with explicit stable many-to-one\nrelationships in a rigorous mapping from OCPNs to OPIDs explicitly capturing\nthe intended stable relationships and the synchronization of related objects.\nWe prove that the original OCPNs and the resulting OPIDs coincide for those\nexecutions that satisfy the intended relationships. Moreover, we provide an\nimplementation of the mapping from OCPN to OPID under stable relationships."}
{"id": "2508.18115", "categories": ["cs.LO", "cs.PL"], "pdf": "https://arxiv.org/pdf/2508.18115", "abs": "https://arxiv.org/abs/2508.18115", "authors": ["Quang Loc Le"], "title": "Compositional Verification in Concurrent Separation Logic with Permissions Regions", "comment": null, "summary": "Concurrent separation logic with fractional permissions (CSLPerm) provides a\npromising reasoning system to verify most complex sequential and concurrent\nfine-grained programs. The logic with strong and weak separating conjunctions\noffers a solid foundation for producing concise and precise proofs. However, it\nlacks automation and compositionality support. This paper addresses this\nlimitation by introducing a compositional verification system for concurrent\nprograms that manipulate regions of shared memory. The centre of our system is\nnovel logical principles and an entailment procedure that can infer the\nresidual heaps in the frame rule for a fragment of CSL-Perm with explicit\narithmetical constraints for memory heaps' disjointness. This procedure enables\nthe compositional reasoning for concurrent threads and function calls. We have\nimplemented the proposal in a prototype tool called CoSl, tested it with 10\nchallenging concurrent programs, including those beyond the state-of-the-art,\nand confirmed the advantage of our approach."}
{"id": "2508.16860", "categories": ["cs.SE", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2508.16860", "abs": "https://arxiv.org/abs/2508.16860", "authors": ["Md Afif Al Mamun", "Gias Uddin", "Lan Xia", "Longyu Zhang"], "title": "TriagerX: Dual Transformers for Bug Triaging Tasks with Content and Interaction Based Rankings", "comment": "This work is currently under review at IEEE Transactions on Software\n  Engineering. The replication package will be made publicly available upon\n  acceptance", "summary": "Pretrained Language Models or PLMs are transformer-based architectures that\ncan be used in bug triaging tasks. PLMs can better capture token semantics than\ntraditional Machine Learning (ML) models that rely on statistical features\n(e.g., TF-IDF, bag of words). However, PLMs may still attend to less relevant\ntokens in a bug report, which can impact their effectiveness. In addition, the\nmodel can be sub-optimal with its recommendations when the interaction history\nof developers around similar bugs is not taken into account. We designed\nTriagerX to address these limitations. First, to assess token semantics more\nreliably, we leverage a dual-transformer architecture. Unlike current\nstate-of-the-art (SOTA) baselines that employ a single transformer\narchitecture, TriagerX collects recommendations from two transformers with each\noffering recommendations via its last three layers. This setup generates a\nrobust content-based ranking of candidate developers. TriagerX then refines\nthis ranking by employing a novel interaction-based ranking methodology, which\nconsiders developers' historical interactions with similar fixed bugs. Across\nfive datasets, TriagerX surpasses all nine transformer-based methods, including\nSOTA baselines, often improving Top-1 and Top-3 developer recommendation\naccuracy by over 10%. We worked with our large industry partner to successfully\ndeploy TriagerX in their development environment. The partner required both\ndeveloper and component recommendations, with components acting as proxies for\nteam assignments-particularly useful in cases of developer turnover or team\nchanges. We trained TriagerX on the partner's dataset for both tasks, and it\noutperformed SOTA baselines by up to 10% for component recommendations and 54%\nfor developer recommendations."}
{"id": "2508.18149", "categories": ["cs.LO"], "pdf": "https://arxiv.org/pdf/2508.18149", "abs": "https://arxiv.org/abs/2508.18149", "authors": ["Sarah Winkler"], "title": "First-Order LTLf Synthesis with Lookback (Extended Version)", "comment": "This is an extended version of the paper \"First-Order LTLf Synthesis\n  with Lookback\" accepted for the 28th European Conference on Artificial\n  Intelligence (ECAI-2025)", "summary": "Reactive synthesis addresses the problem of generating a controller for a\ntemporal specification in an adversarial environment; it was typically studied\nfor LTL. Driven by applications ranging from AI to business process management,\nLTL modulo first order-theories over finite traces (LTLfMT) has recently gained\ntraction, where propositional variables in properties are replaced by\nfirst-order constraints. Though reactive synthesis for LTLf with some\nfirst-order features has been addressed, existing work in this direction\nstrongly restricts or excludes the possibility to compare variables across\ninstants, a limitation that severely restricts expressiveness and\napplicability.\n  In this work we present a reactive synthesis procedure for LTLfMT, where\nproperties support \"lookback\" to model cross-instant comparison of variables.\nOur procedure works for full LTLfMT with lookback, subsuming the fragments of\nLTLfMT for which realizability was studied earlier. However, the setting with\ncross-instant comparison is inherently highly complex, as realizability is\nundecidable even over decidable background theories. Hence termination of our\napproach is in general not guaranteed. Nevertheless, we prove its soundness,\nand show that it is complete if a bound on the strategy length exists. Finally,\nwe show that our approach constitutes a decision procedure for several relevant\nfragments of LTLfMT, at once re-proving known decidability results and\nidentifying new decidable classes."}
{"id": "2508.16903", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2508.16903", "abs": "https://arxiv.org/abs/2508.16903", "authors": ["Yijun Lu", "Hironori Washizaki", "Naoyasu Ubayashi", "Nobukazu Yoshioka", "Chenhao Wu", "Masanari Kondo", "Yuyin Ma", "Jiong Dong", "Jianjin Zhao", "Dongqi Han"], "title": "Mind the Gap: A Decade-Scale Empirical Study of Multi-Stakeholder Dynamics in VR Ecosystem", "comment": null, "summary": "In the development and evolution of VR ecosystem, platform stakeholders\ncontinuously adapt their products in response to user and technical feedback,\noften reflected in subtle shifts in discussion topics or system updates. A\ncomprehensive understanding of these changes is essential for identifying gaps\nbetween user expectations and developer actions, which can guide more effective\nquality assurance and user-centered innovation. While previous studies have\nanalyzed either user reviews or developer discussions in isolation, such\napproaches typically fail to reveal how specific user concerns are (or are not)\naddressed by corresponding technical activities. To address this limitation,\nour study introduces a multi-view empirical framework that systematically\ncompares and aligns stakeholder perspectives. By applying topic modeling and\nquantitative impact analysis to 944,320 user reviews and 389,477 developer\nposts, we identify not only the overlap in concerns (e.g., performance, input\nmethods), but also clear gaps in areas like inclusivity and community safety\n(e.g., LGBTQ+ representation, child-friendly content). Our findings show that\nwhile users repeatedly raise such issues, they are rarely discussed in\ndeveloper forums. These insights enable data-driven recommendations for closing\nthe user-developer gap in VR ecosystems, offering practical implications for\nplatform governance and the design of next-generation VR systems."}
{"id": "2508.18162", "categories": ["cs.LO", "cs.AI", "cs.CC", "cs.LG"], "pdf": "https://arxiv.org/pdf/2508.18162", "abs": "https://arxiv.org/abs/2508.18162", "authors": ["Eric Alsmann", "Martin Lange"], "title": "The Computational Complexity of Satisfiability in State Space Models", "comment": "Accepted at ECAI 25", "summary": "We analyse the complexity of the satisfiability problem ssmSAT for State\nSpace Models (SSM), which asks whether an input sequence can lead the model to\nan accepting configuration. We find that ssmSAT is undecidable in general,\nreflecting the computational power of SSM. Motivated by practical settings, we\nidentify two natural restrictions under which ssmSAT becomes decidable and\nestablish corresponding complexity bounds. First, for SSM with bounded context\nlength, ssmSAT is NP-complete when the input length is given in unary and in\nNEXPTIME (and PSPACE-hard) when the input length is given in binary. Second,\nfor quantised SSM operating over fixed-width arithmetic, ssmSAT is\nPSPACE-complete resp. in EXPSPACE depending on the bit-width encoding. While\nthese results hold for diagonal gated SSM we also establish complexity bounds\nfor time-invariant SSM. Our results establish a first complexity landscape for\nformal reasoning in SSM and highlight fundamental limits and opportunities for\nthe verification of SSM-based language models."}
{"id": "2508.17161", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2508.17161", "abs": "https://arxiv.org/abs/2508.17161", "authors": ["Julyanara R. Silva", "Carlos Eduardo C. Dantas", "Marcelo A. Maia"], "title": "What Developers Ask to ChatGPT in GitHub Pull Requests? an Exploratory Study", "comment": "12 pages, 3 figures", "summary": "The emergence of Large Language Models (LLMs), such as ChatGPT, has\nintroduced a new set of tools to support software developers in solving pro-\ngramming tasks. However, our understanding of the interactions (i.e., prompts)\nbetween developers and ChatGPT that result in contributions to the codebase\nremains limited. To explore this limitation, we conducted a manual evaluation\nof 155 valid ChatGPT share links extracted from 139 merged Pull Requests (PRs),\nrevealing the interactions between developers and reviewers with ChatGPT that\nled to merges into the main codebase. Our results produced a catalog of 14\ntypes of ChatGPT requests categorized into four main groups. We found a\nsignificant number of requests involving code review and the implementation of\ncode snippets based on specific tasks. Developers also sought to clarify doubts\nby requesting technical explanations or by asking for text refinements for\ntheir web pages. Furthermore, we verified that prompts involving code\ngeneration generally required more interactions to produce the desired answer\ncompared to prompts requesting text review or technical information."}
{"id": "2508.18231", "categories": ["cs.LO", "cs.MA", "cs.PL"], "pdf": "https://arxiv.org/pdf/2508.18231", "abs": "https://arxiv.org/abs/2508.18231", "authors": ["Anjo Seidel", "Sarah Winkler", "Alessandro Gianola", "Marco Montali", "Mathias Weske"], "title": "To bind or not to bind? Discovering Stable Relationships in Object-centric Processes (Extended Version)", "comment": null, "summary": "Object-centric process mining investigates the intertwined behavior of\nmultiple objects in business processes. From object-centric event logs,\nobject-centric Petri nets (OCPN) can be discovered to replay the behavior of\nprocesses accessing different object types. Although they indicate how objects\nflow through the process and co-occur in events, OCPNs remain underspecified\nabout the relationships of objects. Hence, they are not able to represent\nsynchronization, i.e. executing objects only according to their intended\nrelationships, and fail to identify violating executions. Existing formal\nmodeling approaches, such as object-centric Petri nets with identifiers (OPID),\nrepresent object identities and relationships to synchronize them correctly.\nHowever, OPID discovery has not yet been studied. This paper uses explicit data\nmodels to bridge the gap between OCPNs and formal OPIDs. We identify the\nimplicit assumptions of stable many-to-one relationships in object-centric\nevent logs, which implies synchronization of related objects. To formally\nunderpin this observation, we combine OCPNs with explicit stable many-to-one\nrelationships in a rigorous mapping from OCPNs to OPIDs explicitly capturing\nthe intended stable relationships and the synchronization of related objects.\nWe prove that the original OCPNs and the resulting OPIDs coincide for those\nexecutions that satisfy the intended relationships. Moreover, we provide an\nimplementation of the mapping from OCPN to OPID under stable relationships."}
{"id": "2508.17343", "categories": ["cs.SE", "cs.AI", "D.2"], "pdf": "https://arxiv.org/pdf/2508.17343", "abs": "https://arxiv.org/abs/2508.17343", "authors": ["Abhik Roychoudhury"], "title": "Agentic AI for Software: thoughts from Software Engineering community", "comment": "4 pages", "summary": "AI agents have recently shown significant promise in software engineering.\nMuch public attention has been transfixed on the topic of code generation from\nLarge Language Models (LLMs) via a prompt. However, software engineering is\nmuch more than programming, and AI agents go far beyond instructions given by a\nprompt.\n  At the code level, common software tasks include code generation, testing,\nand program repair. Design level software tasks may include architecture\nexploration, requirements understanding, and requirements enforcement at the\ncode level. Each of these software tasks involves micro-decisions which can be\ntaken autonomously by an AI agent, aided by program analysis tools. This\ncreates the vision of an AI software engineer, where the AI agent can be seen\nas a member of a development team.\n  Conceptually, the key to successfully developing trustworthy agentic AI-based\nsoftware workflows will be to resolve the core difficulty in software\nengineering - the deciphering and clarification of developer intent.\nSpecification inference, or deciphering the intent, thus lies at the heart of\nmany software tasks, including software maintenance and program repair. A\nsuccessful deployment of agentic technology into software engineering would\ninvolve making conceptual progress in such intent inference via agents.\n  Trusting the AI agent becomes a key aspect, as software engineering becomes\nmore automated. Higher automation also leads to higher volume of code being\nautomatically generated, and then integrated into code-bases. Thus to deal with\nthis explosion, an emerging direction is AI-based verification and validation\n(V & V) of AI generated code. We posit that agentic software workflows in\nfuture will include such AIbased V&V."}
{"id": "2508.17451", "categories": ["cs.FL", "cs.LO"], "pdf": "https://arxiv.org/pdf/2508.17451", "abs": "https://arxiv.org/abs/2508.17451", "authors": ["Davide Ancona", "Angelo Ferrando"], "title": "On The Space Complexity of Partial Derivatives of Regular Expressions with Shuffle", "comment": null, "summary": "Partial derivatives of regular expressions, introduced by Antimirov, define\nan elegant algorithm for generating equivalent non-deterministic finite\nautomata (NFA) with a limited number of states.\n  Here we focus on runtime verification (RV) of simple properties expressible\nwith regular expressions. In this case, words are finite traces of monitorable\nevents forming the language's alphabet, and the generated NFA may have an\nintractable number of states.\n  This typically occurs when sub-traces of mutually independent events are\nallowed to interleave.\n  To address this issue, regular expressions used for RV are extended with the\nshuffle operator to make specifications more compact and easier to read.\n  Exploiting partial derivatives enables a rewriting-based approach to RV,\nwhere only one derivative is stored at each step, avoiding the construction of\nan intractably large automaton.\n  This raises the question of the space complexity of the largest generated\npartial derivative. While the total number of generated partial derivatives is\nknown to be linear in the size of the initial regular expression, no results\ncan be found in the literature regarding the size of the largest partial\nderivative.\n  We study this problem w.r.t. two metrics (height and size of regular\nexpressions), and show that the former increases by at most one, while the\nlatter is quadratic in the size of the regular expression. Surprisingly, these\nresults also hold with shuffle."}
{"id": "2508.17344", "categories": ["cs.SE", "cs.LG", "cs.PF", "cs.PL"], "pdf": "https://arxiv.org/pdf/2508.17344", "abs": "https://arxiv.org/abs/2508.17344", "authors": ["Rajrupa Chattaraj", "Sridhar Chimalakonda", "Vibhu Saujanya Sharma", "Vikrant Kaulgud"], "title": "Who Wins the Race? (R Vs Python) - An Exploratory Study on Energy Consumption of Machine Learning Algorithms", "comment": "18 pages including references, 5 figures", "summary": "The utilization of Machine Learning (ML) in contemporary software systems is\nextensive and continually expanding. However, its usage is energy-intensive,\ncontributing to increased carbon emissions and demanding significant resources.\nWhile numerous studies examine the performance and accuracy of ML, only a\nlimited few focus on its environmental aspects, particularly energy\nconsumption. In addition, despite emerging efforts to compare energy\nconsumption across various programming languages for specific algorithms and\ntasks, there remains a gap specifically in comparing these languages for\nML-based tasks. This paper aims to raise awareness of the energy costs\nassociated with employing different programming languages for ML model training\nand inference. Through this empirical study, we measure and compare the energy\nconsumption along with run-time performance of five regression and five\nclassification tasks implemented in Python and R, the two most popular\nprogramming languages in this context. Our study results reveal a statistically\nsignificant difference in costs between the two languages in 95% of the cases\nexamined. Furthermore, our analysis demonstrates that the choice of programming\nlanguage can influence energy efficiency significantly, up to 99.16% during\nmodel training and up to 99.8% during inferences, for a given ML task."}
{"id": "2508.17713", "categories": ["cs.SE", "cs.AR"], "pdf": "https://arxiv.org/pdf/2508.17713", "abs": "https://arxiv.org/abs/2508.17713", "authors": ["Zhihao Xu", "Shikai Guo", "Guilin Zhao", "Peiyu Zou", "Siwen Wang", "Qian Ma", "Hui Li", "Furui Zhan"], "title": "Code Difference Guided Fuzzing for FPGA Logic Synthesis Compilers via Bayesian Optimization", "comment": null, "summary": "Field Programmable Gate Arrays (FPGAs) play a crucial role in Electronic\nDesign Automation (EDA) applications, which have been widely used in\nsafety-critical environments, including aerospace, chip manufacturing, and\nmedical devices. A critical step in FPGA development is logic synthesis, which\nenables developers to translate their software designs into hardware net lists,\nwhich facilitates the physical implementation of the chip, detailed timing and\npower analysis, gate-level simulation, test vector generation, and optimization\nand consistency checking. However, bugs or incorrect implementations in FPGA\nlogic synthesis compilers may lead to unexpected behaviors in target\nwapplications, posing security risks. Therefore, it is crucial to eliminate\nsuch bugs in FPGA logic synthesis compilers. The effectiveness of existing\nworks is still limited by its simple, blind mutation strategy. To address this\nchallenge, we propose a guided mutation strategy based on Bayesian optimization\ncalled LSC-Fuzz to detect bugs in FPGA logic synthesis compilers. Specifically,\nLSC-Fuzz consists of three components: the test-program generation component,\nthe Bayesian diversity selection component, and the equivalent check component.\nBy performing test-program generation and Bayesian diversity selection,\nLSC-Fuzz generates diverse and complex HDL code, thoroughly testing the FPGA\nlogic synthesis compilers using equivalent check to detect bugs. Through three\nmonths, LSC-Fuzz has found 16 bugs, 12 of these has been confirmed by official\ntechnical support."}
{"id": "2508.17719", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2508.17719", "abs": "https://arxiv.org/abs/2508.17719", "authors": ["Akhila Sri Manasa Venigalla", "Sridhar Chimalakonda"], "title": "DocFetch - Towards Generating Software Documentation from Multiple Software Artifacts", "comment": "12 pages, 7 Figures, 4 Tables", "summary": "Software Documentation plays a major role in the usage and development of a\nproject. Widespread adoption of open source software projects contributes to\nlarger and faster development of the projects, making it difficult to maintain\nthe associated documentation. Existing automated approaches to generate\ndocumentation largely focus on source code. However, information useful for\ndocumentation is observed to be scattered across various artifacts that\nco-evolve with the source code. Leveraging this information across multiple\nartifacts can reduce the effort involved in maintaining documentation. Hence,\nwe propose DocFetch, to generate different types of documentation from multiple\nsoftware artifacts. We employ a multi-layer prompt based LLM and generate\nstructured documentation corresponding to different documentation types for the\ndata consolidated in DocMine dataset. We evaluate the performance of DocFetch\nusing a manually curated groundtruth dataset by analysing the artifacts in\nDocMine. The evaluation yields a highest BLEU-4 score of 43.24% and ROUGE-L\nscore of 0.39 for generation of api-related and file-related information from\nfive documentation sources. The generation of other documentation type related\ninformation also reported BLEU-4 scores close to 30% indicating good\nperformance of the approach. Thus,DocFetch can be employed to\nsemi-automatically generate documentation, and helps in comprehending the\nprojects with minimal effort in maintaining the documentation."}
{"id": "2508.17720", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2508.17720", "abs": "https://arxiv.org/abs/2508.17720", "authors": ["Ziqi Guan", "Xin Yin", "Zhiyuan Peng", "Chao Ni"], "title": "RepoTransAgent: Multi-Agent LLM Framework for Repository-Aware Code Translation", "comment": null, "summary": "Repository-aware code translation is critical for modernizing legacy systems,\nenhancing maintainability, and enabling interoperability across diverse\nprogramming languages. While recent advances in large language models (LLMs)\nhave improved code translation quality, existing approaches face significant\nchallenges in practical scenarios: insufficient contextual understanding,\ninflexible prompt designs, and inadequate error correction mechanisms. These\nlimitations severely hinder accurate and efficient translation of complex,\nreal-world code repositories. To address these challenges, we propose\nRepoTransAgent, a novel multi-agent LLM framework for repository-aware code\ntranslation. RepoTransAgent systematically decomposes the translation process\ninto specialized subtasks-context retrieval, dynamic prompt construction, and\niterative code refinement-each handled by dedicated agents. Our approach\nleverages retrieval-augmented generation (RAG) for contextual information\ngathering, employs adaptive prompts tailored to varying repository scenarios,\nand introduces a reflection-based mechanism for systematic error correction. We\nevaluate RepoTransAgent on hundreds of Java-C# translation pairs from six\npopular open-source projects. Experimental results demonstrate that\nRepoTransAgent significantly outperforms state-of-the-art baselines in both\ncompile and pass rates. Specifically, RepoTransAgent achieves up to 55.34%\ncompile rate and 45.84% pass rate. Comprehensive analysis confirms the\nrobustness and generalizability of RepoTransAgent across different LLMs,\nestablishing its effectiveness for real-world repository-aware code\ntranslation."}
{"id": "2508.17851", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2508.17851", "abs": "https://arxiv.org/abs/2508.17851", "authors": ["Patrick Loic Foalem", "Leuson Da Silva", "Foutse Khomh", "Heng Li", "Ettore Merlo"], "title": "Logging Requirement for Continuous Auditing of Responsible Machine Learning-based Applications", "comment": null, "summary": "Machine learning (ML) is increasingly applied across industries to automate\ndecision-making, but concerns about ethical and legal compliance remain due to\nlimited transparency, fairness, and accountability. Monitoring through logging\na long-standing practice in traditional software offers a potential means for\nauditing ML applications, as logs provide traceable records of system behavior\nuseful for debugging, performance analysis, and continuous auditing.\nsystematically auditing models for compliance or accountability. The findings\nunderscore the need for enhanced logging practices and tooling that\nsystematically integrate responsible AI metrics. Such practices would support\nthe development of auditable, transparent, and ethically responsible ML\nsystems, aligning with growing regulatory requirements and societal\nexpectations. By highlighting specific deficiencies and opportunities, this\nwork provides actionable guidance for both practitioners and tool developers\nseeking to strengthen the accountability and trustworthiness of ML\napplications."}
{"id": "2508.17882", "categories": ["cs.SE", "cs.SC", "cs.SY", "eess.SY"], "pdf": "https://arxiv.org/pdf/2508.17882", "abs": "https://arxiv.org/abs/2508.17882", "authors": ["Izudin Dzafic", "Rabih A. Jabr"], "title": "modelSolver: A Symbolic Model-Driven Solver for Power Network Simulation and Monitoring", "comment": null, "summary": "The development of advanced software tools for power system analysis requires\nextensive programming expertise. Even when using open-source tools, programming\nskills are essential to modify built-in models. This can be particularly\nchallenging for domain experts who lack coding proficiency. This paper\nintroduces modelSolver, a software solution with a new framework centered\naround symbolic mathematical modeling. The proposed paradigm facilitates\ndefining models through intuitive mathematical expressions, thus eliminating\nthe need for traditional programming constructs such as arrays, loops, and\nsparse matrix computations. The modelSolver focuses on power flow and state\nestimation using an open-box approach, which allows users to specify custom\nmodels using either real or complex variables. Unlike existing tools that rely\non hard-coded models, modelSolver enables the representation of a wide range of\nadvanced functionalities, including power flow with voltage regulators and load\ntap changers, continuation power flow, and Gauss-Newton state estimation with\nequality constraints. Compatibility with MATPOWER is ensured via a converter\nthat automates importing data files. The framework prioritizes model-driven\ndevelopment and empowers domain experts to focus on power system modeling\nwithout programming barriers. It aims to simplify power system computations,\nmaking them more accessible to students, scientists, and practitioners."}
{"id": "2508.17900", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2508.17900", "abs": "https://arxiv.org/abs/2508.17900", "authors": ["Mohammed O. Alannsary"], "title": "A Defect Classification Framework for AI-Based Software Systems (AI-ODC)", "comment": "Article, 19 pages, 6 figures, 8 tables,", "summary": "Artificial Intelligence has gained a lot of attention recently, it has been\nutilized in several fields ranging from daily life activities, such as\nresponding to emails and scheduling appointments, to manufacturing and\nautomating work activities. Artificial Intelligence systems are mainly\nimplemented as software solutions, and it is essential to discover and remove\nsoftware defects to assure its quality using defect analysis which is one of\nthe major activities that contribute to software quality. Despite the\nproliferation of AI-based systems, current defect analysis models fail to\ncapture their unique attributes. This paper proposes a framework inspired by\nthe Orthogonal Defect Classification (ODC) paradigm and enables defect analysis\nof Artificial Intelligence systems while recognizing its special attributes and\ncharacteristics. This study demonstrated the feasibility of modifying ODC for\nAI systems to classify its defects. The ODC was adjusted to accommodate the\nData, Learning, and Thinking aspects of AI systems which are newly introduced\nclassification dimensions. This adjustment involved the introduction of an\nadditional attribute to the ODC attributes, the incorporation of a new severity\nlevel, and the substitution of impact areas with characteristics pertinent to\nAI systems. The framework was showcased by applying it to a publicly available\nMachine Learning bug dataset, with results analyzed through one-way and two-way\nanalysis. The case study indicated that defects occurring during the Learning\nphase were the most prevalent and were significantly linked to high-severity\nclassifications. In contrast, defects identified in the Thinking phase had a\ndisproportionate effect on trustworthiness and accuracy. These findings\nillustrate AIODC's capability to identify high-risk defect categories and\ninform focused quality assurance measures."}
{"id": "2508.17912", "categories": ["cs.SE", "cs.HC"], "pdf": "https://arxiv.org/pdf/2508.17912", "abs": "https://arxiv.org/abs/2508.17912", "authors": ["Mohammed O. Alannsary"], "title": "Evaluating Citizen Satisfaction with Saudi Arabia's E-Government Services: A Standards-Based, Theory-Informed Approach", "comment": "38 pages, 1 figure, 16 tables, journal research paper", "summary": "As digital government platforms become central to public service delivery,\nunderstanding citizen assessment is crucial for enhancing usability, trust, and\ninclusivity. This study investigates citizen satisfaction with the e-government\nservices in Saudi Arabia through a quality-in-use framework based on ISO/IEC\n25010 and ISO/IEC 25022 standards, interpreted through the lens of the Unified\nTheory of Acceptance and Use of Technology (UTAUT). A structured questionnaire\nwas administered to 500 citizens, yielding 276 valid responses. Satisfaction\nwas evaluated across four dimensions: overall satisfaction, feature\nsatisfaction, trust, and emotional engagement (pleasure). The findings\ndemonstrate consistently high levels of satisfaction regarding usability and\ntrust, aligning with Saudi Arabia's top-tier global ranking in e-government\ndevelopment. However, the results also highlight persistent challenges related\nto service clarity and system responsiveness. Emotional engagement was limited,\nindicating that users perceive these services primarily as functional tools\nrather than as engaging digital experiences. The study offers valuable insights\nfor policymakers and contributes to the theoretical integration of\nstandards-based and behavioral adoption models in the context of citizenship."}
{"id": "2508.17988", "categories": ["cs.SE", "cs.LG"], "pdf": "https://arxiv.org/pdf/2508.17988", "abs": "https://arxiv.org/abs/2508.17988", "authors": ["Eduardo de Conto", "Blaise Genest", "Arvind Easwaran", "Nicholas Ng", "Shweta Menon"], "title": "DesCartes Builder: A Tool to Develop Machine-Learning Based Digital Twins", "comment": "5 pages, 4 figures. Accepted at EDTconf 2025", "summary": "Digital twins (DTs) are increasingly utilized to monitor, manage, and\noptimize complex systems across various domains, including civil engineering. A\ncore requirement for an effective DT is to act as a fast, accurate, and\nmaintainable surrogate of its physical counterpart, the physical twin (PT). To\nthis end, machine learning (ML) is frequently employed to (i) construct\nreal-time DT prototypes using efficient reduced-order models (ROMs) derived\nfrom high-fidelity simulations of the PT's nominal behavior, and (ii)\nspecialize these prototypes into DT instances by leveraging historical sensor\ndata from the target PT. Despite the broad applicability of ML, its use in DT\nengineering remains largely ad hoc. Indeed, while conventional ML pipelines\noften train a single model for a specific task, DTs typically require multiple,\ntask- and domain-dependent models. Thus, a more structured approach is required\nto design DTs.\n  In this paper, we introduce DesCartes Builder, an open-source tool to enable\nthe systematic engineering of ML-based pipelines for real-time DT prototypes\nand DT instances. The tool leverages an open and flexible visual data flow\nparadigm to facilitate the specification, composition, and reuse of ML models.\nIt also integrates a library of parameterizable core operations and ML\nalgorithms tailored for DT design. We demonstrate the effectiveness and\nusability of DesCartes Builder through a civil engineering use case involving\nthe design of a real-time DT prototype to predict the plastic strain of a\nstructure."}
{"id": "2508.18003", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2508.18003", "abs": "https://arxiv.org/abs/2508.18003", "authors": ["Robert Heumüller", "Frank Ortmeier"], "title": "Previously on... Automating Code Review", "comment": "Preprint currently under review", "summary": "Modern Code Review (MCR) is a standard practice in software engineering, yet\nit demands substantial time and resource investments. Recent research has\nincreasingly explored automating core review tasks using machine learning (ML)\nand deep learning (DL). As a result, there is substantial variability in task\ndefinitions, datasets, and evaluation procedures. This study provides the first\ncomprehensive analysis of MCR automation research, aiming to characterize the\nfield's evolution, formalize learning tasks, highlight methodological\nchallenges, and offer actionable recommendations to guide future research.\nFocusing on the primary code review tasks, we systematically surveyed 691\npublications and identified 24 relevant studies published between May 2015 and\nApril 2024. Each study was analyzed in terms of tasks, models, metrics,\nbaselines, results, validity concerns, and artifact availability. In\nparticular, our analysis reveals significant potential for standardization,\nincluding 48 task metric combinations, 22 of which were unique to their\noriginal paper, and limited dataset reuse. We highlight challenges and derive\nconcrete recommendations for examples such as the temporal bias threat, which\nare rarely addressed so far. Our work contributes to a clearer overview of the\nfield, supports the framing of new research, helps to avoid pitfalls, and\npromotes greater standardization in evaluation practices."}
{"id": "2508.18070", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2508.18070", "abs": "https://arxiv.org/abs/2508.18070", "authors": ["Karolina M. Milano", "Wesley K. G. Assunção", "Bruno B. P. Cafeo"], "title": "A Large-Scale Study on Developer Engagement and Expertise in Configurable Software System Projects", "comment": null, "summary": "Modern systems operate in multiple contexts making variability a fundamental\naspect of Configurable Software Systems (CSSs). Variability, implemented via\npre-processor directives (e.g., #ifdef blocks) interleaved with other code and\nspread across files, complicates maintenance and increases error risk. Despite\nits importance, little is known about how variable code is distributed among\ndevelopers or whether conventional expertise metrics adequately capture\nvariable code proficiency. This study investigates developers' engagement with\nvariable versus mandatory code, the concentration of variable code workload,\nand the effectiveness of expertise metrics in CSS projects. We mined\nrepositories of 25 CSS projects, analyzing 450,255 commits from 9,678\ndevelopers. Results show that 59% of developers never modified variable code,\nwhile about 17% were responsible for developing and maintaining 83% of it. This\nindicates a high concentration of variable code expertise among a few\ndevelopers, suggesting that task assignments should prioritize these\nspecialists. Moreover, conventional expertise metrics performed\npoorly--achieving only around 55% precision and 50% recall in identifying\ndevelopers engaged with variable code. Our findings highlight an unbalanced\ndistribution of variable code responsibilities and underscore the need to\nrefine expertise metrics to better support task assignments in CSS projects,\nthereby promoting a more equitable workload distribution."}
{"id": "2508.18073", "categories": ["cs.SE", "cs.DL"], "pdf": "https://arxiv.org/pdf/2508.18073", "abs": "https://arxiv.org/abs/2508.18073", "authors": ["Joenio Marques da Costa", "Christina von Flach"], "title": "Debian in the Research Software Ecosystem: A Bibliometric Analysis", "comment": "5 pages; 3 figures; 2 tables; to be published in DebConf25 Academic\n  Track https://www.diverse-team.fr/debconf25-academictrack", "summary": "Context: The Debian system has historically participated in academic works\nand scientific projects, with well-known examples including NeuroDebian, Debian\nMed, Debsources, Debian Science, and Debian GIS, where the scientific relevance\nof Debian and its contribution to the Research Software ecosystem are evident.\n  Objective: The objective of this study is to investigate the Debian system\nthrough academic publications, with the aim of classifying articles, mapping\nresearch, identifying trends, and finding opportunities.\n  Method: The study is based on a bibliometric analysis starting with an\ninitial search for the term \"Debian\" in the titles, abstracts, or keywords of\nacademic publications, using the Scopus database. This analysis calculates\nmetrics of co-citation, co-authorship, and word co-occurrence, and is guided by\na set of research questions and criteria for inclusion and exclusion to conduct\nthe bibliometric analysis.\n  Results: The study includes a set of articles published across various fields\nof knowledge, providing a map of the academic publication space about Debian.\nThe study's data will be available in a public repository, reporting\ndemographic and bibliometric trends, including the most cited articles, active\ncountries, researchers, and popular conferences.\n  Conclusion: Results includes a bibliometric and demographic analysis\nidentified in publications about Debian, shedding light on the intellectual\nstructure of academic research. The results of the analyses can help\nresearchers gain an overview of existing trends in publications about Debian\nand identify areas that require more attention from the scientific community."}
{"id": "2508.18089", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2508.18089", "abs": "https://arxiv.org/abs/2508.18089", "authors": ["Karine Even-Mendoza", "Alexander Brownlee", "Alina Geiger", "Carol Hanna", "Justyna Petke", "Federica Sarro", "Dominik Sobania"], "title": "LLM-Guided Genetic Improvement: Envisioning Semantic Aware Automated Software Evolution", "comment": null, "summary": "Genetic Improvement (GI) of software automatically creates alternative\nsoftware versions that are improved according to certain properties of\ninterests (e.g., running-time). Search-based GI excels at navigating large\nprogram spaces, but operates primarily at the syntactic level. In contrast,\nLarge Language Models (LLMs) offer semantic-aware edits, yet lack goal-directed\nfeedback and control (which is instead a strength of GI). As such, we propose\nthe investigation of a new research line on AI-powered GI aimed at\nincorporating semantic aware search. We take a first step at it by augmenting\nGI with the use of automated clustering of LLM edits. We provide initial\nempirical evidence that our proposal, dubbed PatchCat, allows us to\nautomatically and effectively categorize LLM-suggested patches. PatchCat\nidentified 18 different types of software patches and categorized newly\nsuggested patches with high accuracy. It also enabled detecting NoOp edits in\nadvance and, prospectively, to skip test suite execution to save resources in\nmany cases. These results, coupled with the fact that PatchCat works with\nsmall, local LLMs, are a promising step toward interpretable, efficient, and\ngreen GI. We outline a rich agenda of future work and call for the community to\njoin our vision of building a principled understanding of LLM-driven mutations,\nguiding the GI search process with semantic signals."}
{"id": "2508.18106", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2508.18106", "abs": "https://arxiv.org/abs/2508.18106", "authors": ["Keke Lian", "Bin Wang", "Lei Zhang", "Libo Chen", "Junjie Wang", "Ziming Zhao", "Yujiu Yang", "Haotong Duan", "Haoran Zhao", "Shuang Liao", "Mingda Guo", "Jiazheng Quan", "Yilu Zhong", "Chenhao He", "Zichuan Chen", "Jie Wu", "Haoling Li", "Zhaoxuan Li", "Jiongchi Yu", "Hui Li", "Dong Zhang"], "title": "A.S.E: A Repository-Level Benchmark for Evaluating Security in AI-Generated Code", "comment": null, "summary": "The increasing adoption of large language models (LLMs) in software\nengineering necessitates rigorous security evaluation of their generated code.\nHowever, existing benchmarks are inadequate, as they focus on isolated code\nsnippets, employ unstable evaluation methods that lack reproducibility, and\nfail to connect the quality of input context with the security of the output.\nTo address these gaps, we introduce A.S.E (AI Code Generation Security\nEvaluation), a benchmark for repository-level secure code generation. A.S.E\nconstructs tasks from real-world repositories with documented CVEs, preserving\nfull repository context like build systems and cross-file dependencies. Its\nreproducible, containerized evaluation framework uses expert-defined rules to\nprovide stable, auditable assessments of security, build quality, and\ngeneration stability. Our evaluation of leading LLMs on A.S.E reveals three key\nfindings: (1) Claude-3.7-Sonnet achieves the best overall performance. (2) The\nsecurity gap between proprietary and open-source models is narrow;\nQwen3-235B-A22B-Instruct attains the top security score. (3) Concise,\n``fast-thinking'' decoding strategies consistently outperform complex,\n``slow-thinking'' reasoning for security patching."}
{"id": "2508.16782", "categories": ["cs.LO", "cs.SE", "68N17 (Primary) 68N30, 68Q60 (Secondary)", "D.1.6; D.2.3; F.3.1"], "pdf": "https://arxiv.org/pdf/2508.16782", "abs": "https://arxiv.org/abs/2508.16782", "authors": ["Włodzimierz Drabent"], "title": "On systematic construction of correct logic programs", "comment": "21 pages. Accepted for ICLP 2025 (The 41st International Conference\n  on Logic Programming)", "summary": "Partial correctness of imperative or functional programming divides in logic\nprogramming into two notions. Correctness means that all answers of the program\nare compatible with the specification. Completeness means that the program\nproduces all the answers required by the specifications. We also consider\nsemi-completeness -- completeness for those queries for which the program does\nnot diverge. This paper presents an approach to systematically construct\nprovably correct and semi-complete logic programs, for a given specification.\nNormal programs are considered, under Kunen's 3-valued completion semantics (of\nnegation as finite failure) and the well-founded semantics (of negation as\npossibly infinite failure). The approach is declarative, it abstracts from\ndetails of operational semantics, like e.g.\\ the form of the selected literals\n(``procedure calls'') during the computation. The proposed method is simple,\nand can be used (maybe informally) in actual everyday programming."}

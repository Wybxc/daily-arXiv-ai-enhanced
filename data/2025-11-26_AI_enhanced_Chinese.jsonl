{"id": "2511.19521", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2511.19521", "abs": "https://arxiv.org/abs/2511.19521", "authors": ["Tesla Zhang", "Asher Kornfeld", "Rui Li", "Sonya Simkin", "Yue Yao", "Stephanie Balzer"], "title": "Mechanizing a Proof-Relevant Logical Relation for Timed Message-Passing Protocols", "comment": "15 pages, 9 figures", "summary": "Semantic typing has become a powerful tool for program verification, applying the technique of logical relations as not only a proof method, but also a device for prescribing program behavior. In recent work, Yao et al. scaled semantic typing to the verification of timed message-passing protocols, which are prevalent in, e.g., IoT and real-time systems applications. The appeal of semantic typing in this context is precisely because of its ability to support typed and untyped program components alike -- including physical objects -- which caters to the heterogeneity of these applications. Another demand inherent to these applications is timing: constraining the time or time window within which a message exchange must happen. Yao et al. equipped their logical relation not only with temporal predicates, but also with computable trajectories, to supply the evidence that an inhabitant can step from one time point to another one. While Yao et al. provide the formalization for such a verification tool, it lacks a mechanization. Mechanizing the system would not only provide a machine proof for it, but also facilitate scalability for future extensions and applications.\n  This paper tackles the challenge of mechanizing the resulting proof-relevant logical relation in a proof assistant. allowing trajectories to be interleaved, partitioned, and concatenated, while the intended equality on trajectories is the equality of their graphs when seen as processes indexed by time. Unfortunately, proof assistants based on intensional type theory only have modest support for such equations, forcing a prolific use of transports. This paper reports on the process of mechanizing Yao et al.'s results, comprising the logical relation, the algebra of computable trajectories with supporting lemmas, and the fundamental theorem of the logical relation, in the Rocq theorem prover.", "AI": {"tldr": "\u672c\u6587\u5b9e\u73b0\u4e86Yao\u7b49\u4eba\u63d0\u51fa\u7684\u8bed\u4e49\u7c7b\u578b\u7cfb\u7edf\u5728Rocq\u5b9a\u7406\u8bc1\u660e\u5668\u4e2d\u7684\u673a\u68b0\u5316\uff0c\u5305\u62ec\u903b\u8f91\u5173\u7cfb\u3001\u53ef\u8ba1\u7b97\u8f68\u8ff9\u7684\u4ee3\u6570\u548c\u57fa\u672c\u5b9a\u7406\u3002", "motivation": "\u8bed\u4e49\u7c7b\u578b\u5316\u5728\u7a0b\u5e8f\u9a8c\u8bc1\u4e2d\u5f88\u5f3a\u5927\uff0c\u4f46Yao\u7b49\u4eba\u5173\u4e8e\u5b9a\u65f6\u6d88\u606f\u4f20\u9012\u534f\u8bae\u7684\u9a8c\u8bc1\u7cfb\u7edf\u7f3a\u4e4f\u673a\u68b0\u5316\u5b9e\u73b0\u3002\u673a\u68b0\u5316\u4e0d\u4ec5\u80fd\u63d0\u4f9b\u673a\u5668\u8bc1\u660e\uff0c\u8fd8\u80fd\u4fc3\u8fdb\u672a\u6765\u6269\u5c55\u548c\u5e94\u7528\u7684\u53ef\u6269\u5c55\u6027\u3002", "method": "\u5728Rocq\u5b9a\u7406\u8bc1\u660e\u5668\u4e2d\u673a\u68b0\u5316Yao\u7b49\u4eba\u7684\u7ed3\u679c\uff0c\u5305\u62ec\u903b\u8f91\u5173\u7cfb\u3001\u53ef\u8ba1\u7b97\u8f68\u8ff9\u4ee3\u6570\u53ca\u5176\u652f\u6301\u5f15\u7406\uff0c\u4ee5\u53ca\u903b\u8f91\u5173\u7cfb\u7684\u57fa\u672c\u5b9a\u7406\u3002", "result": "\u6210\u529f\u5b9e\u73b0\u4e86\u8bed\u4e49\u7c7b\u578b\u7cfb\u7edf\u7684\u673a\u68b0\u5316\uff0c\u652f\u6301\u8f68\u8ff9\u7684\u4ea4\u9519\u3001\u5206\u533a\u548c\u8fde\u63a5\u64cd\u4f5c\uff0c\u5e76\u5728\u8bc1\u660e\u52a9\u624b\u4e2d\u5904\u7406\u4e86\u8f68\u8ff9\u56fe\u76f8\u7b49\u7684\u590d\u6742\u7b49\u5f0f\u95ee\u9898\u3002", "conclusion": "\u8fd9\u9879\u5de5\u4f5c\u4e3a\u5b9a\u65f6\u6d88\u606f\u4f20\u9012\u534f\u8bae\u7684\u8bed\u4e49\u7c7b\u578b\u9a8c\u8bc1\u63d0\u4f9b\u4e86\u673a\u68b0\u5316\u7684\u57fa\u7840\uff0c\u89e3\u51b3\u4e86\u5728\u5185\u6db5\u7c7b\u578b\u7406\u8bba\u8bc1\u660e\u52a9\u624b\u4e2d\u5904\u7406\u8f68\u8ff9\u7b49\u5f0f\u65f6\u9762\u4e34\u7684\u6311\u6218\u3002"}}
{"id": "2511.19764", "categories": ["cs.PL", "cs.AR", "cs.SE"], "pdf": "https://arxiv.org/pdf/2511.19764", "abs": "https://arxiv.org/abs/2511.19764", "authors": ["Ayaka Yorihiro", "Griffin Berlstein", "Pedro Pontes Garc\u00eda", "Kevin Laeufer", "Adrian Sampson"], "title": "Understanding Accelerator Compilers via Performance Profiling", "comment": null, "summary": "Accelerator design languages (ADLs), high-level languages that compile to hardware units, help domain experts quickly design efficient application-specific hardware. ADL compilers optimize datapaths and convert software-like control flow constructs into control paths. Such compilers are necessarily complex and often unpredictable: they must bridge the wide semantic gap between high-level semantics and cycle-level schedules, and they typically rely on advanced heuristics to optimize circuits. The resulting performance can be difficult to control, requiring guesswork to find and resolve performance problems in the generated hardware. We conjecture that ADL compilers will never be perfect: some performance unpredictability is endemic to the problem they solve.\n  In lieu of compiler perfection, we argue for compiler understanding tools that give ADL programmers insight into how the compiler's decisions affect performance. We introduce Petal, a cycle-level Petal for the Calyx intermediate language (IL). Petal instruments the Calyx code with probes and then analyzes the trace from a register-transfer-level simulation. It maps the events in the trace back to high-level control constructs in the Calyx code to track the clock cycles when each construct was active. Using case studies, we demonstrate that Petal's cycle-level profiles can identify performance problems in existing accelerator designs. We show that these insights can also guide developers toward optimizations that the compiler was unable to perform automatically, including a reduction by 46.9\\% of total cycles for one application.", "AI": {"tldr": "Petal\u662f\u4e00\u4e2a\u9488\u5bf9Calyx\u4e2d\u95f4\u8bed\u8a00\u7684\u5468\u671f\u7ea7\u5206\u6790\u5de5\u5177\uff0c\u901a\u8fc7\u63a2\u6d4b\u548c\u8ddf\u8e2a\u5206\u6790\u6765\u5e2e\u52a9\u52a0\u901f\u5668\u8bbe\u8ba1\u8005\u7406\u89e3\u7f16\u8bd1\u5668\u51b3\u7b56\u5bf9\u6027\u80fd\u7684\u5f71\u54cd\u3002", "motivation": "\u52a0\u901f\u5668\u8bbe\u8ba1\u8bed\u8a00(ADL)\u7f16\u8bd1\u5668\u5b58\u5728\u6027\u80fd\u4e0d\u53ef\u9884\u6d4b\u6027\uff0c\u9700\u8981\u5de5\u5177\u6765\u5e2e\u52a9\u7a0b\u5e8f\u5458\u7406\u89e3\u7f16\u8bd1\u5668\u51b3\u7b56\u5982\u4f55\u5f71\u54cd\u6027\u80fd\u3002", "method": "Petal\u5728Calyx\u4ee3\u7801\u4e2d\u63d2\u5165\u63a2\u9488\uff0c\u5206\u6790\u5bc4\u5b58\u5668\u4f20\u8f93\u7ea7\u4eff\u771f\u7684\u8ddf\u8e2a\u6570\u636e\uff0c\u5c06\u8ddf\u8e2a\u4e8b\u4ef6\u6620\u5c04\u56de\u9ad8\u7ea7\u63a7\u5236\u7ed3\u6784\u6765\u8ddf\u8e2a\u6bcf\u4e2a\u7ed3\u6784\u6d3b\u8dc3\u7684\u65f6\u949f\u5468\u671f\u3002", "result": "\u6848\u4f8b\u7814\u7a76\u8868\u660ePetal\u80fd\u591f\u8bc6\u522b\u73b0\u6709\u52a0\u901f\u5668\u8bbe\u8ba1\u4e2d\u7684\u6027\u80fd\u95ee\u9898\uff0c\u5e76\u6307\u5bfc\u5f00\u53d1\u8005\u8fdb\u884c\u7f16\u8bd1\u5668\u65e0\u6cd5\u81ea\u52a8\u6267\u884c\u7684\u4f18\u5316\uff0c\u5176\u4e2d\u4e00\u4e2a\u5e94\u7528\u7684\u603b\u5468\u671f\u6570\u51cf\u5c11\u4e8646.9%\u3002", "conclusion": "Petal\u4e3aADL\u7a0b\u5e8f\u5458\u63d0\u4f9b\u4e86\u7406\u89e3\u7f16\u8bd1\u5668\u51b3\u7b56\u5bf9\u6027\u80fd\u5f71\u54cd\u7684\u5de5\u5177\uff0c\u5f25\u8865\u4e86\u7f16\u8bd1\u5668\u4e0d\u5b8c\u7f8e\u5e26\u6765\u7684\u6027\u80fd\u4e0d\u53ef\u9884\u6d4b\u6027\u95ee\u9898\u3002"}}
{"id": "2511.20369", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2511.20369", "abs": "https://arxiv.org/abs/2511.20369", "authors": ["Frank Sch\u00fcssele", "Matthias Zumkeller", "Miriam Lagunes-Rochin", "Dominik Klumpp"], "title": "The Ghosts of Empires: Extracting Modularity from Interleaving-Based Proofs (Extended Version)", "comment": "39 pages, 10 figures, 1 table. Extended version with proofs of the paper published at POPL'2026 (https://doi.org/10.1145/3776684)", "summary": "Implementation bugs threaten the soundness of algorithmic software verifiers. Generating correctness certificates for correct programs allows for efficient independent validation of verification results, and thus helps to reveal such bugs. Automatic generation of small, compact correctness proofs for concurrent programs is challenging, as the correctness arguments may depend on the particular interleaving, which can lead to exponential explosion. We present an approach that converts an interleaving-based correctness proof, as generated by many algorithmic verifiers, into a thread-modular correctness proof in the style of Owicki and Gries. We automatically synthesize ghost variables that capture the relevant interleaving information, and abstract away irrelevant details. Our evaluation shows that the approach is efficient in practice and generates compact proofs, compared to a baseline.", "AI": {"tldr": "\u5c06\u57fa\u4e8e\u4ea4\u9519\u6267\u884c\u7684\u6b63\u786e\u6027\u8bc1\u660e\u8f6c\u6362\u4e3a\u7ebf\u7a0b\u6a21\u5757\u5316\u8bc1\u660e\uff0c\u901a\u8fc7\u81ea\u52a8\u5408\u6210\u5e7d\u7075\u53d8\u91cf\u6765\u6355\u83b7\u76f8\u5173\u4ea4\u9519\u4fe1\u606f\uff0c\u751f\u6210\u7d27\u51d1\u7684\u6b63\u786e\u6027\u8bc1\u4e66", "motivation": "\u7b97\u6cd5\u8f6f\u4ef6\u9a8c\u8bc1\u5668\u4e2d\u7684\u5b9e\u73b0\u9519\u8bef\u5a01\u80c1\u5176\u53ef\u9760\u6027\uff0c\u4e3a\u6b63\u786e\u7a0b\u5e8f\u751f\u6210\u6b63\u786e\u6027\u8bc1\u4e66\u53ef\u4ee5\u72ec\u7acb\u9a8c\u8bc1\u7ed3\u679c\uff0c\u4f46\u5e76\u53d1\u7a0b\u5e8f\u7684\u6b63\u786e\u6027\u8bc1\u660e\u9762\u4e34\u6307\u6570\u7206\u70b8\u95ee\u9898", "method": "\u5c06\u57fa\u4e8e\u4ea4\u9519\u6267\u884c\u7684\u6b63\u786e\u6027\u8bc1\u660e\u8f6c\u6362\u4e3aOwicki-Gries\u98ce\u683c\u7684\u7ebf\u7a0b\u6a21\u5757\u5316\u8bc1\u660e\uff0c\u81ea\u52a8\u5408\u6210\u5e7d\u7075\u53d8\u91cf\u6765\u6355\u83b7\u76f8\u5173\u4ea4\u9519\u4fe1\u606f\uff0c\u62bd\u8c61\u6389\u65e0\u5173\u7ec6\u8282", "result": "\u8bc4\u4f30\u8868\u660e\u8be5\u65b9\u6cd5\u5728\u5b9e\u8df5\u4e2d\u9ad8\u6548\uff0c\u76f8\u6bd4\u57fa\u7ebf\u751f\u6210\u66f4\u7d27\u51d1\u7684\u8bc1\u660e", "conclusion": "\u63d0\u51fa\u7684\u65b9\u6cd5\u80fd\u591f\u9ad8\u6548\u751f\u6210\u5e76\u53d1\u7a0b\u5e8f\u7684\u7d27\u51d1\u6b63\u786e\u6027\u8bc1\u4e66\uff0c\u6709\u52a9\u4e8e\u9a8c\u8bc1\u9a8c\u8bc1\u5668\u7684\u53ef\u9760\u6027"}}
{"id": "2511.20193", "categories": ["cs.LO", "cs.PL"], "pdf": "https://arxiv.org/pdf/2511.20193", "abs": "https://arxiv.org/abs/2511.20193", "authors": ["Neta Elad", "Adithya Murali", "Sharon Shoham"], "title": "Separating the Wheat from the Chaff: Understanding (In-)Completeness of Proof Mechanisms for Separation Logic with Inductive Definitions", "comment": null, "summary": "For over two decades Separation Logic has been arguably the most popular framework for reasoning about heap-manipulating programs, as well as reasoning about shared resources and permissions. Separation Logic is often extended to include inductively-defined predicates, interpreted as least fixpoints, forming Separation Logic with Inductive Definitions (SLID). Many theoretical and practical advances have been made in developing automated proof mechanisms for SLID, but these mechanisms are imperfect, and a deeper understanding of their failures is desired. As expressive as Separation Logic is, it is not surprising that it is incomplete, and in fact, it contains several sources of incompleteness that defy automated reasoning.\n  In this paper we study these sources of incompleteness and how they relate to failures of proof mechanisms. We place SLID within a larger logic, that we call Weak Separation Logic (WSL). We prove that unlike SLID, WSL is complete for a non-trivial fragment of quantified entailments with background theories and inductive definitions, via a reduction to first-order logic (FOL). Moreover, we show that the ubiquitous fold/unfold proof mechanism is sound and complete for theory-free, quantifier-free WSL entailments with inductive definitions. Through this, we understand proof failures as stemming from nonstandard models present in WSL, but not allowed in SLID. These rogue models are typically infinite, and we use the formalism of symbolic structures to represent and automatically find them.\n  We present a prototype tool that implements the FOL encoding of WSL and test it on an existing benchmark, which contains over 700 quantified entailment problems with inductive definitions. Our tool is able to find counter-models to many of the examples, and we provide a partial taxonomy of the rogue models, shedding some light on real-world proof failures.", "AI": {"tldr": "\u672c\u6587\u7814\u7a76\u4e86\u5206\u79bb\u903b\u8f91\u4e0e\u5f52\u7eb3\u5b9a\u4e49(SLID)\u7684\u4e0d\u5b8c\u5907\u6027\uff0c\u63d0\u51fa\u4e86\u5f31\u5206\u79bb\u903b\u8f91(WSL)\u4f5c\u4e3a\u66f4\u5b8c\u6574\u7684\u6846\u67b6\uff0c\u8bc1\u660e\u4e86WSL\u5728\u91cf\u5316\u8574\u542b\u95ee\u9898\u4e0a\u7684\u5b8c\u5907\u6027\uff0c\u5e76\u5f00\u53d1\u4e86\u5de5\u5177\u6765\u53d1\u73b0\u53cd\u4f8b\u6a21\u578b\u3002", "motivation": "\u5206\u79bb\u903b\u8f91\u867d\u7136\u6d41\u884c\u4f46\u5b58\u5728\u4e0d\u5b8c\u5907\u6027\uff0c\u7279\u522b\u662f\u5728\u81ea\u52a8\u8bc1\u660e\u673a\u5236\u4e2d\u7ecf\u5e38\u5931\u8d25\u3002\u9700\u8981\u6df1\u5165\u7406\u89e3\u8fd9\u4e9b\u5931\u8d25\u7684\u539f\u56e0\uff0c\u5e76\u5efa\u7acb\u66f4\u5b8c\u6574\u7684\u903b\u8f91\u6846\u67b6\u3002", "method": "\u63d0\u51fa\u5f31\u5206\u79bb\u903b\u8f91(WSL)\u4f5c\u4e3aSLID\u7684\u6269\u5c55\uff0c\u901a\u8fc7\u5f52\u7ea6\u5230\u4e00\u9636\u903b\u8f91\u8bc1\u660eWSL\u7684\u5b8c\u5907\u6027\uff0c\u4f7f\u7528\u7b26\u53f7\u7ed3\u6784\u8868\u793a\u548c\u53d1\u73b0\u975e\u6807\u51c6\u6a21\u578b\uff0c\u5e76\u5f00\u53d1\u539f\u578b\u5de5\u5177\u5b9e\u73b0FOL\u7f16\u7801\u3002", "result": "\u8bc1\u660e\u4e86WSL\u5728\u91cf\u5316\u8574\u542b\u95ee\u9898\u4e0a\u7684\u5b8c\u5907\u6027\uff0c\u5de5\u5177\u5728700\u591a\u4e2a\u95ee\u9898\u4e0a\u6210\u529f\u627e\u5230\u53cd\u4f8b\u6a21\u578b\uff0c\u63ed\u793a\u4e86\u73b0\u5b9e\u4e16\u754c\u8bc1\u660e\u5931\u8d25\u7684\u539f\u56e0\u3002", "conclusion": "WSL\u6bd4SLID\u66f4\u5b8c\u6574\uff0c\u975e\u6807\u51c6\u6a21\u578b\u662f\u8bc1\u660e\u5931\u8d25\u7684\u4e3b\u8981\u539f\u56e0\uff0c\u901a\u8fc7\u7b26\u53f7\u7ed3\u6784\u53ef\u4ee5\u81ea\u52a8\u53d1\u73b0\u8fd9\u4e9b\u53cd\u4f8b\u6a21\u578b\uff0c\u4e3a\u6539\u8fdb\u81ea\u52a8\u8bc1\u660e\u673a\u5236\u63d0\u4f9b\u4e86\u7406\u8bba\u57fa\u7840\u3002"}}
{"id": "2511.20038", "categories": ["cs.FL", "cs.LG", "cs.LO"], "pdf": "https://arxiv.org/pdf/2511.20038", "abs": "https://arxiv.org/abs/2511.20038", "authors": ["Hongjian Jiang", "Michael Hahn", "Georg Zetzsche", "Anthony Widjaja Lin"], "title": "Softmax Transformers are Turing-Complete", "comment": null, "summary": "Hard attention Chain-of-Thought (CoT) transformers are known to be Turing-complete. However, it is an open problem whether softmax attention Chain-of-Thought (CoT) transformers are Turing-complete. In this paper, we prove a stronger result that length-generalizable softmax CoT transformers are Turing-complete. More precisely, our Turing-completeness proof goes via the CoT extension of the Counting RASP (C-RASP), which correspond to softmax CoT transformers that admit length generalization. We prove Turing-completeness for CoT C-RASP with causal masking over a unary alphabet (more generally, for letter-bounded languages). While we show this is not Turing-complete for arbitrary languages, we prove that its extension with relative positional encoding is Turing-complete for arbitrary languages. We empirically validate our theory by training transformers for languages requiring complex (non-linear) arithmetic reasoning.", "AI": {"tldr": "\u672c\u6587\u8bc1\u660e\u4e86\u957f\u5ea6\u53ef\u6cdb\u5316\u7684softmax\u6ce8\u610f\u529b\u94fe\u5f0f\u601d\u7ef4\uff08CoT\uff09\u53d8\u6362\u5668\u662f\u56fe\u7075\u5b8c\u5907\u7684\uff0c\u901a\u8fc7\u6269\u5c55\u8ba1\u6570RASP\uff08C-RASP\uff09\u6a21\u578b\u5b9e\u73b0\uff0c\u5e76\u5728\u5355\u5b57\u6bcd\u8868\u548c\u5b57\u6bcd\u6709\u754c\u8bed\u8a00\u4e0a\u9a8c\u8bc1\u4e86\u56fe\u7075\u5b8c\u5907\u6027\u3002", "motivation": "\u89e3\u51b3\u8f6f\u6ce8\u610f\u529b\u94fe\u5f0f\u601d\u7ef4\u53d8\u6362\u5668\u662f\u5426\u56fe\u7075\u5b8c\u5907\u7684\u5f00\u653e\u6027\u95ee\u9898\uff0c\u7279\u522b\u5173\u6ce8\u957f\u5ea6\u53ef\u6cdb\u5316\u7684\u60c5\u51b5\u3002", "method": "\u901a\u8fc7\u94fe\u5f0f\u601d\u7ef4\u6269\u5c55\u7684\u8ba1\u6570RASP\uff08CoT C-RASP\uff09\u6a21\u578b\uff0c\u7ed3\u5408\u56e0\u679c\u63a9\u7801\u548c\u76f8\u5bf9\u4f4d\u7f6e\u7f16\u7801\uff0c\u8bc1\u660e\u5176\u5728\u7279\u5b9a\u8bed\u8a00\u4e0a\u7684\u56fe\u7075\u5b8c\u5907\u6027\u3002", "result": "\u8bc1\u660e\u4e86CoT C-RASP\u5728\u5355\u5b57\u6bcd\u8868\u548c\u5b57\u6bcd\u6709\u754c\u8bed\u8a00\u4e0a\u662f\u56fe\u7075\u5b8c\u5907\u7684\uff0c\u4e14\u901a\u8fc7\u76f8\u5bf9\u4f4d\u7f6e\u7f16\u7801\u6269\u5c55\u540e\u53ef\u5728\u4efb\u610f\u8bed\u8a00\u4e0a\u5b9e\u73b0\u56fe\u7075\u5b8c\u5907\u6027\u3002", "conclusion": "\u957f\u5ea6\u53ef\u6cdb\u5316\u7684softmax\u6ce8\u610f\u529bCoT\u53d8\u6362\u5668\u662f\u56fe\u7075\u5b8c\u5907\u7684\uff0c\u8fd9\u4e3a\u590d\u6742\u7b97\u672f\u63a8\u7406\u4efb\u52a1\u63d0\u4f9b\u4e86\u7406\u8bba\u57fa\u7840\uff0c\u5e76\u901a\u8fc7\u5b9e\u9a8c\u9a8c\u8bc1\u4e86\u5176\u6709\u6548\u6027\u3002"}}
{"id": "2511.19477", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2511.19477", "abs": "https://arxiv.org/abs/2511.19477", "authors": ["Aram Vardanyan"], "title": "Building Browser Agents: Architecture, Security, and Practical Solutions", "comment": "30 pages, 22 figures. Production architecture and benchmark evaluation of browser agents", "summary": "Browser agents enable autonomous web interaction but face critical reliability and security challenges in production. This paper presents findings from building and operating a production browser agent. The analysis examines where current approaches fail and what prevents safe autonomous operation. The fundamental insight: model capability does not limit agent performance; architectural decisions determine success or failure. Security analysis of real-world incidents reveals prompt injection attacks make general-purpose autonomous operation fundamentally unsafe. The paper argues against developing general browsing intelligence in favor of specialized tools with programmatic constraints, where safety boundaries are enforced through code instead of large language model (LLM) reasoning. Through hybrid context management combining accessibility tree snapshots with selective vision, comprehensive browser tooling matching human interaction capabilities, and intelligent prompt engineering, the agent achieved approximately 85% success rate on the WebGames benchmark across 53 diverse challenges (compared to approximately 50% reported for prior browser agents and 95.7% human baseline).", "AI": {"tldr": "\u751f\u4ea7\u7ea7\u6d4f\u89c8\u5668\u4ee3\u7406\u9762\u4e34\u53ef\u9760\u6027\u548c\u5b89\u5168\u6311\u6218\uff0c\u7814\u7a76\u53d1\u73b0\u6a21\u578b\u80fd\u529b\u4e0d\u662f\u9650\u5236\u56e0\u7d20\uff0c\u67b6\u6784\u51b3\u7b56\u51b3\u5b9a\u6210\u8d25\u3002\u5b89\u5168\u5206\u6790\u663e\u793a\u63d0\u793a\u6ce8\u5165\u653b\u51fb\u4f7f\u901a\u7528\u81ea\u4e3b\u64cd\u4f5c\u4e0d\u5b89\u5168\uff0c\u5e94\u5f00\u53d1\u5177\u6709\u7a0b\u5e8f\u7ea6\u675f\u7684\u4e13\u7528\u5de5\u5177\u800c\u975e\u901a\u7528\u6d4f\u89c8\u667a\u80fd\u3002", "motivation": "\u89e3\u51b3\u6d4f\u89c8\u5668\u4ee3\u7406\u5728\u751f\u4ea7\u73af\u5883\u4e2d\u7684\u53ef\u9760\u6027\u548c\u5b89\u5168\u6027\u95ee\u9898\uff0c\u5206\u6790\u5f53\u524d\u65b9\u6cd5\u5931\u8d25\u7684\u539f\u56e0\u548c\u963b\u788d\u5b89\u5168\u81ea\u4e3b\u64cd\u4f5c\u7684\u56e0\u7d20\u3002", "method": "\u91c7\u7528\u6df7\u5408\u4e0a\u4e0b\u6587\u7ba1\u7406\uff08\u7ed3\u5408\u53ef\u8bbf\u95ee\u6027\u6811\u5feb\u7167\u548c\u9009\u62e9\u6027\u89c6\u89c9\uff09\u3001\u5168\u9762\u6d4f\u89c8\u5668\u5de5\u5177\u5339\u914d\u4eba\u7c7b\u4ea4\u4e92\u80fd\u529b\u3001\u667a\u80fd\u63d0\u793a\u5de5\u7a0b\u3002", "result": "\u5728WebGames\u57fa\u51c6\u6d4b\u8bd5\u768453\u4e2a\u591a\u6837\u5316\u6311\u6218\u4e2d\u8fbe\u5230\u7ea685%\u6210\u529f\u7387\uff0c\u4f18\u4e8e\u4e4b\u524d\u6d4f\u89c8\u5668\u4ee3\u7406\u7684\u7ea650%\uff0c\u63a5\u8fd1\u4eba\u7c7b\u57fa\u7ebf\u768495.7%\u3002", "conclusion": "\u53cd\u5bf9\u5f00\u53d1\u901a\u7528\u6d4f\u89c8\u667a\u80fd\uff0c\u4e3b\u5f20\u5f00\u53d1\u5177\u6709\u7a0b\u5e8f\u7ea6\u675f\u7684\u4e13\u7528\u5de5\u5177\uff0c\u901a\u8fc7\u4ee3\u7801\u800c\u975eLLM\u63a8\u7406\u6765\u5f3a\u5236\u6267\u884c\u5b89\u5168\u8fb9\u754c\u3002"}}
{"id": "2511.19565", "categories": ["cs.LO", "cs.AI"], "pdf": "https://arxiv.org/pdf/2511.19565", "abs": "https://arxiv.org/abs/2511.19565", "authors": ["Jorge Fandinno", "Vladimir Lifschitz"], "title": "Deductive Systems for Logic Programs with Counting", "comment": "Under consideration in Theory and Practice of Logic Programming (TPLP)", "summary": "In answer set programming, two groups of rules are considered strongly equivalent if they have the same meaning in any context. Strong equivalence of two programs can be sometimes established by deriving rules of each program from rules of the other in an appropriate deductive system. This paper shows how to extend this method of proving strong equivalence to programs containing the counting aggregate.", "AI": {"tldr": "\u672c\u6587\u5c55\u793a\u4e86\u5982\u4f55\u5c06\u8bc1\u660e\u5f3a\u7b49\u4ef7\u6027\u7684\u65b9\u6cd5\u6269\u5c55\u5230\u5305\u542b\u8ba1\u6570\u805a\u5408\u7684\u7a0b\u5e8f\u4e2d\u3002", "motivation": "\u5728\u56de\u7b54\u96c6\u7f16\u7a0b\u4e2d\uff0c\u5f3a\u7b49\u4ef7\u6027\u662f\u6307\u4e24\u4e2a\u89c4\u5219\u7ec4\u5728\u4efb\u4f55\u4e0a\u4e0b\u6587\u4e2d\u5177\u6709\u76f8\u540c\u542b\u4e49\u3002\u4f20\u7edf\u4e0a\u53ef\u4ee5\u901a\u8fc7\u9002\u5f53\u7684\u6f14\u7ece\u7cfb\u7edf\u6765\u8bc1\u660e\u5f3a\u7b49\u4ef7\u6027\uff0c\u4f46\u8fd9\u79cd\u65b9\u6cd5\u9700\u8981\u6269\u5c55\u5230\u5305\u542b\u8ba1\u6570\u805a\u5408\u7684\u7a0b\u5e8f\u3002", "method": "\u901a\u8fc7\u6269\u5c55\u6f14\u7ece\u7cfb\u7edf\uff0c\u4f7f\u5f97\u80fd\u591f\u4ece\u53e6\u4e00\u4e2a\u7a0b\u5e8f\u7684\u89c4\u5219\u63a8\u5bfc\u51fa\u6bcf\u4e2a\u7a0b\u5e8f\u7684\u89c4\u5219\uff0c\u4ece\u800c\u8bc1\u660e\u5305\u542b\u8ba1\u6570\u805a\u5408\u7684\u7a0b\u5e8f\u7684\u5f3a\u7b49\u4ef7\u6027\u3002", "result": "\u5f00\u53d1\u4e86\u4e00\u79cd\u65b9\u6cd5\u6765\u8bc1\u660e\u5305\u542b\u8ba1\u6570\u805a\u5408\u7684\u7a0b\u5e8f\u7684\u5f3a\u7b49\u4ef7\u6027\uff0c\u6269\u5c55\u4e86\u4f20\u7edf\u7684\u8bc1\u660e\u65b9\u6cd5\u3002", "conclusion": "\u8be5\u65b9\u6cd5\u6210\u529f\u5730\u5c06\u5f3a\u7b49\u4ef7\u6027\u8bc1\u660e\u6280\u672f\u6269\u5c55\u5230\u5305\u542b\u8ba1\u6570\u805a\u5408\u7684\u7a0b\u5e8f\uff0c\u4e3a\u56de\u7b54\u96c6\u7f16\u7a0b\u4e2d\u7684\u7b49\u4ef7\u6027\u9a8c\u8bc1\u63d0\u4f9b\u4e86\u66f4\u5e7f\u6cdb\u7684\u9002\u7528\u6027\u3002"}}
{"id": "2511.20617", "categories": ["cs.SE", "cs.PL"], "pdf": "https://arxiv.org/pdf/2511.20617", "abs": "https://arxiv.org/abs/2511.20617", "authors": ["Saman Dehghan", "Tianran Sun", "Tianxiang Wu", "Zihan Li", "Reyhaneh Jabbarvand"], "title": "Translating Large-Scale C Repositories to Idiomatic Rust", "comment": "21 pages, 14 figures", "summary": "Existing C to Rust translation techniques fail to balance quality and scalability: transpilation-based approaches scale to large projects but produce code with poor safety, idiomaticity, and readability. In contrast, LLM-based techniques are prohibitively expensive due to their reliance on frontier models (without which they cannot reliably generate compilable translations), thus limiting scalability. This paper proposes Rustine, a fully automated pipeline for effective and efficient repository-level C to idiomatic safe Rust translation. Evaluating on a diverse set of 23 C programs, ranging from 27 to 13,200 lines of code, Rustine can generate fully compilable Rust code for all and achieve 87% functional equivalence (passing 1,063,099 assertions out of 1,221,192 in test suites with average function and line coverage of 74.7% and 72.2%). Compared to six prior repository-level C to Rust translation techniques, the translations by Rustine are overall safer (fewer raw pointers, pointer arithmetic, and unsafe constructs), more idiomatic (fewer Rust linter violations), and more readable. When the translations cannot pass all tests to fulfill functional equivalence, human developers were able to complete the task in 4.5 hours, on average, using Rustine as debugging support.", "AI": {"tldr": "Rustine\u662f\u4e00\u4e2a\u81ea\u52a8\u5316C\u5230Rust\u7ffb\u8bd1\u7ba1\u9053\uff0c\u5e73\u8861\u4e86\u8d28\u91cf\u4e0e\u53ef\u6269\u5c55\u6027\uff0c\u76f8\u6bd4\u73b0\u6709\u65b9\u6cd5\u751f\u6210\u66f4\u5b89\u5168\u3001\u66f4\u5730\u9053\u7684Rust\u4ee3\u7801\u3002", "motivation": "\u73b0\u6709C\u5230Rust\u7ffb\u8bd1\u6280\u672f\u65e0\u6cd5\u5e73\u8861\u8d28\u91cf\u4e0e\u53ef\u6269\u5c55\u6027\uff1a\u57fa\u4e8e\u8f6c\u8bd1\u7684\u65b9\u6cd5\u53ef\u6269\u5c55\u4f46\u4ee3\u7801\u5b89\u5168\u6027\u548c\u53ef\u8bfb\u6027\u5dee\uff0c\u800c\u57fa\u4e8eLLM\u7684\u65b9\u6cd5\u6210\u672c\u8fc7\u9ad8\u4e14\u4f9d\u8d56\u524d\u6cbf\u6a21\u578b\u3002", "method": "\u63d0\u51faRustine\u5168\u81ea\u52a8\u7ba1\u9053\uff0c\u7528\u4e8e\u4ed3\u5e93\u7ea7\u522b\u7684C\u5230\u5730\u9053\u5b89\u5168Rust\u7ffb\u8bd1\u3002", "result": "\u572823\u4e2aC\u7a0b\u5e8f\u4e0a\u8bc4\u4f30\uff0cRustine\u80fd\u4e3a\u6240\u6709\u7a0b\u5e8f\u751f\u6210\u5b8c\u5168\u53ef\u7f16\u8bd1\u7684Rust\u4ee3\u7801\uff0c\u8fbe\u523087%\u529f\u80fd\u7b49\u4ef7\u6027\uff08\u901a\u8fc71,063,099/1,221,192\u4e2a\u65ad\u8a00\uff09\uff0c\u5e73\u5747\u51fd\u6570\u548c\u884c\u8986\u76d6\u7387\u4e3a74.7%\u548c72.2%\u3002", "conclusion": "Rustine\u7ffb\u8bd1\u6bd4\u516d\u79cd\u73b0\u6709\u6280\u672f\u66f4\u5b89\u5168\u3001\u66f4\u5730\u9053\u3001\u66f4\u53ef\u8bfb\u3002\u5f53\u7ffb\u8bd1\u65e0\u6cd5\u901a\u8fc7\u6240\u6709\u6d4b\u8bd5\u65f6\uff0c\u5f00\u53d1\u8005\u5e73\u5747\u53ea\u97004.5\u5c0f\u65f6\u5373\u53ef\u5b8c\u6210\u8c03\u8bd5\u3002"}}
{"id": "2511.19897", "categories": ["cs.LO", "cs.FL"], "pdf": "https://arxiv.org/pdf/2511.19897", "abs": "https://arxiv.org/abs/2511.19897", "authors": ["Parosh Aziz Abdulla", "Yu-Fang Chen", "Michal He\u010dko", "Luk\u00e1\u0161 Hol\u00edk", "Ond\u0159ej Leng\u00e1l", "Jyun-Ao Lin", "Ramanathan Srinivasan Thinniyam"], "title": "Parameterized Verification of Quantum Circuits (Technical Report)", "comment": "Accepted for POPL'26", "summary": "We present the first fully automatic framework for verifying relational properties of parameterized quantum programs, i.e., a program that, given an input size, generates a corresponding quantum circuit. We focus on verifying input-output correctness as well as equivalence. At the core of our approach is a new automata model, synchronized weighted tree automata (SWTAs), which compactly and precisely captures the infinite families of quantum states produced by parameterized programs. We introduce a class of transducers to model quantum gate semantics and develop composition algorithms for constructing transducers of parameterized circuits. Verification is reduced to functional inclusion or equivalence checking between SWTAs, for which we provide decision procedures. Our implementation demonstrates both the expressiveness and practical efficiency of the framework by verifying a diverse set of representative parameterized quantum programs with verification times ranging from milliseconds to seconds.", "AI": {"tldr": "\u63d0\u51fa\u4e86\u9996\u4e2a\u81ea\u52a8\u9a8c\u8bc1\u53c2\u6570\u5316\u91cf\u5b50\u7a0b\u5e8f\u5173\u7cfb\u6027\u8d28\u7684\u6846\u67b6\uff0c\u6838\u5fc3\u662f\u540c\u6b65\u52a0\u6743\u6811\u81ea\u52a8\u673a(SWTA)\u6a21\u578b\uff0c\u80fd\u591f\u7d27\u51d1\u7cbe\u786e\u5730\u8868\u793a\u53c2\u6570\u5316\u7a0b\u5e8f\u4ea7\u751f\u7684\u65e0\u9650\u91cf\u5b50\u6001\u65cf\u3002", "motivation": "\u9700\u8981\u9a8c\u8bc1\u53c2\u6570\u5316\u91cf\u5b50\u7a0b\u5e8f\u7684\u8f93\u5165\u8f93\u51fa\u6b63\u786e\u6027\u548c\u7b49\u4ef7\u6027\uff0c\u8fd9\u7c7b\u7a0b\u5e8f\u6839\u636e\u8f93\u5165\u5927\u5c0f\u751f\u6210\u5bf9\u5e94\u7684\u91cf\u5b50\u7535\u8def\uff0c\u4f20\u7edf\u65b9\u6cd5\u96be\u4ee5\u5904\u7406\u65e0\u9650\u72b6\u6001\u65cf\u3002", "method": "\u4f7f\u7528\u540c\u6b65\u52a0\u6743\u6811\u81ea\u52a8\u673a(SWTA)\u6355\u83b7\u91cf\u5b50\u6001\u65cf\uff0c\u5f15\u5165\u91cf\u5b50\u95e8\u8bed\u4e49\u7684\u8f6c\u6362\u5668\u7c7b\uff0c\u5f00\u53d1\u53c2\u6570\u5316\u7535\u8def\u7684\u7ec4\u5408\u7b97\u6cd5\uff0c\u5c06\u9a8c\u8bc1\u95ee\u9898\u8f6c\u5316\u4e3aSWTA\u7684\u529f\u80fd\u5305\u542b\u6216\u7b49\u4ef7\u68c0\u67e5\u3002", "result": "\u5b9e\u73b0\u9a8c\u8bc1\u4e86\u591a\u79cd\u4ee3\u8868\u6027\u53c2\u6570\u5316\u91cf\u5b50\u7a0b\u5e8f\uff0c\u9a8c\u8bc1\u65f6\u95f4\u4ece\u6beb\u79d2\u5230\u79d2\u7ea7\uff0c\u8bc1\u660e\u4e86\u6846\u67b6\u7684\u8868\u8fbe\u80fd\u529b\u548c\u5b9e\u9645\u6548\u7387\u3002", "conclusion": "\u8be5\u6846\u67b6\u9996\u6b21\u5b9e\u73b0\u4e86\u53c2\u6570\u5316\u91cf\u5b50\u7a0b\u5e8f\u7684\u81ea\u52a8\u5173\u7cfb\u6027\u8d28\u9a8c\u8bc1\uff0cSWTA\u6a21\u578b\u548c\u8f6c\u6362\u5668\u65b9\u6cd5\u4e3a\u91cf\u5b50\u7a0b\u5e8f\u9a8c\u8bc1\u63d0\u4f9b\u4e86\u6709\u6548\u89e3\u51b3\u65b9\u6848\u3002"}}
{"id": "2511.19483", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2511.19483", "abs": "https://arxiv.org/abs/2511.19483", "authors": ["Qingsong He", "Jing Nan", "Jiayu Jiao", "Liangjie Tang", "Xiaodong Xu", "Mengmeng Sun", "Qingyao Wang", "Minghui Yan"], "title": "Z-Space: A Multi-Agent Tool Orchestration Framework for Enterprise-Grade LLM Automation", "comment": null, "summary": "Large Language Models can break through knowledge and timeliness limitations by invoking external tools within the Model Context Protocol framework to achieve automated execution of complex tasks. However, with the rapid growth of enterprise-scale MCP services, efficiently and accurately matching target functionalities among thousands of heterogeneous tools has become a core challenge restricting system practicality. Existing approaches generally rely on full-prompt injection or static semantic retrieval, facing issues including semantic disconnection between user queries and tool descriptions, context inflation in LLM input, and high inference latency. To address these challenges, this paper proposes Z-Space, a data-generation-oriented multi-agent collaborative tool invocation framework Z-Space. The Z-Space framework establishes a multi-agent collaborative architecture and tool filtering algorithm: (1) A structured semantic understanding of user queries is achieved through an intent parsing model; (2) A tool filtering module (FSWW) based on fused subspace weighted algorithm realizes fine-grained semantic alignment between intents and tools without parameter tuning; (3) An inference execution agent is constructed to support dynamic planning and fault-tolerant execution for multi-step tasks. This framework has been deployed in the Eleme platform's technical division, serving large-scale test data generation scenarios across multiple business units including Taotian, Gaode, and Hema. Production data demonstrates that the system reduces average token consumption in tool inference by 96.26\\% while achieving a 92\\% tool invocation accuracy rate, significantly enhancing the efficiency and reliability of intelligent test data generation systems.", "AI": {"tldr": "Z-Space\u662f\u4e00\u4e2a\u9762\u5411\u6570\u636e\u751f\u6210\u7684\u591a\u667a\u80fd\u4f53\u534f\u4f5c\u5de5\u5177\u8c03\u7528\u6846\u67b6\uff0c\u901a\u8fc7\u610f\u56fe\u89e3\u6790\u3001\u5de5\u5177\u8fc7\u6ee4\u548c\u6267\u884c\u4ee3\u7406\u89e3\u51b3\u5927\u89c4\u6a21MCP\u670d\u52a1\u4e2d\u5de5\u5177\u5339\u914d\u7684\u6311\u6218\uff0c\u663e\u8457\u63d0\u5347\u667a\u80fd\u6d4b\u8bd5\u6570\u636e\u751f\u6210\u7cfb\u7edf\u7684\u6548\u7387\u548c\u53ef\u9760\u6027\u3002", "motivation": "\u968f\u7740\u4f01\u4e1a\u7ea7MCP\u670d\u52a1\u7684\u5feb\u901f\u589e\u957f\uff0c\u5728\u6570\u5343\u4e2a\u5f02\u6784\u5de5\u5177\u4e2d\u9ad8\u6548\u51c6\u786e\u5730\u5339\u914d\u76ee\u6807\u529f\u80fd\u6210\u4e3a\u9650\u5236\u7cfb\u7edf\u5b9e\u7528\u6027\u7684\u6838\u5fc3\u6311\u6218\u3002\u73b0\u6709\u65b9\u6cd5\u4f9d\u8d56\u5168\u63d0\u793a\u6ce8\u5165\u6216\u9759\u6001\u8bed\u4e49\u68c0\u7d22\uff0c\u9762\u4e34\u7528\u6237\u67e5\u8be2\u4e0e\u5de5\u5177\u63cf\u8ff0\u8bed\u4e49\u8131\u8282\u3001LLM\u8f93\u5165\u4e0a\u4e0b\u6587\u81a8\u80c0\u548c\u9ad8\u63a8\u7406\u5ef6\u8fdf\u7b49\u95ee\u9898\u3002", "method": "\u5efa\u7acb\u591a\u667a\u80fd\u4f53\u534f\u4f5c\u67b6\u6784\u548c\u5de5\u5177\u8fc7\u6ee4\u7b97\u6cd5\uff1a(1)\u901a\u8fc7\u610f\u56fe\u89e3\u6790\u6a21\u578b\u5b9e\u73b0\u7528\u6237\u67e5\u8be2\u7684\u7ed3\u6784\u5316\u8bed\u4e49\u7406\u89e3\uff1b(2)\u57fa\u4e8e\u878d\u5408\u5b50\u7a7a\u95f4\u52a0\u6743\u7b97\u6cd5\u7684\u5de5\u5177\u8fc7\u6ee4\u6a21\u5757(FSWW)\u5b9e\u73b0\u610f\u56fe\u4e0e\u5de5\u5177\u7684\u7ec6\u7c92\u5ea6\u8bed\u4e49\u5bf9\u9f50\uff1b(3)\u6784\u5efa\u63a8\u7406\u6267\u884c\u4ee3\u7406\u652f\u6301\u591a\u6b65\u4efb\u52a1\u7684\u52a8\u6001\u89c4\u5212\u548c\u5bb9\u9519\u6267\u884c\u3002", "result": "\u7cfb\u7edf\u5728\u997f\u4e86\u4e48\u5e73\u53f0\u6280\u672f\u90e8\u90e8\u7f72\uff0c\u670d\u52a1\u4e8e\u6dd8\u5929\u3001\u9ad8\u5fb7\u3001\u76d2\u9a6c\u7b49\u591a\u4e2a\u4e1a\u52a1\u5355\u5143\u7684\u5927\u89c4\u6a21\u6d4b\u8bd5\u6570\u636e\u751f\u6210\u573a\u666f\u3002\u751f\u4ea7\u6570\u636e\u663e\u793a\uff0c\u7cfb\u7edf\u5c06\u5de5\u5177\u63a8\u7406\u7684\u5e73\u5747token\u6d88\u8017\u964d\u4f4e96.26%\uff0c\u540c\u65f6\u8fbe\u523092%\u7684\u5de5\u5177\u8c03\u7528\u51c6\u786e\u7387\u3002", "conclusion": "Z-Space\u6846\u67b6\u663e\u8457\u63d0\u5347\u4e86\u667a\u80fd\u6d4b\u8bd5\u6570\u636e\u751f\u6210\u7cfb\u7edf\u7684\u6548\u7387\u548c\u53ef\u9760\u6027\uff0c\u4e3a\u5927\u89c4\u6a21MCP\u670d\u52a1\u4e2d\u7684\u5de5\u5177\u5339\u914d\u95ee\u9898\u63d0\u4f9b\u4e86\u6709\u6548\u89e3\u51b3\u65b9\u6848\u3002"}}
{"id": "2511.19747", "categories": ["cs.LO", "math.LO"], "pdf": "https://arxiv.org/pdf/2511.19747", "abs": "https://arxiv.org/abs/2511.19747", "authors": ["Tenyo Takahashi"], "title": "Chopping More Finely: Finite Countermodels in Modal Logic via the Subdivision Construction", "comment": "32 pages, 1 figure", "summary": "We present a new method, the Subdivision Construction, for proving the finite model property (the fmp) for broad classes of modal logics and modal rule systems. The construction builds on the framework of stable canonical rules, and produces a finite modal algebra (finite modal space) that will be a finite countermodel of such rules, yielding the fmp. We apply the Subdivision Construction for proving the fmp for logics and rule systems axiomatized by stable canonical formulas and rules of finite modal algebras of finite height. We also observe that these logics and rule systems are union-splittings in corresponding lattices. As a consequence, we identify a class of union-splittings in $\\mathsf{NExt}(\\mathsf{K4})$ with the degree of Kripke incompleteness 1.", "AI": {"tldr": "\u63d0\u51fa\u4e86\u4e00\u79cd\u540d\u4e3a\u7ec6\u5206\u6784\u9020\u7684\u65b0\u65b9\u6cd5\uff0c\u7528\u4e8e\u8bc1\u660e\u6a21\u6001\u903b\u8f91\u548c\u6a21\u6001\u89c4\u5219\u7cfb\u7edf\u7684\u6709\u9650\u6a21\u578b\u6027\u8d28\uff0c\u8be5\u65b9\u6cd5\u57fa\u4e8e\u7a33\u5b9a\u89c4\u8303\u89c4\u5219\u6846\u67b6\u6784\u5efa\u6709\u9650\u6a21\u6001\u4ee3\u6570/\u7a7a\u95f4\u4f5c\u4e3a\u89c4\u5219\u7684\u53cd\u6a21\u578b\u3002", "motivation": "\u4e3a\u5e7f\u6cdb\u7c7b\u522b\u7684\u6a21\u6001\u903b\u8f91\u548c\u6a21\u6001\u89c4\u5219\u7cfb\u7edf\u63d0\u4f9b\u6709\u9650\u6a21\u578b\u6027\u8d28\u7684\u8bc1\u660e\u65b9\u6cd5\uff0c\u7279\u522b\u662f\u9488\u5bf9\u7531\u6709\u9650\u9ad8\u5ea6\u6709\u9650\u6a21\u6001\u4ee3\u6570\u7684\u7a33\u5b9a\u89c4\u8303\u516c\u5f0f\u548c\u89c4\u5219\u516c\u7406\u5316\u7684\u7cfb\u7edf\u3002", "method": "\u7ec6\u5206\u6784\u9020\u65b9\u6cd5\uff0c\u57fa\u4e8e\u7a33\u5b9a\u89c4\u8303\u89c4\u5219\u6846\u67b6\uff0c\u6784\u5efa\u6709\u9650\u6a21\u6001\u4ee3\u6570\u6216\u6709\u9650\u6a21\u6001\u7a7a\u95f4\u4f5c\u4e3a\u6709\u9650\u53cd\u6a21\u578b\u3002", "result": "\u6210\u529f\u8bc1\u660e\u4e86\u7531\u6709\u9650\u9ad8\u5ea6\u6709\u9650\u6a21\u6001\u4ee3\u6570\u7684\u7a33\u5b9a\u89c4\u8303\u516c\u5f0f\u548c\u89c4\u5219\u516c\u7406\u5316\u7684\u903b\u8f91\u548c\u89c4\u5219\u7cfb\u7edf\u5177\u6709\u6709\u9650\u6a21\u578b\u6027\u8d28\uff0c\u5e76\u53d1\u73b0\u8fd9\u4e9b\u7cfb\u7edf\u5728\u76f8\u5e94\u683c\u4e2d\u662f\u5e76\u5206\u88c2\u3002", "conclusion": "\u7ec6\u5206\u6784\u9020\u662f\u8bc1\u660e\u6a21\u6001\u903b\u8f91\u548c\u6a21\u6001\u89c4\u5219\u7cfb\u7edf\u6709\u9650\u6a21\u578b\u6027\u8d28\u7684\u6709\u6548\u65b9\u6cd5\uff0c\u5e76\u8bc6\u522b\u4e86\u5728NExt(K4)\u4e2d\u5177\u6709Kripke\u4e0d\u5b8c\u5168\u5ea6\u4e3a1\u7684\u5e76\u5206\u88c2\u7c7b\u3002"}}
{"id": "2511.19484", "categories": ["cs.SE", "cs.LG"], "pdf": "https://arxiv.org/pdf/2511.19484", "abs": "https://arxiv.org/abs/2511.19484", "authors": ["Randall Balestriero", "Hugues Van Assel", "Sami BuGhanem", "Lucas Maes"], "title": "stable-pretraining-v1: Foundation Model Research Made Simple", "comment": null, "summary": "Foundation models and self-supervised learning (SSL) have become central to modern AI, yet research in this area remains hindered by complex codebases, redundant re-implementations, and the heavy engineering burden of scaling experiments. We present stable-pretraining, a modular, extensible, and performance-optimized library built on top of PyTorch, Lightning, Hugging Face, and TorchMetrics. Unlike prior toolkits focused narrowly on reproducing state-of-the-art results, stable-pretraining is designed for flexibility and iteration speed: it unifies essential SSL utilities--including probes, collapse detection metrics, augmentation pipelines, and extensible evaluation routines--within a coherent and reliable framework. A central design principle is logging everything, enabling fine-grained visibility into training dynamics that makes debugging, monitoring, and reproducibility seamless. We validate the library by demonstrating its ability to generate new research insights with minimal overhead, including depthwise representation probing and the analysis of CLIP degradation under synthetic data finetuning. By lowering barriers to entry while remaining scalable to large experiments, stable-pretraining aims to accelerate discovery and expand the possibilities of foundation model research.", "AI": {"tldr": "stable-pretraining\u662f\u4e00\u4e2a\u6a21\u5757\u5316\u3001\u53ef\u6269\u5c55\u7684\u81ea\u76d1\u7763\u5b66\u4e60\u5e93\uff0c\u65e8\u5728\u964d\u4f4e\u57fa\u7840\u6a21\u578b\u7814\u7a76\u7684\u5de5\u7a0b\u8d1f\u62c5\uff0c\u63d0\u4f9b\u7edf\u4e00\u7684SSL\u5de5\u5177\u548c\u5168\u9762\u65e5\u5fd7\u8bb0\u5f55\uff0c\u52a0\u901f\u7814\u7a76\u8fed\u4ee3\u3002", "motivation": "\u5f53\u524d\u81ea\u76d1\u7763\u5b66\u4e60\u548c\u57fa\u7840\u6a21\u578b\u7814\u7a76\u9762\u4e34\u4ee3\u7801\u5e93\u590d\u6742\u3001\u91cd\u590d\u5b9e\u73b0\u3001\u5de5\u7a0b\u8d1f\u62c5\u91cd\u7b49\u95ee\u9898\uff0c\u963b\u788d\u4e86\u7814\u7a76\u8fdb\u5c55\u3002", "method": "\u57fa\u4e8ePyTorch\u3001Lightning\u3001Hugging Face\u548cTorchMetrics\u6784\u5efa\u6a21\u5757\u5316\u5e93\uff0c\u7edf\u4e00SSL\u5de5\u5177\uff08\u63a2\u9488\u3001\u5d29\u6e83\u68c0\u6d4b\u3001\u6570\u636e\u589e\u5f3a\u3001\u8bc4\u4f30\u6d41\u7a0b\uff09\uff0c\u91c7\u7528\u5168\u9762\u65e5\u5fd7\u8bb0\u5f55\u539f\u5219\u3002", "result": "\u9a8c\u8bc1\u4e86\u5e93\u7684\u6709\u6548\u6027\uff0c\u80fd\u591f\u4ee5\u6700\u5c0f\u5f00\u9500\u751f\u6210\u65b0\u7814\u7a76\u89c1\u89e3\uff0c\u5305\u62ec\u6df1\u5ea6\u8868\u793a\u63a2\u9488\u548cCLIP\u5728\u5408\u6210\u6570\u636e\u5fae\u8c03\u4e0b\u7684\u9000\u5316\u5206\u6790\u3002", "conclusion": "stable-pretraining\u901a\u8fc7\u964d\u4f4e\u5165\u95e8\u95e8\u69db\u5e76\u4fdd\u6301\u5927\u89c4\u6a21\u5b9e\u9a8c\u7684\u53ef\u6269\u5c55\u6027\uff0c\u65e8\u5728\u52a0\u901f\u57fa\u7840\u6a21\u578b\u7814\u7a76\u7684\u53d1\u73b0\u8fdb\u7a0b\u3002"}}
{"id": "2511.19489", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2511.19489", "abs": "https://arxiv.org/abs/2511.19489", "authors": ["Zhe Zhao", "Yuheng Yang", "Haibin Wen", "Xiaojie Qiu", "Zaixi Zhang", "Qingfu Zhang"], "title": "Evolution without an Oracle: Driving Effective Evolution with LLM Judges", "comment": "14 pages, 5 figures", "summary": "The integration of Large Language Models (LLMs) with Evolutionary Computation (EC) has unlocked new frontiers in scientific discovery but remains shackled by a fundamental constraint: the reliance on an Oracle--an objective, machine-computable fitness function. This paper breaks this barrier by asking: Can evolution thrive in a purely subjective landscape governed solely by LLM judges? We introduce MADE (Multi-Agent Decomposed Evolution), a framework that tames the inherent noise of subjective evaluation through \"Problem Specification.\" By decomposing vague instructions into specific, verifiable sub-requirements, MADE transforms high-variance LLM feedback into stable, precise selection pressure. The results are transformative: across complex benchmarks like DevAI and InfoBench, MADE outperforms strong baselines by over 50% in software requirement satisfaction (39.9% to 61.9%) and achieves a 95% perfect pass rate on complex instruction following. This work validates a fundamental paradigm shift: moving from optimizing \"computable metrics\" to \"describable qualities,\" thereby unlocking evolutionary optimization for the vast open-ended domains where no ground truth exists.", "AI": {"tldr": "MADE\u6846\u67b6\u901a\u8fc7\u5c06\u6a21\u7cca\u6307\u4ee4\u5206\u89e3\u4e3a\u53ef\u9a8c\u8bc1\u7684\u5b50\u9700\u6c42\uff0c\u5229\u7528LLM\u4e3b\u89c2\u8bc4\u4ef7\u66ff\u4ee3\u4f20\u7edf\u53ef\u8ba1\u7b97\u9002\u5e94\u5ea6\u51fd\u6570\uff0c\u5728\u65e0\u771f\u5b9e\u6807\u7b7e\u7684\u5f00\u653e\u9886\u57df\u5b9e\u73b0\u8fdb\u5316\u4f18\u5316", "motivation": "\u6253\u7834\u4f20\u7edf\u8fdb\u5316\u8ba1\u7b97\u5bf9\u53ef\u8ba1\u7b97\u9002\u5e94\u5ea6\u51fd\u6570\u7684\u4f9d\u8d56\uff0c\u63a2\u7d22\u5728\u7eaf\u4e3b\u89c2\u8bc4\u4ef7\u4e0b\u7684\u8fdb\u5316\u4f18\u5316\u53ef\u80fd\u6027", "method": "\u63d0\u51faMADE\u6846\u67b6\uff0c\u901a\u8fc7\u95ee\u9898\u89c4\u7ea6\u5c06\u6a21\u7cca\u6307\u4ee4\u5206\u89e3\u4e3a\u5177\u4f53\u53ef\u9a8c\u8bc1\u7684\u5b50\u9700\u6c42\uff0c\u5229\u7528\u591a\u667a\u80fd\u4f53\u5206\u89e3\u8fdb\u5316\u6765\u9a6f\u670dLLM\u4e3b\u89c2\u8bc4\u4ef7\u7684\u566a\u58f0", "result": "\u5728DevAI\u548cInfoBench\u57fa\u51c6\u6d4b\u8bd5\u4e2d\uff0c\u8f6f\u4ef6\u9700\u6c42\u6ee1\u8db3\u7387\u4ece39.9%\u63d0\u5347\u81f361.9%\uff0c\u590d\u6742\u6307\u4ee4\u9075\u5faa\u5b8c\u7f8e\u901a\u8fc7\u7387\u8fbe\u523095%", "conclusion": "\u5b9e\u73b0\u4e86\u4ece\u4f18\u5316\"\u53ef\u8ba1\u7b97\u6307\u6807\"\u5230\"\u53ef\u63cf\u8ff0\u8d28\u91cf\"\u7684\u8303\u5f0f\u8f6c\u53d8\uff0c\u4e3a\u65e0\u771f\u5b9e\u6807\u7b7e\u7684\u5f00\u653e\u9886\u57df\u89e3\u9501\u4e86\u8fdb\u5316\u4f18\u5316\u80fd\u529b"}}
{"id": "2511.19510", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2511.19510", "abs": "https://arxiv.org/abs/2511.19510", "authors": ["Asif Zaman", "Kallol Naha", "Khalid Belhajjame", "Hasan M. Jamil"], "title": "CodeR3: A GenAI-Powered Workflow Repair and Revival Ecosystem", "comment": "9 pages, 4 figures", "summary": "Scientific workflows encode valuable domain expertise and computational methodologies. Yet studies consistently show that a significant proportion of published workflows suffer from decay over time. This problem is particularly acute for legacy workflow systems like Taverna, where discontinued services, obsolete dependencies, and system retirement render previously functional workflows unusable. We present a novel legacy workflow migration system, called CodeR$^3$ (stands for Code Repair, Revival and Reuse), that leverages generative AI to analyze the characteristics of decayed workflows, reproduce them into modern workflow technologies like Snakemake and VisFlow. Our system additionally integrates stepwise workflow analysis visualization, automated service substitution, and human-in-the-loop validation. Through several case studies of Taverna workflow revival, we demonstrate the feasibility of this approach while identifying key challenges that require human oversight. Our findings reveal that automation significantly reduces manual effort in workflow parsing and service identification. However, critical tasks such as service substitution and data validation still require domain expertise. Our result will be a crowdsourcing platform that enables the community to collaboratively revive decayed workflows and validate the functionality and correctness of revived workflows. This work contributes a framework for workflow revival that balances automation efficiency with necessary human judgment.", "AI": {"tldr": "CodeR\u00b3\u7cfb\u7edf\u5229\u7528\u751f\u6210\u5f0fAI\u5c06\u8fc7\u65f6\u7684Taverna\u5de5\u4f5c\u6d41\u8fc1\u79fb\u5230Snakemake\u548cVisFlow\u7b49\u73b0\u4ee3\u6280\u672f\uff0c\u7ed3\u5408\u53ef\u89c6\u5316\u5206\u6790\u548c\u4eba\u673a\u534f\u4f5c\u9a8c\u8bc1\uff0c\u663e\u8457\u51cf\u5c11\u624b\u52a8\u5de5\u4f5c\u91cf\u4f46\u5173\u952e\u4efb\u52a1\u4ecd\u9700\u4eba\u5de5\u76d1\u7763\u3002", "motivation": "\u79d1\u5b66\u5de5\u4f5c\u6d41\u5305\u542b\u91cd\u8981\u9886\u57df\u77e5\u8bc6\uff0c\u4f46\u5927\u91cf\u5df2\u53d1\u5e03\u5de5\u4f5c\u6d41\u968f\u65f6\u95f4\u8870\u8d25\uff0c\u7279\u522b\u662fTaverna\u7b49\u9057\u7559\u7cfb\u7edf\u56e0\u670d\u52a1\u7ec8\u6b62\u3001\u4f9d\u8d56\u8fc7\u65f6\u7b49\u95ee\u9898\u5bfc\u81f4\u5de5\u4f5c\u6d41\u5931\u6548\u3002", "method": "\u5f00\u53d1CodeR\u00b3\u7cfb\u7edf\uff0c\u4f7f\u7528\u751f\u6210\u5f0fAI\u5206\u6790\u8870\u8d25\u5de5\u4f5c\u6d41\u7279\u5f81\uff0c\u5c06\u5176\u8f6c\u6362\u4e3a\u73b0\u4ee3\u5de5\u4f5c\u6d41\u6280\u672f\uff0c\u96c6\u6210\u9010\u6b65\u53ef\u89c6\u5316\u5206\u6790\u3001\u81ea\u52a8\u670d\u52a1\u66ff\u6362\u548c\u4eba\u673a\u534f\u4f5c\u9a8c\u8bc1\u3002", "result": "\u6848\u4f8b\u7814\u7a76\u8868\u660e\u8be5\u65b9\u6cd5\u53ef\u884c\uff0c\u81ea\u52a8\u5316\u663e\u8457\u51cf\u5c11\u4e86\u5de5\u4f5c\u6d41\u89e3\u6790\u548c\u670d\u52a1\u8bc6\u522b\u7684\u624b\u52a8\u5de5\u4f5c\uff0c\u4f46\u670d\u52a1\u66ff\u6362\u548c\u6570\u636e\u9a8c\u8bc1\u4ecd\u9700\u9886\u57df\u4e13\u5bb6\u53c2\u4e0e\u3002", "conclusion": "\u63d0\u51fa\u4e86\u4e00\u4e2a\u5e73\u8861\u81ea\u52a8\u5316\u6548\u7387\u548c\u5fc5\u8981\u4eba\u5de5\u5224\u65ad\u7684\u5de5\u4f5c\u6d41\u590d\u5174\u6846\u67b6\uff0c\u5c06\u5f00\u53d1\u4f17\u5305\u5e73\u53f0\u4f9b\u793e\u533a\u534f\u4f5c\u590d\u5174\u548c\u9a8c\u8bc1\u5de5\u4f5c\u6d41\u3002"}}
{"id": "2511.20540", "categories": ["cs.LO", "cs.AI", "cs.GT", "cs.MA"], "pdf": "https://arxiv.org/pdf/2511.20540", "abs": "https://arxiv.org/abs/2511.20540", "authors": ["Adam Bjorndahl"], "title": "Proceedings Twentieth Conference on Theoretical Aspects of Rationality and Knowledge", "comment": null, "summary": "The TARK conference (Theoretical Aspects of Rationality and Knowledge) is a conference that aims to bring together researchers from a wide variety of fields, including computer science, artificial intelligence, game theory, decision theory, philosophy, logic, linguistics, and cognitive science. Its goal is to further our understanding of interdisciplinary issues involving reasoning about rationality and knowledge.\n  Previous conferences have been held biennially around the world since 1986, on the initiative of Joe Halpern (Cornell University). Topics of interest include, but are not limited to, semantic models for knowledge, belief, uncertainty, awareness, bounded rationality, common sense epistemic reasoning, epistemic logic, epistemic game theory, knowledge and action, applications of reasoning about knowledge and other mental states, belief revision, computational social choice, algorithmic game theory, and foundations of multi-agent systems.\n  Information about TARK is available at http://www.tark.org/.\n  These proceedings contain the papers that have been accepted for presentation at the Twentieth Conference on Theoretical Aspects of Rationality and Knowledge (TARK 2025), held July 14--16, 2025, at Heinrich-Heine-Universit\u00e4t, D\u00fcsseldorf, Germany. The conference website can be found at https://ccc.cs.uni-duesseldorf.de/tark-2025/.", "AI": {"tldr": "TARK\u4f1a\u8bae\u662f\u5173\u4e8e\u7406\u6027\u548c\u77e5\u8bc6\u7406\u8bba\u65b9\u9762\u7684\u8de8\u5b66\u79d1\u4f1a\u8bae\uff0c\u6c47\u96c6\u4e86\u8ba1\u7b97\u673a\u79d1\u5b66\u3001\u4eba\u5de5\u667a\u80fd\u3001\u535a\u5f08\u8bba\u7b49\u591a\u4e2a\u9886\u57df\u7684\u7814\u7a76\u8005\uff0c\u65e8\u5728\u4fc3\u8fdb\u5bf9\u7406\u6027\u548c\u77e5\u8bc6\u63a8\u7406\u7684\u7406\u89e3\u3002", "motivation": "\u4fc3\u8fdb\u4e0d\u540c\u5b66\u79d1\u9886\u57df\u7814\u7a76\u8005\u4e4b\u95f4\u7684\u4ea4\u6d41\uff0c\u8fdb\u4e00\u6b65\u7406\u89e3\u7406\u6027\u548c\u77e5\u8bc6\u63a8\u7406\u7684\u8de8\u5b66\u79d1\u95ee\u9898\u3002", "method": "\u901a\u8fc7\u4e24\u5e74\u4e00\u6b21\u7684\u4f1a\u8bae\u5f62\u5f0f\uff0c\u6c47\u96c6\u6765\u81ea\u8ba1\u7b97\u673a\u79d1\u5b66\u3001\u4eba\u5de5\u667a\u80fd\u3001\u535a\u5f08\u8bba\u3001\u51b3\u7b56\u7406\u8bba\u3001\u54f2\u5b66\u3001\u903b\u8f91\u5b66\u3001\u8bed\u8a00\u5b66\u548c\u8ba4\u77e5\u79d1\u5b66\u7b49\u9886\u57df\u7684\u7814\u7a76\u8005\u8fdb\u884c\u5b66\u672f\u4ea4\u6d41\u3002", "result": "\u6210\u529f\u4e3e\u529e\u4e86\u81ea1986\u5e74\u4ee5\u6765\u7684\u7cfb\u5217\u4f1a\u8bae\uff0c2025\u5e74\u5c06\u5728\u5fb7\u56fd\u675c\u585e\u5c14\u591a\u592b\u5927\u5b66\u4e3e\u529e\u7b2c20\u5c4a\u4f1a\u8bae\uff0c\u6536\u5f55\u4e86\u76f8\u5173\u9886\u57df\u7684\u7814\u7a76\u8bba\u6587\u3002", "conclusion": "TARK\u4f1a\u8bae\u4f5c\u4e3a\u4e00\u4e2a\u957f\u671f\u8fd0\u884c\u7684\u8de8\u5b66\u79d1\u5e73\u53f0\uff0c\u6301\u7eed\u63a8\u52a8\u7740\u7406\u6027\u548c\u77e5\u8bc6\u7406\u8bba\u9886\u57df\u7684\u7814\u7a76\u53d1\u5c55\uff0c\u4fc3\u8fdb\u4e86\u4e0d\u540c\u5b66\u79d1\u4e4b\u95f4\u7684\u601d\u60f3\u4ea4\u6d41\u3002"}}
{"id": "2511.19635", "categories": ["cs.SE", "cs.LG"], "pdf": "https://arxiv.org/pdf/2511.19635", "abs": "https://arxiv.org/abs/2511.19635", "authors": ["Abhi Chivukula", "Jay Somasundaram", "Vijay Somasundaram"], "title": "Agint: Agentic Graph Compilation for Software Engineering Agents", "comment": "18 pages, 5 figures, NeurIPS 2025: Deep Learning for Code in the Agentic Era", "summary": "LLM-based coding agents are increasingly common but still face challenges in context management, latency, reliability, reproducibility, and scalability. We present Agint, an agentic graph compiler, interpreter, and runtime that incrementally and hierarchically converts natural-language instructions into typed, effect-aware code DAGs. Agint introduces explicit type floors (text to data to spec to code) grounded in semantic graph transformations and a hybrid LLM and function-based JIT runtime. This enables dynamic graph refinement, reproducible and optimizable execution, speculative evaluation, and interoperability with existing developer tools. Agint's typed graph bindings improve reliability and allow concurrent composition of concurrent codebases by construction, supporting accelerated development with smaller and faster models, lower latency, efficient context utilization, and higher throughput. Hierarchical compilation allows scalable graph edits, while the graph structure supports reproducibility and efficient parallel generation. Agint provides a composable unix-style toolchain: dagify (DAG compiler), dagent (hybrid JIT runtime), schemagin (schema generator), and datagin (data transformer) for realtime, low-latency code and dataflow creation. Human developers and coding agents refine graphs through the Agint CLI, while non-technical users use Agint Flow GUI for visual editing, conversational refinement, and debugging to promote prototype agentic workflows to production code. This continuous co-creation model allows teams to prototype quickly, refine seamlessly, and deploy reliably, bridging natural language, compiler methods, and developer tooling to enable a new generation of composable, team-centric coding agents at scale.", "AI": {"tldr": "Agint\u662f\u4e00\u4e2a\u57fa\u4e8e\u56fe\u7684\u667a\u80fd\u7f16\u7801\u4ee3\u7406\u7cfb\u7edf\uff0c\u901a\u8fc7\u5206\u5c42\u7f16\u8bd1\u5c06\u81ea\u7136\u8bed\u8a00\u6307\u4ee4\u8f6c\u6362\u4e3a\u7c7b\u578b\u5316\u4ee3\u7801DAG\uff0c\u63d0\u4f9b\u6df7\u5408LLM\u548c\u51fd\u6570JIT\u8fd0\u884c\u65f6\uff0c\u652f\u6301\u52a8\u6001\u56fe\u4f18\u5316\u3001\u53ef\u91cd\u73b0\u6267\u884c\u548c\u4e0e\u73b0\u6709\u5f00\u53d1\u5de5\u5177\u96c6\u6210\u3002", "motivation": "\u89e3\u51b3\u5f53\u524dLLM\u7f16\u7801\u4ee3\u7406\u5728\u4e0a\u4e0b\u6587\u7ba1\u7406\u3001\u5ef6\u8fdf\u3001\u53ef\u9760\u6027\u3001\u53ef\u91cd\u73b0\u6027\u548c\u53ef\u6269\u5c55\u6027\u65b9\u9762\u7684\u6311\u6218\uff0c\u6784\u5efa\u53ef\u7ec4\u5408\u3001\u56e2\u961f\u534f\u4f5c\u7684\u7f16\u7801\u4ee3\u7406\u7cfb\u7edf\u3002", "method": "\u91c7\u7528\u663e\u5f0f\u7c7b\u578b\u5c42\u6b21\uff08\u6587\u672c\u2192\u6570\u636e\u2192\u89c4\u8303\u2192\u4ee3\u7801\uff09\u7684\u8bed\u4e49\u56fe\u8f6c\u6362\uff0c\u7ed3\u5408\u6df7\u5408LLM\u548c\u51fd\u6570JIT\u8fd0\u884c\u65f6\uff0c\u5b9e\u73b0\u589e\u91cf\u5206\u5c42\u7f16\u8bd1\u548c\u52a8\u6001\u56fe\u4f18\u5316\u3002", "result": "\u63d0\u9ad8\u4e86\u53ef\u9760\u6027\uff0c\u652f\u6301\u5e76\u53d1\u4ee3\u7801\u5e93\u7ec4\u5408\uff0c\u4f7f\u7528\u66f4\u5c0f\u66f4\u5feb\u7684\u6a21\u578b\uff0c\u964d\u4f4e\u5ef6\u8fdf\uff0c\u63d0\u9ad8\u4e0a\u4e0b\u6587\u5229\u7528\u6548\u7387\u548c\u541e\u5410\u91cf\u3002", "conclusion": "Agint\u901a\u8fc7\u8fde\u63a5\u81ea\u7136\u8bed\u8a00\u3001\u7f16\u8bd1\u5668\u65b9\u6cd5\u548c\u5f00\u53d1\u5de5\u5177\uff0c\u5b9e\u73b0\u4e86\u53ef\u7ec4\u5408\u3001\u56e2\u961f\u5bfc\u5411\u7684\u7f16\u7801\u4ee3\u7406\u89c4\u6a21\u5316\u90e8\u7f72\uff0c\u652f\u6301\u4ece\u539f\u578b\u5230\u751f\u4ea7\u4ee3\u7801\u7684\u65e0\u7f1d\u8fc7\u6e21\u3002"}}
{"id": "2511.20550", "categories": ["cs.LO"], "pdf": "https://arxiv.org/pdf/2511.20550", "abs": "https://arxiv.org/abs/2511.20550", "authors": ["Dustin Bryant", "Jonathan Julian Huerta y Munive", "Simon Foster"], "title": "Verifying Numerical Methods with Isabelle/HOL", "comment": "30 pages, 30 listings, for accompanying formalisation, see https://zenodo.org/records/17679526", "summary": "Modern machine learning pipelines are built on numerical algorithms. Reliable numerical methods are thus a prerequisite for trustworthy machine learning and cyber-physical systems. Therefore, we contribute a framework for verified numerical methods in Isabelle/HOL based on ITrees. Our user-friendly specification language enables the direct declaration of numerical programs that can be annotated with variants and invariants for reasoning about correctness specifications. The generated verification conditions can be discharged via automated proof methods and lemmas from the HOL-Analysis library. The ITrees foundation interacts with Isabelle's code generator to export source code. This provides an end-to-end path from formal specifications with machine-checked guarantees to executable sources. We illustrate the process of modelling numerical methods and demonstrate the effectiveness of the verification by focusing on two well-known methods, the bisection method and the fixed-point iteration method. We also contribute crucial extensions to the libraries of formalised mathematics required for this objective: higher-order derivatives and Taylor's theorem in Peano form. Finally, we qualitatively evaluate the use of the framework for verifying numerical methods.", "AI": {"tldr": "\u63d0\u51fa\u4e86\u4e00\u4e2a\u57fa\u4e8eIsabelle/HOL\u548cITrees\u7684\u9a8c\u8bc1\u6570\u503c\u65b9\u6cd5\u6846\u67b6\uff0c\u652f\u6301\u4ece\u5f62\u5f0f\u5316\u89c4\u8303\u5230\u53ef\u6267\u884c\u4ee3\u7801\u7684\u7aef\u5230\u7aef\u8def\u5f84\uff0c\u5e76\u5e94\u7528\u4e8e\u4e8c\u5206\u6cd5\u548c\u4e0d\u52a8\u70b9\u8fed\u4ee3\u6cd5\u3002", "motivation": "\u73b0\u4ee3\u673a\u5668\u5b66\u4e60\u7ba1\u9053\u4f9d\u8d56\u6570\u503c\u7b97\u6cd5\uff0c\u53ef\u9760\u7684\u6570\u503c\u65b9\u6cd5\u662f\u53ef\u4fe1\u673a\u5668\u5b66\u4e60\u548c\u7f51\u7edc\u7269\u7406\u7cfb\u7edf\u7684\u5148\u51b3\u6761\u4ef6\u3002", "method": "\u57fa\u4e8eITrees\u7684Isabelle/HOL\u6846\u67b6\uff0c\u63d0\u4f9b\u7528\u6237\u53cb\u597d\u7684\u89c4\u8303\u8bed\u8a00\uff0c\u53ef\u76f4\u63a5\u58f0\u660e\u6570\u503c\u7a0b\u5e8f\u5e76\u6807\u6ce8\u53d8\u4f53\u548c\u4e0d\u53d8\u5f0f\uff0c\u9a8c\u8bc1\u6761\u4ef6\u53ef\u901a\u8fc7\u81ea\u52a8\u5316\u8bc1\u660e\u65b9\u6cd5\u548cHOL-Analysis\u5e93\u5f15\u7406\u89e3\u51b3\u3002", "result": "\u6210\u529f\u9a8c\u8bc1\u4e86\u4e8c\u5206\u6cd5\u548c\u4e0d\u52a8\u70b9\u8fed\u4ee3\u6cd5\uff0c\u6269\u5c55\u4e86\u5f62\u5f0f\u5316\u6570\u5b66\u5e93\uff08\u9ad8\u9636\u5bfc\u6570\u548c\u6cf0\u52d2\u5b9a\u7406\uff09\uff0c\u63d0\u4f9b\u4e86\u4ece\u5f62\u5f0f\u89c4\u8303\u5230\u53ef\u6267\u884c\u4ee3\u7801\u7684\u5b8c\u6574\u8def\u5f84\u3002", "conclusion": "\u8be5\u6846\u67b6\u4e3a\u6570\u503c\u65b9\u6cd5\u63d0\u4f9b\u4e86\u673a\u5668\u68c0\u67e5\u7684\u4fdd\u8bc1\uff0c\u5c55\u793a\u4e86\u5728\u9a8c\u8bc1\u6570\u503c\u7b97\u6cd5\u65b9\u9762\u7684\u6709\u6548\u6027\uff0c\u5e76\u6269\u5c55\u4e86\u5fc5\u8981\u7684\u6570\u5b66\u57fa\u7840\u5e93\u3002"}}
{"id": "2511.19875", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2511.19875", "abs": "https://arxiv.org/abs/2511.19875", "authors": ["Qingyu Zhang", "Puzhuo Liu", "Peng Di", "Chenxiong Qian"], "title": "CodeFuse-CommitEval: Towards Benchmarking LLM's Power on Commit Message and Code Change Inconsistency Detection", "comment": null, "summary": "Version control relies on commit messages to convey the rationale for code changes, but these messages are often low quality and, more critically, inconsistent with their diffs-known as message-code inconsistency (MCI). MCIs mislead reviewers, hinder maintenance, contaminate research datasets, and may obscure security patches. Yet, no dedicated benchmark exists to evaluate models for MCI detection. We introduce CODEFUSE-COMMITEVAL, the first benchmark designed for MCI detection using large language models (LLMs). Built on the ApacheCM dataset for diversity and quality, we generate seven types of inconsistent messages through rule-guided mutations of originally consistent commits and apply two-fold validation to verify both positive and negative samples. Using this labeled dataset of message-diff pairs, we evaluate six state-of-the-art open-source LLMs under a vanilla setting and with three augmentation strategies: few-shot prompting, chain-of-thought, and extended context. Results show models detect inconsistent commits more reliably than consistent ones (average Recall 85.95%, Precision 80.28%, Specificity 63.8%); gpt-oss-20B performs best overall but uses over twice the tokens of others. Augmentation effects vary: adjacent context helps larger models but adds noise for smaller ones; few-shot improves accuracy and reduces token use, yet increases universally incorrect predictions; chain-of-thought boosts precision and specificity at the cost of recall and higher token consumption. Type-wise analysis reveals higher detectability for component, file-path, and operation inconsistencies, but lower accuracy and higher token cost for intent-level \"purpose\" inconsistencies. CODEFUSE-COMMITEVAL provides a rigorous foundation for measuring, comparing, and advancing MCI detection, highlighting the need for richer context and balanced data to capture high-level semantic gaps.", "AI": {"tldr": "\u63d0\u51fa\u4e86CODEFUSE-COMMITEVAL\uff0c\u8fd9\u662f\u9996\u4e2a\u4e13\u95e8\u7528\u4e8e\u8bc4\u4f30\u5927\u8bed\u8a00\u6a21\u578b\u68c0\u6d4b\u63d0\u4ea4\u6d88\u606f\u4e0e\u4ee3\u7801\u4e0d\u4e00\u81f4\u6027\u7684\u57fa\u51c6\uff0c\u901a\u8fc7\u89c4\u5219\u5316\u53d8\u5f02\u751f\u6210\u4e03\u79cd\u4e0d\u4e00\u81f4\u6d88\u606f\u7c7b\u578b\uff0c\u5e76\u8bc4\u4f30\u4e86\u516d\u79cd\u5f00\u6e90LLM\u5728\u4e0d\u540c\u589e\u5f3a\u7b56\u7565\u4e0b\u7684\u8868\u73b0\u3002", "motivation": "\u73b0\u6709\u7684\u63d0\u4ea4\u6d88\u606f\u5f80\u5f80\u8d28\u91cf\u4f4e\u4e14\u4e0e\u4ee3\u7801\u53d8\u66f4\u4e0d\u4e00\u81f4\uff0c\u8fd9\u4f1a\u8bef\u5bfc\u4ee3\u7801\u5ba1\u67e5\u3001\u963b\u788d\u7ef4\u62a4\u3001\u6c61\u67d3\u7814\u7a76\u6570\u636e\u96c6\uff0c\u751a\u81f3\u53ef\u80fd\u63a9\u76d6\u5b89\u5168\u8865\u4e01\uff0c\u4f46\u76ee\u524d\u7f3a\u4e4f\u4e13\u95e8\u8bc4\u4f30MCI\u68c0\u6d4b\u6a21\u578b\u7684\u57fa\u51c6\u3002", "method": "\u57fa\u4e8eApacheCM\u6570\u636e\u96c6\uff0c\u901a\u8fc7\u89c4\u5219\u5f15\u5bfc\u7684\u53d8\u5f02\u751f\u6210\u4e03\u79cd\u7c7b\u578b\u7684\u4e0d\u4e00\u81f4\u6d88\u606f\uff0c\u91c7\u7528\u53cc\u91cd\u9a8c\u8bc1\u786e\u4fdd\u6b63\u8d1f\u6837\u672c\u8d28\u91cf\uff0c\u8bc4\u4f30\u516d\u79cd\u5f00\u6e90LLM\u5728\u666e\u901a\u8bbe\u7f6e\u548c\u4e09\u79cd\u589e\u5f3a\u7b56\u7565\u4e0b\u7684\u8868\u73b0\u3002", "result": "\u6a21\u578b\u68c0\u6d4b\u4e0d\u4e00\u81f4\u63d0\u4ea4\u6bd4\u4e00\u81f4\u63d0\u4ea4\u66f4\u53ef\u9760\uff1bgpt-oss-20B\u8868\u73b0\u6700\u4f73\u4f46token\u6d88\u8017\u662f\u5176\u4ed6\u6a21\u578b\u7684\u4e24\u500d\u591a\uff1b\u589e\u5f3a\u7b56\u7565\u6548\u679c\u5404\u5f02\uff1a\u76f8\u90bb\u4e0a\u4e0b\u6587\u5bf9\u5927\u6a21\u578b\u6709\u5e2e\u52a9\u4f46\u5bf9\u5c0f\u6a21\u578b\u589e\u52a0\u566a\u58f0\uff0cfew-shot\u63d0\u9ad8\u51c6\u786e\u7387\u4f46\u589e\u52a0\u9519\u8bef\u9884\u6d4b\uff0cchain-of-thought\u63d0\u5347\u7cbe\u786e\u5ea6\u4f46\u964d\u4f4e\u53ec\u56de\u7387\u3002", "conclusion": "CODEFUSE-COMMITEVAL\u4e3aMCI\u68c0\u6d4b\u63d0\u4f9b\u4e86\u4e25\u8c28\u7684\u8bc4\u4f30\u57fa\u7840\uff0c\u63ed\u793a\u4e86\u9700\u8981\u66f4\u4e30\u5bcc\u7684\u4e0a\u4e0b\u6587\u548c\u5e73\u8861\u6570\u636e\u6765\u6355\u6349\u9ad8\u5c42\u6b21\u8bed\u4e49\u5dee\u8ddd\uff0c\u4e0d\u540c\u4e0d\u4e00\u81f4\u7c7b\u578b\u7684\u68c0\u6d4b\u96be\u5ea6\u5b58\u5728\u5dee\u5f02\u3002"}}
{"id": "2511.20403", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2511.20403", "abs": "https://arxiv.org/abs/2511.20403", "authors": ["Andrea Lops", "Fedelucio Narducci", "Azzurra Ragone", "Michelantonio Trizio", "Claudio Barto"], "title": "LLMs for Automated Unit Test Generation and Assessment in Java: The AgoneTest Framework", "comment": "Accepted at 40th IEEE/ACM International Conference on Automated Software Engineering", "summary": "Unit testing is an essential but resource-intensive step in software development, ensuring individual code units function correctly. This paper introduces AgoneTest, an automated evaluation framework for Large Language Model-generated (LLM) unit tests in Java. AgoneTest does not aim to propose a novel test generation algorithm; rather, it supports researchers and developers in comparing different LLMs and prompting strategies through a standardized end-to-end evaluation pipeline under realistic conditions. We introduce the Classes2Test dataset, which maps Java classes under test to their corresponding test classes, and a framework that integrates advanced evaluation metrics, such as mutation score and test smells, for a comprehensive assessment. Experimental results show that, for the subset of tests that compile, LLM-generated tests can match or exceed human-written tests in terms of coverage and defect detection. Our findings also demonstrate that enhanced prompting strategies contribute to test quality. AgoneTest clarifies the potential of LLMs in software testing and offers insights for future improvements in model design, prompt engineering, and testing practices.", "AI": {"tldr": "AgoneTest\u662f\u4e00\u4e2a\u7528\u4e8e\u8bc4\u4f30LLM\u751f\u6210\u7684Java\u5355\u5143\u6d4b\u8bd5\u7684\u81ea\u52a8\u5316\u6846\u67b6\uff0c\u5305\u542bClasses2Test\u6570\u636e\u96c6\u548c\u7efc\u5408\u8bc4\u4f30\u6307\u6807\uff0c\u5b9e\u9a8c\u663e\u793aLLM\u751f\u6210\u7684\u6d4b\u8bd5\u5728\u7f16\u8bd1\u6210\u529f\u7684\u60c5\u51b5\u4e0b\u53ef\u4ee5\u8fbe\u5230\u6216\u8d85\u8fc7\u4eba\u5de5\u7f16\u5199\u6d4b\u8bd5\u7684\u8d28\u91cf\u3002", "motivation": "\u5355\u5143\u6d4b\u8bd5\u662f\u8f6f\u4ef6\u5f00\u53d1\u4e2d\u91cd\u8981\u4f46\u8d44\u6e90\u5bc6\u96c6\u7684\u73af\u8282\uff0c\u9700\u8981\u6807\u51c6\u5316\u6846\u67b6\u6765\u8bc4\u4f30\u4e0d\u540cLLM\u548c\u63d0\u793a\u7b56\u7565\u5728\u771f\u5b9e\u6761\u4ef6\u4e0b\u7684\u6d4b\u8bd5\u751f\u6210\u80fd\u529b\u3002", "method": "\u63d0\u51faAgoneTest\u8bc4\u4f30\u6846\u67b6\u548cClasses2Test\u6570\u636e\u96c6\uff0c\u96c6\u6210\u53d8\u5f02\u5206\u6570\u548c\u6d4b\u8bd5\u5f02\u5473\u7b49\u9ad8\u7ea7\u8bc4\u4f30\u6307\u6807\uff0c\u5efa\u7acb\u7aef\u5230\u7aef\u7684\u6807\u51c6\u5316\u8bc4\u4f30\u6d41\u7a0b\u3002", "result": "\u5bf9\u4e8e\u80fd\u591f\u7f16\u8bd1\u7684\u6d4b\u8bd5\u5b50\u96c6\uff0cLLM\u751f\u6210\u7684\u6d4b\u8bd5\u5728\u8986\u76d6\u7387\u548c\u7f3a\u9677\u68c0\u6d4b\u65b9\u9762\u80fd\u591f\u5339\u914d\u6216\u8d85\u8fc7\u4eba\u5de5\u7f16\u5199\u7684\u6d4b\u8bd5\uff0c\u589e\u5f3a\u7684\u63d0\u793a\u7b56\u7565\u6709\u52a9\u4e8e\u63d0\u9ad8\u6d4b\u8bd5\u8d28\u91cf\u3002", "conclusion": "AgoneTest\u9610\u660e\u4e86LLM\u5728\u8f6f\u4ef6\u6d4b\u8bd5\u4e2d\u7684\u6f5c\u529b\uff0c\u4e3a\u672a\u6765\u6a21\u578b\u8bbe\u8ba1\u3001\u63d0\u793a\u5de5\u7a0b\u548c\u6d4b\u8bd5\u5b9e\u8df5\u7684\u6539\u8fdb\u63d0\u4f9b\u4e86\u89c1\u89e3\u3002"}}

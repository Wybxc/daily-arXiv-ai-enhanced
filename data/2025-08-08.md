<div id=toc></div>

# Table of Contents

- [cs.SE](#cs.SE) [Total: 12]
- [cs.PL](#cs.PL) [Total: 1]


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [1] [Automated File-Level Logging Generation for Machine Learning Applications using LLMs: A Case Study using GPT-4o Mini](https://arxiv.org/abs/2508.04820)
*Mayra Sofia Ruiz Rodriguez,SayedHassan Khatoonabadi,Emad Shihab*

Main category: cs.SE

TL;DR: 研究评估了GPT-4o mini在机器学习项目中生成文件级日志的能力，发现其生成位置与人类日志一致率为63.91%，但存在82.66%的过度日志问题。


<details>
  <summary>Details</summary>
Motivation: 探索大型语言模型（LLMs）在文件级日志生成中的潜力，尤其是在机器学习应用中，以提升系统可靠性。

Method: 收集171个ML仓库的4,073个Python文件，移除原始日志后，用LLM生成日志，并评估日志位置、级别、变量和文本质量。

Result: LLM生成日志的位置与人类一致率为63.91%，但过度日志率高达82.66%，且存在日志位置和项目规范不一致的问题。

Conclusion: LLM在文件级日志生成中表现有潜力，但需解决过度日志和规范对齐问题才能实际应用。

Abstract: Logging is essential in software development, helping developers monitor
system behavior and aiding in debugging applications. Given the ability of
large language models (LLMs) to generate natural language and code, researchers
are exploring their potential to generate log statements. However, prior work
focuses on evaluating logs introduced in code functions, leaving file-level log
generation underexplored -- especially in machine learning (ML) applications,
where comprehensive logging can enhance reliability. In this study, we evaluate
the capacity of GPT-4o mini as a case study to generate log statements for ML
projects at file level. We gathered a set of 171 ML repositories containing
4,073 Python files with at least one log statement. We identified and removed
the original logs from the files, prompted the LLM to generate logs for them,
and evaluated both the position of the logs and log level, variables, and text
quality of the generated logs compared to human-written logs. In addition, we
manually analyzed a representative sample of generated logs to identify common
patterns and challenges. We find that the LLM introduces logs in the same place
as humans in 63.91% of cases, but at the cost of a high overlogging rate of
82.66%. Furthermore, our manual analysis reveals challenges for file-level
logging, which shows overlogging at the beginning or end of a function,
difficulty logging within large code blocks, and misalignment with
project-specific logging conventions. While the LLM shows promise for
generating logs for complete files, these limitations remain to be addressed
for practical implementation.

</details>


### [2] [Automated Bug Frame Retrieval from Gameplay Videos Using Vision-Language Models](https://arxiv.org/abs/2508.04895)
*Wentao Lu,Alexander Senchenko,Abram Hindle,Cor-Paul Bezemer*

Main category: cs.SE

TL;DR: 论文提出了一种自动化流程，将游戏视频缩减为最能匹配错误描述的单帧图像，显著减少开发者的手动工作量。


<details>
  <summary>Details</summary>
Motivation: 现代游戏工作室快速发布新版本和补丁，产生大量包含游戏视频的错误报告，手动检查这些视频耗时且难以扩展。

Method: 使用FFmpeg提取关键帧，再通过视觉-语言模型（GPT-4o）评估并选择最匹配错误描述的代表性帧。

Result: 在真实游戏视频和JIRA错误报告上测试，F1分数为0.79，准确率为0.89。性能因错误类别而异，最高为光照与阴影（F1=0.94）。

Conclusion: 该方法通过提供即时视觉证据，显著提高了错误分类和回归检查的效率，对游戏行业的QA团队和开发者具有实际价值。

Abstract: Modern game studios deliver new builds and patches at a rapid pace,
generating thousands of bug reports, many of which embed gameplay videos. To
verify and triage these bug reports, developers must watch the submitted
videos. This manual review is labour-intensive, slow, and hard to scale. In
this paper, we introduce an automated pipeline that reduces each video to a
single frame that best matches the reported bug description, giving developers
instant visual evidence that pinpoints the bug.
  Our pipeline begins with FFmpeg for keyframe extraction, reducing each video
to a median of just 1.90% of its original frames while still capturing bug
moments in 98.79 of cases. These keyframes are then evaluated by a
vision--language model (GPT-4o), which ranks them based on how well they match
the textual bug description and selects the most representative frame. We
evaluated this approach using real-world developer-submitted gameplay videos
and JIRA bug reports from a popular First-Person Shooter (FPS) game. The
pipeline achieves an overall F1 score of 0.79 and Accuracy of 0.89 for the
top-1 retrieved frame. Performance is highest for the Lighting & Shadow (F1 =
0.94), Physics & Collision (0.86), and UI & HUD (0.83) bug categories, and
lowest for Animation & VFX (0.51).
  By replacing video viewing with an immediately informative image, our
approach dramatically reduces manual effort and speeds up triage and regression
checks, offering practical benefits to quality assurance (QA) teams and
developers across the game industry.

</details>


### [3] [Charting Uncertain Waters: A Socio-Technical Framework for Navigating GenAI's Impact on Open Source Communities](https://arxiv.org/abs/2508.04921)
*Zixuan Feng,Reed Milewicz,Emerson Murphy-Hill,Tyler Menezes,Alexander Serebrenik,Igor Steinmacher,Anita Sarma*

Main category: cs.SE

TL;DR: 开源软件社区面临生成式AI带来的不确定性，需通过社会技术框架探索风险与机遇。


<details>
  <summary>Details</summary>
Motivation: 生成式AI正在改变软件的创建、维护和治理方式，开源社区需应对其带来的复杂性和模糊性。

Method: 采用基于McLuhan四元法的社会技术框架，进行情景驱动的概念性探索。

Result: 在软件实践、文档、社区参与和治理四个领域，识别了生成式AI对开源社区的潜在影响。

Conclusion: 开源社区领导者和研究者应主动塑造生态系统的未来，而非被动应对技术变革。

Abstract: Open Source Software communities face a wave of uncertainty as Generative AI
rapidly transforms how software is created, maintained, and governed. Without
clear frameworks, communities risk being overwhelmed by the complexity and
ambiguity introduced by GenAI, threatening the collaborative ethos that
underpins OSS. We conduct a scenario-driven, conceptual exploration using a
socio-technical framework inspired by McLuhan's Tetrad to surface both risks
and opportunities for community resilience amid GenAI-driven disruption of OSS
development across four domains: software practices, documentation, community
engagement, and governance. By adopting this lens, OSS leaders and researchers
can proactively shape the future of their ecosystems, rather than simply
reacting to technological upheaval.

</details>


### [4] [Taxonomy of Faults in Attention-Based Neural Networks](https://arxiv.org/abs/2508.04925)
*Sigma Jahan,Saurabh Singh Rajput,Tushar Sharma,Mohammad Masudur Rahman*

Main category: cs.SE

TL;DR: 论文通过分析555个真实故障，提出了注意力机制特有的七类故障分类，并提供了诊断启发式方法。


<details>
  <summary>Details</summary>
Motivation: 现有深度学习故障分类未能充分涵盖注意力机制引入的独特故障，导致缺乏可操作的诊断指导。

Method: 系统分析了来自96个项目、十个框架的555个真实故障，开发了新的注意力机制故障分类。

Result: 超过一半的注意力网络故障源于其特有机制，研究提出了四类诊断启发式方法，解释了33%的故障。

Conclusion: 研究填补了注意力机制故障分类的空白，为实践者提供了系统化的诊断指导。

Abstract: Attention mechanisms are at the core of modern neural architectures, powering
systems ranging from ChatGPT to autonomous vehicles and driving a major
economic impact. However, high-profile failures, such as ChatGPT's nonsensical
outputs or Google's suspension of Gemini's image generation due to attention
weight errors, highlight a critical gap: existing deep learning fault
taxonomies might not adequately capture the unique failures introduced by
attention mechanisms. This gap leaves practitioners without actionable
diagnostic guidance. To address this gap, we present the first comprehensive
empirical study of faults in attention-based neural networks (ABNNs). Our work
is based on a systematic analysis of 555 real-world faults collected from 96
projects across ten frameworks, including GitHub, Hugging Face, and Stack
Overflow. Through our analysis, we develop a novel taxonomy comprising seven
attention-specific fault categories, not captured by existing work. Our results
show that over half of the ABNN faults arise from mechanisms unique to
attention architectures. We further analyze the root causes and manifestations
of these faults through various symptoms. Finally, by analyzing symptom-root
cause associations, we identify four evidence-based diagnostic heuristics that
explain 33.0% of attention-specific faults, offering the first systematic
diagnostic guidance for attention-based models.

</details>


### [5] [Generative AI for Object-Oriented Programming: Writing the Right Code and Reasoning the Right Logic](https://arxiv.org/abs/2508.05005)
*Gang Xu,Airong Wang,Yushan Pan*

Main category: cs.SE

TL;DR: 探索大型语言模型（LLMs）与面向对象编程（OOP）的结合点，提出如何利用LLMs提升OOP学习和代码编写的效率，并评估AI工具的效果。


<details>
  <summary>Details</summary>
Motivation: 当前LLMs与OOP的结合研究不足，缺乏对LLMs如何提升OOP学习和代码编写的理解，以及如何评估相关AI工具。

Method: 从程序员、新手和经验丰富的程序员等关键利益相关者的视角，分析典型编码流程中LLMs的潜在应用点。

Result: 识别了LLMs在编码流程中的关键应用场景，并提出了增强逻辑推理和代码编写的方法。

Conclusion: LLMs在OOP领域具有巨大潜力，未来可进一步优化编程体验。

Abstract: We find ourselves in the midst of an explosion in artificial intelligence
research, particularly with large language models (LLMs). These models have
diverse applications spanning finance, commonsense knowledge graphs, medicine,
and visual analysis. In the world of Object-Oriented Programming(OOP), a robust
body of knowledge and methods has been developed for managing complex tasks
through object-oriented thinking. However, the intersection of LLMs with OOP
remains an underexplored territory. Empirically, we currently possess limited
understanding of how LLMs can enhance the effectiveness of OOP learning and
code writing, as well as how we can evaluate such AI-powered tools. Our work
aims to address this gap by presenting a vision from the perspectives of key
stakeholders involved in an OOP task: programmers, mariners, and experienced
programmers. We identify critical junctures within typical coding workflows
where the integration of LLMs can offer significant benefits. Furthermore, we
propose ways to augment existing logical reasoning and code writing, ultimately
enhancing the programming experience.

</details>


### [6] [An ML-based Approach to Predicting Software Change Dependencies: Insights from an Empirical Study on OpenStack](https://arxiv.org/abs/2508.05034)
*Arabat,Ali,Sayagh,Mohammed,Hassine,Jameleddine*

Main category: cs.SE

TL;DR: 论文研究了大型软件系统中变更依赖管理的重要性，提出了一种半自动化的机器学习方法，用于预测和识别依赖关系。


<details>
  <summary>Details</summary>
Motivation: 随着软件系统复杂度的增加，准确识别和管理变更依赖变得至关重要，尤其是在跨团队多组件的情况下。

Method: 研究基于OpenStack的初步调查，提出两种机器学习模型：一种预测变更间依赖的可能性，另一种识别具体的依赖对。

Result: 模型表现良好，平均AUC分数分别为79.33%和91.89%，Brier分数为0.11和0.014。

Conclusion: 该方法能帮助开发者更早识别依赖关系，但仍有改进空间，尤其是在精确度方面。

Abstract: As software systems grow in complexity, accurately identifying and managing
dependencies among changes becomes increasingly critical. For instance, a
change that leverages a function must depend on the change that introduces it.
Establishing such dependencies allows CI/CD pipelines to build and orchestrate
changes effectively, preventing build failures and incomplete feature
deployments. In modern software systems, dependencies often span multiple
components across teams, creating challenges for development and deployment.
They serve various purposes, from enabling new features to managing
configurations, and can even involve traditionally independent changes like
documentation updates. To address these challenges, we conducted a preliminary
study on dependency management in OpenStack, a large-scale software system. Our
study revealed that a substantial portion of software changes in OpenStack over
the past 10 years are interdependent. Surprisingly, 51.08% of these
dependencies are identified during the code review phase-after a median delay
of 5.06 hours-rather than at the time of change creation. Developers often
spend a median of 57.12 hours identifying dependencies, searching among a
median of 463 other changes. To help developers proactively identify
dependencies, we propose a semi-automated approach that leverages two ML
models. The first model predicts the likelihood of dependencies among changes,
while the second identifies the exact pairs of dependent changes. Our proposed
models demonstrate strong performance, achieving average AUC scores of 79.33%
and 91.89%, and Brier scores of 0.11 and 0.014, respectively. Indeed, the
second model has a good top-k recall across all types of pairs, while the top-k
precision has room for improvement.

</details>


### [7] [LadyBug: A GitHub Bot for UI-Enhanced Bug Localization in Mobile Apps](https://arxiv.org/abs/2508.05085)
*Junayed Mahmud,James Chen,Terry Achille,Camilo Alvarez-Velez,Darren Dean Bansil,Patrick Ijieh,Samar Karanch,Nadeeshan De Silva,Oscar Chaparro,Andrian Marcus,Kevin Moran*

Main category: cs.SE

TL;DR: LadyBug是一个GitHub机器人，通过结合UI交互信息和文本检索，自动定位Android应用中的bug。


<details>
  <summary>Details</summary>
Motivation: 提高Android应用中bug定位的准确性和效率，减少开发者的手动调试时间。

Method: LadyBug连接到GitHub仓库，通过问题追踪器触发，开发者上传bug重现轨迹，结合文本描述和UI信息进行文件检索。

Result: 在包含80个bug报告的基准测试中，LadyBug优于纯文本检索方法，UI信息显著提高了定位准确性。

Conclusion: LadyBug是一个有效的开源工具，能显著提升Android应用bug定位的效率和准确性。

Abstract: This paper introduces LadyBug, a GitHub bot that automatically localizes bugs
for Android apps by combining UI interaction information with text retrieval.
LadyBug connects to an Android app's GitHub repository, and is triggered when a
bug is reported in the corresponding issue tracker. Developers can then record
a reproduction trace for the bug on a device or emulator and upload the trace
to LadyBug via the GitHub issue tracker. This enables LadyBug to utilize both
the text from the original bug description, and UI information from the
reproduction trace to accurately retrieve a ranked list of files from the
project that most likely contain the reported bug.
  We empirically evaluated LadyBug using an automated testing pipeline and
benchmark called RedWing that contains 80 fully-localized and reproducible bug
reports from 39 Android apps. Our results illustrate that LadyBug outperforms
text-retrieval-based baselines and that the utilization of UI information leads
to a substantial increase in localization accuracy. LadyBug is an open-source
tool, available at https://github.com/LadyBugML/ladybug.
  A video showing the capabilities of Ladybug can be viewed here:
https://youtu.be/hI3tzbRK0Cw

</details>


### [8] [Posterior-GRPO: Rewarding Reasoning Processes in Code Generation](https://arxiv.org/abs/2508.05170)
*Lishui Fan,Yu Zhang,Mouxiang Chen,Zhongxin Liu*

Main category: cs.SE

TL;DR: 论文提出了一种结合推理过程质量的强化学习框架，通过LCB-RB基准和OD-based奖励模型训练方法，以及P-GRPO算法，显著提升了代码生成的性能。


<details>
  <summary>Details</summary>
Motivation: 当前基于测试结果的强化学习方法忽视了中间推理过程的质量，容易导致奖励黑客问题，影响最终结果。

Method: 开发了LCB-RB基准和OD-based奖励模型训练方法，并提出了P-GRPO算法，将推理奖励与任务成功挂钩。

Result: 7B参数模型在代码生成任务中表现优异，超越基线4.5%，接近GPT-4-Turbo水平，并成功推广至数学任务。

Conclusion: 该框架有效解决了奖励黑客问题，提升了推理质量，具有广泛适用性。

Abstract: Reinforcement learning (RL) has significantly advanced code generation for
large language models (LLMs). However, current paradigms rely on outcome-based
rewards from test cases, neglecting the quality of the intermediate reasoning
process. While supervising the reasoning process directly is a promising
direction, it is highly susceptible to reward hacking, where the policy model
learns to exploit the reasoning reward signal without improving final outcomes.
To address this, we introduce a unified framework that can effectively
incorporate the quality of the reasoning process during RL. First, to enable
reasoning evaluation, we develop LCB-RB, a benchmark comprising preference
pairs of superior and inferior reasoning processes. Second, to accurately score
reasoning quality, we introduce an Optimized-Degraded based (OD-based) method
for reward model training. This method generates high-quality preference pairs
by systematically optimizing and degrading initial reasoning paths along
curated dimensions of reasoning quality, such as factual accuracy, logical
rigor, and coherence. A 7B parameter reward model with this method achieves
state-of-the-art (SOTA) performance on LCB-RB and generalizes well to other
benchmarks. Finally, we introduce Posterior-GRPO (P-GRPO), a novel RL method
that conditions process-based rewards on task success. By selectively applying
rewards to the reasoning processes of only successful outcomes, P-GRPO
effectively mitigates reward hacking and aligns the model's internal reasoning
with final code correctness. A 7B parameter model with P-GRPO achieves superior
performance across diverse code generation tasks, outperforming outcome-only
baselines by 4.5%, achieving comparable performance to GPT-4-Turbo. We further
demonstrate the generalizability of our approach by extending it to
mathematical tasks. Our models, dataset, and code are publicly available.

</details>


### [9] [AI-assisted JSON Schema Creation and Mapping](https://arxiv.org/abs/2508.05192)
*Felix Neubauer,Jürgen Pleiss,Benjamin Uekermann*

Main category: cs.SE

TL;DR: 提出了一种结合大语言模型（LLMs）和确定性技术的混合方法，用于通过自然语言输入创建和修改JSON Schema，并集成到开源工具MetaConfigurator中。


<details>
  <summary>Details</summary>
Motivation: 许多领域缺乏标准化模型，且非专家难以创建模型，因此需要一种更易用的方法。

Method: 结合LLMs和确定性技术，支持自然语言输入生成JSON Schema和模式映射，并通过MetaConfigurator工具实现。

Result: 在化学领域展示了应用实例，显著降低了非专家进行结构化数据建模和数据整合的门槛。

Conclusion: 通过自然语言交互与确定性保障的结合，为非专家提供了更便捷的数据建模和整合解决方案。

Abstract: Model-Driven Engineering (MDE) places models at the core of system and data
engineering processes. In the context of research data, these models are
typically expressed as schemas that define the structure and semantics of
datasets. However, many domains still lack standardized models, and creating
them remains a significant barrier, especially for non-experts. We present a
hybrid approach that combines large language models (LLMs) with deterministic
techniques to enable JSON Schema creation, modification, and schema mapping
based on natural language inputs by the user. These capabilities are integrated
into the open-source tool MetaConfigurator, which already provides visual model
editing, validation, code generation, and form generation from models. For data
integration, we generate schema mappings from heterogeneous JSON, CSV, XML, and
YAML data using LLMs, while ensuring scalability and reliability through
deterministic execution of generated mapping rules. The applicability of our
work is demonstrated in an application example in the field of chemistry. By
combining natural language interaction with deterministic safeguards, this work
significantly lowers the barrier to structured data modeling and data
integration for non-experts.

</details>


### [10] [STEPWISE-CODEX-Bench: Evaluating Complex Multi-Function Comprehension and Fine-Grained Execution Reasoning](https://arxiv.org/abs/2508.05193)
*Kaiwen Yan,Yuhang Chang,Zirui Guo,Yaling Mou,Jiang Ming,Jingwei Sun*

Main category: cs.SE

TL;DR: SX-Bench是一个新的代码理解与推理基准，专注于复杂多函数场景和细粒度执行推理，揭示了主流模型在高级推理任务中的瓶颈。


<details>
  <summary>Details</summary>
Motivation: 现有基准（如HumanEval和MBPP）主要评估功能正确性，而推理基准（如CRUXEVAL）局限于单函数低复杂度场景，导致高级模型得分饱和，缺乏区分力。

Method: SX-Bench通过多子函数协作任务（如链式调用、嵌套循环）评估整体控制和数据流建模，以“计算步骤”为最小执行单元，要求模型预测推理任务的总步骤数。

Result: 评估20多个主流模型（包括14个推理增强模型）显示，SX-Bench区分力强：OpenAI-O3在Hard-Reasoning任务中仅78.37%准确率，远低于其在传统基准上的饱和得分。

Conclusion: SX-Bench将代码评估从“单函数验证”推进到“多函数动态推理”，为高级代码智能模型的深度评估提供了关键工具。

Abstract: In recent years, large language models (LLMs) have made significant progress
in code intelligence, yet systematically evaluating their code understanding
and reasoning abilities remains challenging. Mainstream benchmarks such as
HumanEval and MBPP primarily assess functional correctness, while reasoning
benchmarks like CRUXEVAL are limited to single-function, low-complexity
scenarios. As a result, advanced models achieve nearly saturated scores,
limiting their discriminative power. To address this, we present
STEPWISE-CODEX-Bench (SX-Bench), a novel benchmark designed for complex
multi-function understanding and fine-grained execution reasoning. SX-Bench
features tasks involving collaboration among multiple sub-functions (e.g.,
chained calls, nested loops), shifting evaluation towards overall control and
data flow modeling. It defines "computation steps" as the minimal execution
unit and requires models to predict the total number of steps in reasoning
tasks, thereby assessing a model's in-depth understanding of dynamic execution
beyond simple I/O matching. Evaluation on over 20 mainstream models (including
14 reasoning-enhanced models) demonstrates that SX-Bench is highly
discriminative: even the state-of-the-art OpenAI-O3 achieves only 78.37 percent
accuracy on Hard-Reasoning tasks, much lower than its saturated scores on
previous benchmarks, thereby revealing bottlenecks in complex and fine-grained
reasoning. We also release an automated pipeline combining program synthesis,
symbolic execution, and LLM-aided validation for efficient benchmark generation
and quality assurance. SX-Bench advances code evaluation from "single-function
verification" to "multi-function dynamic reasoning," providing a key tool for
the in-depth assessment of advanced code intelligence models.

</details>


### [11] [EvoGraph: Hybrid Directed Graph Evolution toward Software 3.0](https://arxiv.org/abs/2508.05199)
*Igor Costa,Christopher Baran*

Main category: cs.SE

TL;DR: EvoGraph是一个框架，通过类型化有向图表示软件系统的各种构件，利用小型语言模型驱动突变操作，实现代码、文档等的自动演化。在多个任务中表现优异，如修复漏洞、代码翻译和文档更新。


<details>
  <summary>Details</summary>
Motivation: 解决传统软件系统在代码演化、文档维护和现代化改造中的低效问题，特别是针对遗留系统的现代化挑战。

Method: 使用类型化有向图表示构件，通过小型语言模型驱动突变操作，并结合多目标适应度选择幸存者。

Result: 在安全漏洞修复、代码翻译和文档更新等任务中表现优异，显著降低了延迟和开发时间。

Conclusion: EvoGraph为软件系统的持续自适应提供了一条可行路径，同时保持可控性。

Abstract: We introduce **EvoGraph**, a framework that enables software systems to
evolve their own source code, build pipelines, documentation, and tickets.
EvoGraph represents every artefact in a typed directed graph, applies learned
mutation operators driven by specialized small language models (SLMs), and
selects survivors with a multi-objective fitness. On three benchmarks, EvoGraph
fixes 83% of known security vulnerabilities, translates COBOL to Java with 93%
functional equivalence (test verified), and maintains documentation freshness
within two minutes. Experiments show a 40% latency reduction and a sevenfold
drop in feature lead time compared with strong baselines. We extend our
approach to **evoGraph**, leveraging language-specific SLMs for modernizing
.NET, Lisp, CGI, ColdFusion, legacy Python, and C codebases, achieving 82-96%
semantic equivalence across languages while reducing computational costs by 90%
compared to large language models. EvoGraph's design responds to empirical
failure modes in legacy modernization, such as implicit contracts, performance
preservation, and integration evolution. Our results suggest a practical path
toward Software 3.0, where systems adapt continuously yet remain under
measurable control.

</details>


### [12] [A Conceptual Model and Methodology for Sustainability-aware, IoT-enhanced Business Processes](https://arxiv.org/abs/2508.05301)
*Victoria Torres Bosch,Ronny Seiger,Manuela Albert Albiol,Antoni Mestre Gascon,Pedro Jose Valderas Aranda*

Main category: cs.SE

TL;DR: 本文提出了一种概念模型和方法论，旨在通过物联网（IoT）技术提升业务流程（BPs）的可持续性，并展示了在旅游和医疗领域的应用案例。


<details>
  <summary>Details</summary>
Motivation: 尽管业务流程管理（BPM）中的可持续性研究主要关注环境问题，但实现全面和持久的可持续性影响需要超越环境维度的系统性方法。

Method: 提出了一个概念模型和结构化方法论，用于分析物联网如何测量和改善业务流程的可持续性。模型将BPM和IoT联系起来，方法论则指导对现有业务流程的系统分析。

Result: 通过旅游和医疗领域的案例研究，展示了该方法论的实际应用效果。

Conclusion: 该研究为利用IoT技术提升业务流程的可持续性提供了系统化的理论框架和实践指导。

Abstract: The real-time data collection and automation capabilities offered by the
Internet of Things (IoT) are revolutionizing and transforming Business
Processes (BPs) into IoT-enhanced BPs, showing high potential for improving
sustainability. Although already studied in Business Process Management (BPM),
sustainability research has primarily focused on environmental concerns.
However, achieving a holistic and lasting impact requires a systematic approach
to address sustainability beyond the environmental dimension. This work
proposes a conceptual model and a structured methodology with the goal of
analyzing the potential of IoT to measure and improve the sustainability of
BPs. The conceptual model formally represents key sustainability concepts,
linking BPM and IoT by highlighting how IoT devices support and contribute to
sustainability. The methodology guides the systematic analysis of existing BPs,
identifies opportunities, and implements sustainability-aware, IoT-enhanced
BPs. The approach is illustrated through a running example from the tourism
domain and a case study in healthcare.

</details>


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [13] [Consistent Updates for Scalable Microservices](https://arxiv.org/abs/2508.04829)
*Devora Chait-Roth,Kedar S. Namjoshi,Thomas Wies*

Main category: cs.PL

TL;DR: 本文提出了首个保证混合模式更新一致性的算法，利用服务行为的语义属性（如交换性），并证明了语义感知的必要性。


<details>
  <summary>Details</summary>
Motivation: 在线服务通常采用可扩展的微服务架构，但动态修改服务功能时，避免因混合模式操作导致的不一致性具有挑战性。

Method: 提出基于服务动作语义属性的算法，并开发了一个形式化框架和理论基础，用于推理混合模式更新的一致性。

Result: 证明了语义感知是避免不一致性的必要条件，并提出了新的算法，确保客户端感知到原子性更新。

Conclusion: 通过语义感知和形式化框架，本文解决了混合模式更新的核心挑战，为在线服务动态更新提供了理论支持和实用算法。

Abstract: Online services are commonly implemented with a scalable microservice
architecture, where isomorphic worker processes service client requests,
recording persistent state in a backend data store. To maintain service, any
modifications to the service functionality must be made on the fly -- i.e., as
the service continues to process client requests -- but doing so is
challenging. The central difficulty is that of avoiding potential
inconsistencies caused by ''mixed mode'' operation, where workers of current
and new versions are concurrently active and interact via the data store. Some
update methods avoid mixed mode altogether, but only at the cost of substantial
inefficiency -- by doubling resources (memory and compute), or by halving
throughput. The alternative is a so-called ''rolling'' update, which is
uncontrolled and runs the risk of serious service failures arising from
inconsistent mixed-mode behavior.
  In this paper, we present the first algorithms that guarantee consistency for
mixed mode updates. The algorithms rely on semantic properties of service
actions, such as commutativity. We show that semantic awareness is required, by
proving that any semantically oblivious, mixed-mode update method cannot avoid
inconsistencies. Ideally, it should appear to every client that a service
update takes effect atomically; this ensures that a client is not exposed to
inconsistent mixed-mode behavior. We introduce a framework that formalizes this
intuition and develop foundational theory for reasoning about the consistency
of mixed-mode updates, applying that theory to derive the new algorithms and
establish their correctness.

</details>
